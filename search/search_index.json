{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dash_charts \u2693\ufe0e Note In 2019-2020, I was building applications with Dash and wanted a way to make them more composable and reusable. Since then, I moved on to other projects and Dash has become far more composable. Dash expanded plotly express and introduced templates along with other changes as the ecosystem has evolved! Given the advances in Dash, I\u2019m going to archive this project, publish a final release to PyPi, and move on to other projects Python package for Plotly/Dash apps with support for multi-page, modules, and new charts such as Pareto with an Object Orient Approach Includes base classes for building a custom chart or application, new charts such as a Pareto, and base classes for tabbed or multi-page applications. See full documentation at https://kyleking.me/dash_charts/ . ( TODO: Currently not online ) dash_charts Nov2020-Mar2021 Updates Quick Start 1. Install 2. Example Code 3. Resulting Pareto Chart 4. Additional Notes Design Principles Local Development Example Charts and Tables Pareto Chart Gantt Chart Time Vis Chart Rolling Mean and STD Chart Fitted Chart Real Time SQL Demo Coordinate Chart Marginal Chart Data Table Module Upload Module Applications Tabbed Application Multi-Page Application PX Generic Application Other Cache Static HTML Generation Coverage External Links Installation Usage Roadmap Contributing License Quick Start \u2693\ufe0e 1. Install \u2693\ufe0e With Poetry install dash_charts with: poetry add dash_charts --git https://github.com/KyleKing/dash_charts.git#main 2. Example Code \u2693\ufe0e \"\"\"Example Dash Application.\"\"\" from typing import Optional import dash from dash import html import plotly.express as px from box import Box from implements import implements from dash_charts.pareto_chart import ParetoChart from dash_charts.utils_app import AppBase , AppInterface from dash_charts.utils_fig import min_graph # FIXME: the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases # Still pending if this is the preferred approach _ID = Box ({ 'chart' : 'pareto' , }) \"\"\"Default App IDs.\"\"\" @implements ( AppInterface ) class ParetoDemo ( AppBase ): \"\"\"Example creating a simple Pareto chart.\"\"\" def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : \"\"\"Initialize app and initial data members. Should be inherited in child class and called with super(). Args: app: Dash instance. If None, will create standalone app. Otherwise, will be part of existing app \"\"\" self . name = 'Car Share Pareto Demo' self . data_raw = None self . chart_main = None self . _id = _ID super () . __init__ ( app = app ) def generate_data ( self ) -> None : \"\"\"Format the car share data from plotly express for the Pareto. Called by parent class.\"\"\" self . data_raw = ( px . data . carshare () . rename ( columns = { 'peak_hour' : 'category' , 'car_hours' : 'value' })) self . data_raw [ 'category' ] = [ f 'H: { cat : 02 } ' for cat in self . data_raw [ 'category' ]] def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" self . chart_main = ParetoChart ( title = 'Car Share Pareto' , xlabel = 'Peak Hours' , ylabel = 'Car Hours' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . Div ([ min_graph ( id = self . _il [ self . _id . chart ], figure = self . chart_main . create_figure ( df_raw = self . data_raw ), )]), ]) def create_callbacks ( self ) -> None : \"\"\"Register the callbacks.\"\"\" pass # Override base class. Not necessary for this example if __name__ == '__main__' : app = ParetoDemo () app . create () app . run ( debug = True ) else : app = instance () app . create () FLASK_HANDLE = app . get_server () 3. Resulting Pareto Chart \u2693\ufe0e 4. Additional Notes \u2693\ufe0e TO get the most out of the tools, you may want to add calcipy and add the below snippets to your pyproject.toml file [tool.poetry.dev-dependencies.dash] extras = [ \"testing\" ,] version = \"*, ^1.19\" [tool.poetry.dependencies.calcipy] git = \"https://github.com/kyleking/calcipy.git\" branch = \"dev/development\" rev = \"01635ea\" # Always pin to a commit develop = true # Optional: will reinstall each time [tool.poetry.dev-dependencies.calcipy] git = \"https://github.com/kyleking/calcipy.git\" branch = \"dev/development\" extras = [ \"dev\" , \"lint\" , \"test\" , \"commitizen_legacy\" ] You will also want at minimum the dodo.py and folder structure from dash_charts Design Principles \u2693\ufe0e I wanted to show that an object oriented programming approach to Dash projects could be really powerful for improving code reuse and improving readability in large projects. Below are a couple of design principles to keep that I try to keep in mind when implementing this package. Try to encapsulate all application logic (callbacks, ids, etc.) in application classes or modules For components that are reused between application, create a module . The layout, state, and callbacks can all be delegated to the module rather than cluttering the main application\u2019s class and allowing for better code reuse Move any methods that do not require state ( self ) into standalone functions If you can separate Dash (ids/layout/Callbacks) and Plotly (figures/tables) code, you can generate static HTML or PNGs more easily. Sometimes static output is useful when programmatically generating views rather than tweaking the interactive inputs each time. Overall, I find that this package really improves my Dash code and I hope others find it useful. Please feel free to submit PRs or open issues if you have any input. See ./DESIGN.md for additional information on design decisions and package architecture Local Development \u2693\ufe0e Initial commands to clone code from Github, create Python virtual environment, and run first example application git clone https://github.com/KyleKing/dash_charts.git cd dash_charts poetry install poetry shell python tests/examples/ex_app_px.py Other useful scripts for testing, documentation, and more: poetry run ptw -- -m \"not INTERACTIVE\" poetry run doit run test poetry run doit Example Charts and Tables \u2693\ufe0e Below are screenshots and links to the example code for each chart or table included in dash_charts Pareto Chart \u2693\ufe0e Create Pareto charts in Dash. Handles ordering the category, calculating the cumulative percentage, and configuring both YAxis. See sample code in tests/examples/ex_pareto_chart.py . Screenshot below: Gantt Chart \u2693\ufe0e Create simple Gantt charts in Dash. Doesn\u2019t support more advanced features such as dependencies and resource assignment, but effectively shows tasks, progress, and projects in a clear way. You can toggle the different projects on/off and use zoom like a normal Plotly chart. See sample code in tests/examples/ex_gantt_chart.py . Screenshot below: Time Vis Chart \u2693\ufe0e Create a TimeVis chart to plot general time visualizations (based on daattali/timevis from R). This chart differs from a Gantt chart by showing events that repeat in the same row. See sample code in tests/examples/ex_time_vis_chart.py . Screenshot below: Rolling Mean and STD Chart \u2693\ufe0e Easily chart the rolling mean and standard deviation for a given scatter data set. Demonstrates using chart annotations. See sample code in tests/examples/ex_rolling_chart.py . Screenshot below: Fitted Chart \u2693\ufe0e Fit arbitrary scatter data with a specified equation. On hover will show the rounded fit parameters. Useful for experimenting with new data. See sample code in tests/examples/ex_fitted_chart.py . Screenshot below: Real Time SQL Demo \u2693\ufe0e Example using a Rolling Chart to show real time data from a SQLite database. For the demo, a background thread populates the database as the Dash app runs in a separate thread. See sample code in tests/examples/ex_sqlite_realtime.py . Screenshot below: Coordinate Chart \u2693\ufe0e Chart a discrete data set on a 2D plane with color for intensity. Below examples show how to use the YearGrid() , MonthGrid() , and CircleGrid() classes See sample code in tests/examples/ex_coordinate_chart.py . Screenshot below: Marginal Chart \u2693\ufe0e Example creating a new chart from utils_fig.MarginalChart See sample code in tests/examples/ex_marginal_chart.py . Screenshot below: Data Table Module \u2693\ufe0e Display Dash data table from dataframe See sample code in tests/examples/ex_datatable.py . Screenshot below: Upload Module \u2693\ufe0e Upload module for user-selected CSV, JSON, or SQLite files. See sample code in tests/examples/ex_upload.py . Screenshot below: Applications \u2693\ufe0e Every app derives from AppBase() so that each tab or page can be run independently or part of a more complicated application Tabbed Application \u2693\ufe0e Use the AppWithTabs() base class to quickly build applications with tabbed navigation. You can set tabs to the top/bottom/left/right, to be compact or not, etc. See sample code in tests/examples/ex_tabs.py . Screenshot below: Multi-Page Application \u2693\ufe0e Use the AppMultiPage() base class to quickly build applications with tabbed navigation. You can set tabs to the top/bottom/left/right, to be compact or not, etc. See sample code in tests/examples/ex_multi_page.py . Screenshot below: PX Generic Application \u2693\ufe0e To facilitate general data analysis from a JSON, CSV, or SQLite file, dash_charts includes apps for each px plot type and a tabbed app to bring them all together. See sample code in tests/examples/ex_app_px.py . Screenshot below: Other \u2693\ufe0e Other notable components in dash_charts Cache \u2693\ufe0e Utilities for utilizing a local cache file system for storing JSON data. Particularly useful if scraping or making many API calls to cache the responses locally. See sample code in the relevant test file tests/test_utils_json_cache.py Static HTML Generation \u2693\ufe0e utilities for creating static HTML output with all of the CustomCharts above or user-created. Also includes utilities for writing tables, code, markdown, and more to be added. See sample code in tests/examples/ex_utils_static.py . Screenshot below: Coverage \u2693\ufe0e Latest coverage table File Statements Missing Excluded Coverage dash_charts/__init__.py 2 0 0 100.0% dash_charts/app_px.py 130 11 0 91.5% dash_charts/components.py 13 0 0 100.0% dash_charts/coordinate_chart.py 102 1 6 99.0% dash_charts/custom_colorscales.py 3 0 0 100.0% dash_charts/datatable.py 79 25 0 68.4% dash_charts/equations.py 11 0 0 100.0% dash_charts/gantt_chart.py 54 0 0 100.0% dash_charts/modules_datatable.py 101 11 0 89.1% dash_charts/modules_upload.py 132 60 0 54.5% dash_charts/pareto_chart.py 43 0 2 100.0% dash_charts/scatter_line_charts.py 45 0 3 100.0% dash_charts/time_vis_chart.py 61 0 0 100.0% dash_charts/utils_app.py 98 14 6 85.7% dash_charts/utils_app_modules.py 26 3 4 88.5% dash_charts/utils_app_with_navigation.py 119 9 6 92.4% dash_charts/utils_callbacks.py 34 6 0 82.4% dash_charts/utils_data.py 63 1 0 98.4% dash_charts/utils_dataset.py 76 43 0 43.4% dash_charts/utils_fig.py 77 2 4 97.4% dash_charts/utils_helpers.py 17 8 7 52.9% dash_charts/utils_json_cache.py 51 10 0 80.4% dash_charts/utils_static.py 111 5 0 95.5% dash_charts/utils_static_toc.py 22 1 0 95.5% Generated on: 2020-11-08T22:46:27.420973 External Links \u2693\ufe0e Useful Dash reference links Official Dash Docs / Plotly Docs Example Apps Pretty annotations from Market Ahead , a commercial Dash app Pleasant dark app from Dash-Bio, Circos All Dash Sample Apps Code Conceptual inspiration On Tidy data Using field for properties in a @DataClass Best Practices IBM Design Language (note that v2 doesn\u2019t have documentation on visualization yet) Process Select Chart Alt Chart Decision Diagram Principles (color conventions, etc.) Color Library and Data Vis Swatches Interaction Style Colors Friendly Guide to Colors Viz-Palette Tool AI Color Palette / Coolors Reference Pandas CheatSheet for Data Manipulation Installation \u2693\ufe0e \u2026 \u2026 echo Hello World! \u2026 Usage \u2693\ufe0e For more examples, see Scripts or Tests Roadmap \u2693\ufe0e See the Open Issues and Milestones for current status and ./docs/CODE_TAG_SUMMARY.md for annotations in the source code. For release history, see the ./docs/CHANGELOG.md Contributing \u2693\ufe0e See the Developer Guide, Contribution Guidelines, etc ./docs/DEVELOPER_GUIDE.md ./docs/STYLE_GUIDE.md ./docs/CONTRIBUTING.md ./docs/CODE_OF_CONDUCT.md ./docs/SECURITY.md License \u2693\ufe0e LICENSE","title":"dash_charts"},{"location":"#dash_charts","text":"Note In 2019-2020, I was building applications with Dash and wanted a way to make them more composable and reusable. Since then, I moved on to other projects and Dash has become far more composable. Dash expanded plotly express and introduced templates along with other changes as the ecosystem has evolved! Given the advances in Dash, I\u2019m going to archive this project, publish a final release to PyPi, and move on to other projects Python package for Plotly/Dash apps with support for multi-page, modules, and new charts such as Pareto with an Object Orient Approach Includes base classes for building a custom chart or application, new charts such as a Pareto, and base classes for tabbed or multi-page applications. See full documentation at https://kyleking.me/dash_charts/ . ( TODO: Currently not online ) dash_charts Nov2020-Mar2021 Updates Quick Start 1. Install 2. Example Code 3. Resulting Pareto Chart 4. Additional Notes Design Principles Local Development Example Charts and Tables Pareto Chart Gantt Chart Time Vis Chart Rolling Mean and STD Chart Fitted Chart Real Time SQL Demo Coordinate Chart Marginal Chart Data Table Module Upload Module Applications Tabbed Application Multi-Page Application PX Generic Application Other Cache Static HTML Generation Coverage External Links Installation Usage Roadmap Contributing License","title":"dash_charts"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#1-install","text":"With Poetry install dash_charts with: poetry add dash_charts --git https://github.com/KyleKing/dash_charts.git#main","title":"1. Install"},{"location":"#2-example-code","text":"\"\"\"Example Dash Application.\"\"\" from typing import Optional import dash from dash import html import plotly.express as px from box import Box from implements import implements from dash_charts.pareto_chart import ParetoChart from dash_charts.utils_app import AppBase , AppInterface from dash_charts.utils_fig import min_graph # FIXME: the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases # Still pending if this is the preferred approach _ID = Box ({ 'chart' : 'pareto' , }) \"\"\"Default App IDs.\"\"\" @implements ( AppInterface ) class ParetoDemo ( AppBase ): \"\"\"Example creating a simple Pareto chart.\"\"\" def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : \"\"\"Initialize app and initial data members. Should be inherited in child class and called with super(). Args: app: Dash instance. If None, will create standalone app. Otherwise, will be part of existing app \"\"\" self . name = 'Car Share Pareto Demo' self . data_raw = None self . chart_main = None self . _id = _ID super () . __init__ ( app = app ) def generate_data ( self ) -> None : \"\"\"Format the car share data from plotly express for the Pareto. Called by parent class.\"\"\" self . data_raw = ( px . data . carshare () . rename ( columns = { 'peak_hour' : 'category' , 'car_hours' : 'value' })) self . data_raw [ 'category' ] = [ f 'H: { cat : 02 } ' for cat in self . data_raw [ 'category' ]] def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" self . chart_main = ParetoChart ( title = 'Car Share Pareto' , xlabel = 'Peak Hours' , ylabel = 'Car Hours' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . Div ([ min_graph ( id = self . _il [ self . _id . chart ], figure = self . chart_main . create_figure ( df_raw = self . data_raw ), )]), ]) def create_callbacks ( self ) -> None : \"\"\"Register the callbacks.\"\"\" pass # Override base class. Not necessary for this example if __name__ == '__main__' : app = ParetoDemo () app . create () app . run ( debug = True ) else : app = instance () app . create () FLASK_HANDLE = app . get_server ()","title":"2. Example Code"},{"location":"#3-resulting-pareto-chart","text":"","title":"3. Resulting Pareto Chart"},{"location":"#4-additional-notes","text":"TO get the most out of the tools, you may want to add calcipy and add the below snippets to your pyproject.toml file [tool.poetry.dev-dependencies.dash] extras = [ \"testing\" ,] version = \"*, ^1.19\" [tool.poetry.dependencies.calcipy] git = \"https://github.com/kyleking/calcipy.git\" branch = \"dev/development\" rev = \"01635ea\" # Always pin to a commit develop = true # Optional: will reinstall each time [tool.poetry.dev-dependencies.calcipy] git = \"https://github.com/kyleking/calcipy.git\" branch = \"dev/development\" extras = [ \"dev\" , \"lint\" , \"test\" , \"commitizen_legacy\" ] You will also want at minimum the dodo.py and folder structure from dash_charts","title":"4. Additional Notes"},{"location":"#design-principles","text":"I wanted to show that an object oriented programming approach to Dash projects could be really powerful for improving code reuse and improving readability in large projects. Below are a couple of design principles to keep that I try to keep in mind when implementing this package. Try to encapsulate all application logic (callbacks, ids, etc.) in application classes or modules For components that are reused between application, create a module . The layout, state, and callbacks can all be delegated to the module rather than cluttering the main application\u2019s class and allowing for better code reuse Move any methods that do not require state ( self ) into standalone functions If you can separate Dash (ids/layout/Callbacks) and Plotly (figures/tables) code, you can generate static HTML or PNGs more easily. Sometimes static output is useful when programmatically generating views rather than tweaking the interactive inputs each time. Overall, I find that this package really improves my Dash code and I hope others find it useful. Please feel free to submit PRs or open issues if you have any input. See ./DESIGN.md for additional information on design decisions and package architecture","title":"Design Principles"},{"location":"#local-development","text":"Initial commands to clone code from Github, create Python virtual environment, and run first example application git clone https://github.com/KyleKing/dash_charts.git cd dash_charts poetry install poetry shell python tests/examples/ex_app_px.py Other useful scripts for testing, documentation, and more: poetry run ptw -- -m \"not INTERACTIVE\" poetry run doit run test poetry run doit","title":"Local Development"},{"location":"#example-charts-and-tables","text":"Below are screenshots and links to the example code for each chart or table included in dash_charts","title":"Example Charts and Tables"},{"location":"#pareto-chart","text":"Create Pareto charts in Dash. Handles ordering the category, calculating the cumulative percentage, and configuring both YAxis. See sample code in tests/examples/ex_pareto_chart.py . Screenshot below:","title":"Pareto Chart"},{"location":"#gantt-chart","text":"Create simple Gantt charts in Dash. Doesn\u2019t support more advanced features such as dependencies and resource assignment, but effectively shows tasks, progress, and projects in a clear way. You can toggle the different projects on/off and use zoom like a normal Plotly chart. See sample code in tests/examples/ex_gantt_chart.py . Screenshot below:","title":"Gantt Chart"},{"location":"#time-vis-chart","text":"Create a TimeVis chart to plot general time visualizations (based on daattali/timevis from R). This chart differs from a Gantt chart by showing events that repeat in the same row. See sample code in tests/examples/ex_time_vis_chart.py . Screenshot below:","title":"Time Vis Chart"},{"location":"#rolling-mean-and-std-chart","text":"Easily chart the rolling mean and standard deviation for a given scatter data set. Demonstrates using chart annotations. See sample code in tests/examples/ex_rolling_chart.py . Screenshot below:","title":"Rolling Mean and STD Chart"},{"location":"#fitted-chart","text":"Fit arbitrary scatter data with a specified equation. On hover will show the rounded fit parameters. Useful for experimenting with new data. See sample code in tests/examples/ex_fitted_chart.py . Screenshot below:","title":"Fitted Chart"},{"location":"#real-time-sql-demo","text":"Example using a Rolling Chart to show real time data from a SQLite database. For the demo, a background thread populates the database as the Dash app runs in a separate thread. See sample code in tests/examples/ex_sqlite_realtime.py . Screenshot below:","title":"Real Time SQL Demo"},{"location":"#coordinate-chart","text":"Chart a discrete data set on a 2D plane with color for intensity. Below examples show how to use the YearGrid() , MonthGrid() , and CircleGrid() classes See sample code in tests/examples/ex_coordinate_chart.py . Screenshot below:","title":"Coordinate Chart"},{"location":"#marginal-chart","text":"Example creating a new chart from utils_fig.MarginalChart See sample code in tests/examples/ex_marginal_chart.py . Screenshot below:","title":"Marginal Chart"},{"location":"#data-table-module","text":"Display Dash data table from dataframe See sample code in tests/examples/ex_datatable.py . Screenshot below:","title":"Data Table Module"},{"location":"#upload-module","text":"Upload module for user-selected CSV, JSON, or SQLite files. See sample code in tests/examples/ex_upload.py . Screenshot below:","title":"Upload Module"},{"location":"#applications","text":"Every app derives from AppBase() so that each tab or page can be run independently or part of a more complicated application","title":"Applications"},{"location":"#tabbed-application","text":"Use the AppWithTabs() base class to quickly build applications with tabbed navigation. You can set tabs to the top/bottom/left/right, to be compact or not, etc. See sample code in tests/examples/ex_tabs.py . Screenshot below:","title":"Tabbed Application"},{"location":"#multi-page-application","text":"Use the AppMultiPage() base class to quickly build applications with tabbed navigation. You can set tabs to the top/bottom/left/right, to be compact or not, etc. See sample code in tests/examples/ex_multi_page.py . Screenshot below:","title":"Multi-Page Application"},{"location":"#px-generic-application","text":"To facilitate general data analysis from a JSON, CSV, or SQLite file, dash_charts includes apps for each px plot type and a tabbed app to bring them all together. See sample code in tests/examples/ex_app_px.py . Screenshot below:","title":"PX Generic Application"},{"location":"#other","text":"Other notable components in dash_charts","title":"Other"},{"location":"#cache","text":"Utilities for utilizing a local cache file system for storing JSON data. Particularly useful if scraping or making many API calls to cache the responses locally. See sample code in the relevant test file tests/test_utils_json_cache.py","title":"Cache"},{"location":"#static-html-generation","text":"utilities for creating static HTML output with all of the CustomCharts above or user-created. Also includes utilities for writing tables, code, markdown, and more to be added. See sample code in tests/examples/ex_utils_static.py . Screenshot below:","title":"Static HTML Generation"},{"location":"#coverage","text":"Latest coverage table File Statements Missing Excluded Coverage dash_charts/__init__.py 2 0 0 100.0% dash_charts/app_px.py 130 11 0 91.5% dash_charts/components.py 13 0 0 100.0% dash_charts/coordinate_chart.py 102 1 6 99.0% dash_charts/custom_colorscales.py 3 0 0 100.0% dash_charts/datatable.py 79 25 0 68.4% dash_charts/equations.py 11 0 0 100.0% dash_charts/gantt_chart.py 54 0 0 100.0% dash_charts/modules_datatable.py 101 11 0 89.1% dash_charts/modules_upload.py 132 60 0 54.5% dash_charts/pareto_chart.py 43 0 2 100.0% dash_charts/scatter_line_charts.py 45 0 3 100.0% dash_charts/time_vis_chart.py 61 0 0 100.0% dash_charts/utils_app.py 98 14 6 85.7% dash_charts/utils_app_modules.py 26 3 4 88.5% dash_charts/utils_app_with_navigation.py 119 9 6 92.4% dash_charts/utils_callbacks.py 34 6 0 82.4% dash_charts/utils_data.py 63 1 0 98.4% dash_charts/utils_dataset.py 76 43 0 43.4% dash_charts/utils_fig.py 77 2 4 97.4% dash_charts/utils_helpers.py 17 8 7 52.9% dash_charts/utils_json_cache.py 51 10 0 80.4% dash_charts/utils_static.py 111 5 0 95.5% dash_charts/utils_static_toc.py 22 1 0 95.5% Generated on: 2020-11-08T22:46:27.420973","title":"Coverage"},{"location":"#external-links","text":"Useful Dash reference links Official Dash Docs / Plotly Docs Example Apps Pretty annotations from Market Ahead , a commercial Dash app Pleasant dark app from Dash-Bio, Circos All Dash Sample Apps Code Conceptual inspiration On Tidy data Using field for properties in a @DataClass Best Practices IBM Design Language (note that v2 doesn\u2019t have documentation on visualization yet) Process Select Chart Alt Chart Decision Diagram Principles (color conventions, etc.) Color Library and Data Vis Swatches Interaction Style Colors Friendly Guide to Colors Viz-Palette Tool AI Color Palette / Coolors Reference Pandas CheatSheet for Data Manipulation","title":"External Links"},{"location":"#installation","text":"\u2026 \u2026 echo Hello World! \u2026","title":"Installation"},{"location":"#usage","text":"For more examples, see Scripts or Tests","title":"Usage"},{"location":"#roadmap","text":"See the Open Issues and Milestones for current status and ./docs/CODE_TAG_SUMMARY.md for annotations in the source code. For release history, see the ./docs/CHANGELOG.md","title":"Roadmap"},{"location":"#contributing","text":"See the Developer Guide, Contribution Guidelines, etc ./docs/DEVELOPER_GUIDE.md ./docs/STYLE_GUIDE.md ./docs/CONTRIBUTING.md ./docs/CODE_OF_CONDUCT.md ./docs/SECURITY.md","title":"Contributing"},{"location":"#license","text":"LICENSE","title":"License"},{"location":"CODE_TAG_SUMMARY/","text":"Task Summary \u2693\ufe0e Auto-Generated by dash_charts dash_charts/app_px.py line 65 PLANNED: template should be able to be None line 83 PLANNED: below items should be able to be None line 187 FIXME: replace tabs-select with actual keyname (?) dash_charts/coordinate_chart.py line 19 PLANNED: subplots for multiple years of calendar charts (Subplot title is year) line 335 PLANNED: make this configureable dash_charts/datatable.py line 5 TODO: See pattern mathing callbacks for adding buttons (to show modal) to datatables line 8 PLANNED: see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting line 10 PLANNED: These methods may be replaced in a future version of Dash line 87 PLANNED: Maybe move parameters to attr.ib classes? dash_charts/modules_upload.py line 76 PLANNED: Revisit. Should filename be a name or the full path? line 371 TODO: Add delete button for each table - need pattern matching callback: line 420 FIXME: Better handle NaN values\u2026 dash_charts/time_vis_chart.py line 5 NOTE: Consider automated (non-overlapping) text/event placement dash_charts/utils_app.py line 156 FIXME: Need to decide if there is a better approach. Reading this code is confusing\u2026 dash_charts/utils_app_with_navigation.py line 34 TODO: Try to see if I can resolve the interface differences or if I need make a subclass interface line 154 PLANNED: Make the tabs and chart compact as well when the compact argument is set to True line 361 TODO: Demo how pages could use parameters from pathname dash_charts/utils_data.py line 24 TODO: what does this set? line 84 PLANNED: Convert to FP and recursive calls? dash_charts/utils_json_cache.py line 14 FIXME: Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ line 32 TODO: Enable versioning of data and automatic deletion when the version changes dash_charts/utils_static_toc.py line 43 FIXME: Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) docs/README.md line 5 TODO: Currently not online ) line 48 FIXME: Keep updates up to date! \u2013> line 98 FIXME: the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases line 421 TODO: See https://github.com/KyleKing/calcipy/issues/38 \u2013> line 436 TODO: Show an example (screenshots, terminal recording, etc.) \u2013> dodo.py line 31 PLANNED: Move all of this into a function! (and/or task?) line 53 TODO: pypi package wasn\u2019t working. Used local version line 56 PLANNED: needs to be a bit more efficient\u2026 scripts/jsonl_viewer.py line 79 TODO: CLICKABLE POPUPS line 87 TODO: See: https://dash.plot.ly/datatable/interactivity line 93 TODO: Formatting (Typing): https://dash.plot.ly/datatable/typing tests/configuration.py line 15 PLANNED: Move all of this into a function! (and/or task?) {Duplicate of dodo.py} line 29 PLANNED: Output the test name and other information to the test.log file. Currently only used in no_log_errors line 30 PLANNED: move to dash_dev line 47 HACK: get_logs always return None with webdrivers other than Chrome line 48 FIXME: Handle path to the executable. Example with Firefox when the Gecko Drive is installed and on path tests/examples/ex_coordinate_chart.py line 17 TODO: Also set marker size based on value? line 18 TODO: Re-align alignment charts into line and update screenshot line 19 TODO: Maybe green heat map like Github? For one year? tests/examples/ex_datatable.py line 18 FIXME: AttributeError: \u2018DataTableDemo\u2019 object has no attribute \u2018ids\u2019 line 80 TODO: CLICKABLE POPUPS line 88 TODO: See: https://dash.plot.ly/datatable/interactivity line 94 TODO: Formatting (Typing): https://dash.plot.ly/datatable/typing tests/examples/ex_style_bootstrap.py line 92 TODO: Decide which styles from Bulma should be compared here Found code tags for FIXME (9), TODO (20), PLANNED (15), HACK (1), NOTE (1)","title":"Task Summary"},{"location":"CODE_TAG_SUMMARY/#task-summary","text":"Auto-Generated by dash_charts dash_charts/app_px.py line 65 PLANNED: template should be able to be None line 83 PLANNED: below items should be able to be None line 187 FIXME: replace tabs-select with actual keyname (?) dash_charts/coordinate_chart.py line 19 PLANNED: subplots for multiple years of calendar charts (Subplot title is year) line 335 PLANNED: make this configureable dash_charts/datatable.py line 5 TODO: See pattern mathing callbacks for adding buttons (to show modal) to datatables line 8 PLANNED: see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting line 10 PLANNED: These methods may be replaced in a future version of Dash line 87 PLANNED: Maybe move parameters to attr.ib classes? dash_charts/modules_upload.py line 76 PLANNED: Revisit. Should filename be a name or the full path? line 371 TODO: Add delete button for each table - need pattern matching callback: line 420 FIXME: Better handle NaN values\u2026 dash_charts/time_vis_chart.py line 5 NOTE: Consider automated (non-overlapping) text/event placement dash_charts/utils_app.py line 156 FIXME: Need to decide if there is a better approach. Reading this code is confusing\u2026 dash_charts/utils_app_with_navigation.py line 34 TODO: Try to see if I can resolve the interface differences or if I need make a subclass interface line 154 PLANNED: Make the tabs and chart compact as well when the compact argument is set to True line 361 TODO: Demo how pages could use parameters from pathname dash_charts/utils_data.py line 24 TODO: what does this set? line 84 PLANNED: Convert to FP and recursive calls? dash_charts/utils_json_cache.py line 14 FIXME: Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ line 32 TODO: Enable versioning of data and automatic deletion when the version changes dash_charts/utils_static_toc.py line 43 FIXME: Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) docs/README.md line 5 TODO: Currently not online ) line 48 FIXME: Keep updates up to date! \u2013> line 98 FIXME: the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases line 421 TODO: See https://github.com/KyleKing/calcipy/issues/38 \u2013> line 436 TODO: Show an example (screenshots, terminal recording, etc.) \u2013> dodo.py line 31 PLANNED: Move all of this into a function! (and/or task?) line 53 TODO: pypi package wasn\u2019t working. Used local version line 56 PLANNED: needs to be a bit more efficient\u2026 scripts/jsonl_viewer.py line 79 TODO: CLICKABLE POPUPS line 87 TODO: See: https://dash.plot.ly/datatable/interactivity line 93 TODO: Formatting (Typing): https://dash.plot.ly/datatable/typing tests/configuration.py line 15 PLANNED: Move all of this into a function! (and/or task?) {Duplicate of dodo.py} line 29 PLANNED: Output the test name and other information to the test.log file. Currently only used in no_log_errors line 30 PLANNED: move to dash_dev line 47 HACK: get_logs always return None with webdrivers other than Chrome line 48 FIXME: Handle path to the executable. Example with Firefox when the Gecko Drive is installed and on path tests/examples/ex_coordinate_chart.py line 17 TODO: Also set marker size based on value? line 18 TODO: Re-align alignment charts into line and update screenshot line 19 TODO: Maybe green heat map like Github? For one year? tests/examples/ex_datatable.py line 18 FIXME: AttributeError: \u2018DataTableDemo\u2019 object has no attribute \u2018ids\u2019 line 80 TODO: CLICKABLE POPUPS line 88 TODO: See: https://dash.plot.ly/datatable/interactivity line 94 TODO: Formatting (Typing): https://dash.plot.ly/datatable/typing tests/examples/ex_style_bootstrap.py line 92 TODO: Decide which styles from Bulma should be compared here Found code tags for FIXME (9), TODO (20), PLANNED (15), HACK (1), NOTE (1)","title":"Task Summary"},{"location":"DESIGN/","text":"Design and Architecture Notes \u2693\ufe0e TODO: Work in progress. Also take a look at: https://gist.github.com/jerieljan/4c82515ff5f2b2e4dd5122d354a82b7e PlantUML documentation","title":"Design and Architecture Notes"},{"location":"DESIGN/#design-and-architecture-notes","text":"TODO: Work in progress. Also take a look at: https://gist.github.com/jerieljan/4c82515ff5f2b2e4dd5122d354a82b7e PlantUML documentation","title":"Design and Architecture Notes"},{"location":"adr/","text":"ADR Documentation \u2693\ufe0e ADR : Architectural Design Decision ADRs \u2693\ufe0e ADR 000: Meta-ADR.md","title":"ADR Documentation"},{"location":"adr/#adr-documentation","text":"ADR : Architectural Design Decision","title":"ADR Documentation"},{"location":"adr/#adrs","text":"ADR 000: Meta-ADR.md","title":"ADRs"},{"location":"adr/NNN-Template/","text":"[short title of solved problem and solution] \u2693\ufe0e Status: [proposed | rejected | accepted | deprecated | \u2026 | superseded by ADR-0005 ] Deciders: [list everyone involved in the decision] Date: [YYYY-MM-DD when the decision was last updated] Technical Story: [description | ticket/issue URL] Context and Problem Statement \u2693\ufe0e [Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate the problem in form of a question.] Decision Drivers \u2693\ufe0e [driver 1, e.g., a force, facing concern, \u2026] [driver 2, e.g., a force, facing concern, \u2026] \u2026 Considered Options \u2693\ufe0e [option 1] [option 2] [option 3] \u2026 Decision Outcome \u2693\ufe0e Chosen option: \u201c[option 1]\u201d, because [justification. e.g., only option, which meets k.o. criterion decision driver | which resolves force force | \u2026 | comes out best (see below)]. Positive Consequences \u2693\ufe0e [e.g., improvement of quality attribute satisfaction, follow-up decisions required, \u2026] \u2026 Negative Consequences \u2693\ufe0e [e.g., compromising quality attribute, follow-up decisions required, \u2026] \u2026 Pros and Cons of the Options \u2693\ufe0e [option 1] \u2693\ufe0e [example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026 [option 2] \u2693\ufe0e [example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026 [option 3] \u2693\ufe0e [example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026 Links \u2693\ufe0e [Link type] [Link to ADR] \u2026","title":"[short title of solved problem and solution]"},{"location":"adr/NNN-Template/#short-title-of-solved-problem-and-solution","text":"Status: [proposed | rejected | accepted | deprecated | \u2026 | superseded by ADR-0005 ] Deciders: [list everyone involved in the decision] Date: [YYYY-MM-DD when the decision was last updated] Technical Story: [description | ticket/issue URL]","title":"[short title of solved problem and solution]"},{"location":"adr/NNN-Template/#context-and-problem-statement","text":"[Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate the problem in form of a question.]","title":"Context and Problem Statement"},{"location":"adr/NNN-Template/#decision-drivers","text":"[driver 1, e.g., a force, facing concern, \u2026] [driver 2, e.g., a force, facing concern, \u2026] \u2026","title":"Decision Drivers "},{"location":"adr/NNN-Template/#considered-options","text":"[option 1] [option 2] [option 3] \u2026","title":"Considered Options"},{"location":"adr/NNN-Template/#decision-outcome","text":"Chosen option: \u201c[option 1]\u201d, because [justification. e.g., only option, which meets k.o. criterion decision driver | which resolves force force | \u2026 | comes out best (see below)].","title":"Decision Outcome"},{"location":"adr/NNN-Template/#positive-consequences","text":"[e.g., improvement of quality attribute satisfaction, follow-up decisions required, \u2026] \u2026","title":"Positive Consequences "},{"location":"adr/NNN-Template/#negative-consequences","text":"[e.g., compromising quality attribute, follow-up decisions required, \u2026] \u2026","title":"Negative Consequences "},{"location":"adr/NNN-Template/#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options "},{"location":"adr/NNN-Template/#option-1","text":"[example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026","title":"[option 1]"},{"location":"adr/NNN-Template/#option-2","text":"[example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026","title":"[option 2]"},{"location":"adr/NNN-Template/#option-3","text":"[example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026","title":"[option 3]"},{"location":"adr/NNN-Template/#links","text":"[Link type] [Link to ADR] \u2026","title":"Links "},{"location":"docs/CHANGELOG/","text":"Unreleased \u2693\ufe0e Fix \u2693\ufe0e copy archival notice to doc README as well 0.1.1 (2022-08-04) \u2693\ufe0e Fix \u2693\ufe0e update README to indicate archival 0.1.0 (2022-02-18) \u2693\ufe0e 0.1.0a1 (2022-02-06) \u2693\ufe0e Feat \u2693\ufe0e WIP experimentation with tabulator experiment with plotting data from calcipy release date cache Fix \u2693\ufe0e more fixes for nox_coverage properly use pd.concat resolve warnings from dash migrate to dash-bootstrap-components >=1 drop unused matplotlib functionality temporarily patch the \u201c_id\u201d attr Refactor \u2693\ufe0e fix linting issues subset of Sourcery Refactoring use \u2018or\u2019 in place of some if/else add return type for generate_data apply sourcery refactoring batch add some type annotations experiment with Box/attr use self._il instead of self.ids New (Old) \u2693\ufe0e updates on project status WIP plantuml diagrams AppInterface and minor tweaks write toc to an HTML file split utils_dash into more specific files add matplotlib conversion convenience method refactor and add test for utils_cache Time Vis chart Change (Old) \u2693\ufe0e minor fixes to documentation update dash_dev dep implement improved SQL insert move into .diagrams & track png update image links for pdoc README update docs improve logging functionality drop bottleneck and update docstrings upgrade to latest dash_dev add additional tests, update docs, & fix lint downgrade Matplotlib 3.1 for pytest warning rename dash_helpers to utils_dash sync local changes for database & cache add upload image to README implement validation layout. Closes #2 add username control for upload module add video for testing utils_static cleanup TODO items & fix some linting errors rename utils cache to json_cache initialize upload module example tests are failing for rolling chart refactor and cleanup of time vis and add img initialize new highlighted time section add events to time vis compress task list and add app_px image rename gantt.py to gantt_chart.py expand testing for dash helpers move source data to CSV and add to README cleanup and refactor create legendgroups to toggle projects sort and show Gantt tasks using Scatter @WIP initialize Gantt with plotly shapes @WIP cleanup px app update requirements and changelog set default dropdown values in child class add additional tests merge untested code from kitsu project merge rolling and fitted charts (inc: 0.0.5) Fix (Old) \u2693\ufe0e fix #3 for broken image paths to main branch minor bugs in datatable & drop snoop experiment with isort corrections isort and dash testing requirements make cache_dir configurable test errors and standardize log checks chart load errors. Resolves #1 gantt chart image name\u2026 tests and add ex_gantt test Gantt sort and date range 0.0.4 (2020-05-03) \u2693\ufe0e New (Old) \u2693\ufe0e ability to create Plotly HTML from markdown add utils_static function tag_markdown improve utils_static with dominate refactor fitted and rolling figures initialize module for writing static HTML add slider to the rolling chart implement sqlite realtime demo @wip DataCache and general updates migrate to dash_dev remove files moved to dash_dev add design principles to README add linting to DoIt doit methods for placing content into README add example for marginal chart BaseDataTable class and example initialize \u201cmodules\u201d move AppMultiPage and AppWithTabs to new file move examples to test/ and init dash.testing fitted line chart initialize the coordinate chart and example Cerberus property validation and tests default navbar for multipage applications added multi-page application base class @dataclass for pareto to reduce method args update plotly express example add Bootstrap example use external stylesheets for Bulma example first refactored example with Pareto chart Change (Old) \u2693\ufe0e update documentation split AppWithTabs into inline and FullScreen update images and dependencies add ex_utils_static to README update dash_dev for docs fixes use generate_data instead of _generate_data slightly improve annotations use RollingChart for SQL demo and capture gif set debug by CLI argument refactor to use dict instead of obj & use data_raw move some dash tutorials into tasks/package move px app into package reorganize some functions add filter inputs to datatable example move module to dash_charts improve datatable styling and module create initial module for datatable style sort and select in table & update docs refactor datatable for mutables and update ex add method to write sample code into README rename _create_traces back to create_traces() rename create_traces() to _create_traces() rename create_charts() to create_elements() expand tests and coverage minor refactor for pareto and AppBase add example cool hexagonal charts to WIP/ add planned sample code (commented out) @wip removed alignment chart badges! remove make_colorbar and add coord_chart img refactor make_colorbar and remove log_fire use itertools and * syntax in coord chart refactor coordinate chart standardize as chart_ , data_ , id_* group bar placeholder fix formatting of raw changelog refactor to split run/create tasks in app always call Dash stylesheets from init_app remove dataclass for pareto & move utils_dodo update color scheme for Pareto refactor AppWithTabs and update image remove TODOs from README and update links relax version requirements in toml rename dash tutorial folder update README and pareto chart initialize tests and move to plotly.express update dash tutorial examples additional snake_case refactor add notes update rolling chart simplify tab example update documentation reduce complexity for map_args refactor utilities and initilze AppWithTabs update TODO annotations refactor the app.callback utilities rename examples files to be different from package files update data members based on Pareto changes experimented and semi-broke 0.0.3 tag reference improve documentation Fix (Old) \u2693\ufe0e remove mdx_gfm (doesn\u2019t work with markdown 3) fix error in path for task commit_docs add test for ex_sqlite sqlite demo spawning duplicate processes references to app_px finish migration to dash_dev missing example image & README indentation set css styles to React format (not dashed) improve dropdown_group and add examples to px rendering tabs. Move create() out of init() update ex_px for app changes & add TODOs rolling & alignment charts, still work to do pytest class warning Pareto chart dataclass pass kwargs to init and update README moving subdirectories to gh-pages branch tabs example 0.0.3 (2020-02-12) \u2693\ufe0e New (Old) \u2693\ufe0e show examples in documentation base application class add Tabbed Application GUI from PFE add annotations to rolling chart Add marginal charts with alignment demo create YearGrid and MonthGrid subtitles for each plot in coordinate chart log colors for coordinate chart coordinate chart move DoIt base utilities to separate file responsive Bulma example Dash app initApp selects assets from package add Bulma stylesheet to assets example dark theme w/ toggle Change (Old) \u2693\ufe0e update imports for newly split helpers file split helpers into charts and app utility files select port at CLI and more doc updates update requirements start converting to snake_case and rethinking app structure @WIP add optional count to Pareto bars proper month grid for the current year/day migrate to Plotly v4 minor tweaks to alignment chart add customLayoutParams arg add plaid iframe style @wip add ddOpts to package and use MinGraph cleaned up README and TODO list @cosmetic Fix (Old) \u2693\ufe0e move base DoDo file into package cleanup lockfile and requirements remove github dependencies 0.0.2 (2019-06-17) \u2693\ufe0e 0.0.1 (2019-06-13) \u2693\ufe0e Fix (Old) \u2693\ufe0e assets paths","title":"CHANGELOG"},{"location":"docs/CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"docs/CHANGELOG/#fix","text":"copy archival notice to doc README as well","title":"Fix"},{"location":"docs/CHANGELOG/#011-2022-08-04","text":"","title":"0.1.1 (2022-08-04)"},{"location":"docs/CHANGELOG/#fix_1","text":"update README to indicate archival","title":"Fix"},{"location":"docs/CHANGELOG/#010-2022-02-18","text":"","title":"0.1.0 (2022-02-18)"},{"location":"docs/CHANGELOG/#010a1-2022-02-06","text":"","title":"0.1.0a1 (2022-02-06)"},{"location":"docs/CHANGELOG/#feat","text":"WIP experimentation with tabulator experiment with plotting data from calcipy release date cache","title":"Feat"},{"location":"docs/CHANGELOG/#fix_2","text":"more fixes for nox_coverage properly use pd.concat resolve warnings from dash migrate to dash-bootstrap-components >=1 drop unused matplotlib functionality temporarily patch the \u201c_id\u201d attr","title":"Fix"},{"location":"docs/CHANGELOG/#refactor","text":"fix linting issues subset of Sourcery Refactoring use \u2018or\u2019 in place of some if/else add return type for generate_data apply sourcery refactoring batch add some type annotations experiment with Box/attr use self._il instead of self.ids","title":"Refactor"},{"location":"docs/CHANGELOG/#new-old","text":"updates on project status WIP plantuml diagrams AppInterface and minor tweaks write toc to an HTML file split utils_dash into more specific files add matplotlib conversion convenience method refactor and add test for utils_cache Time Vis chart","title":"New (Old)"},{"location":"docs/CHANGELOG/#change-old","text":"minor fixes to documentation update dash_dev dep implement improved SQL insert move into .diagrams & track png update image links for pdoc README update docs improve logging functionality drop bottleneck and update docstrings upgrade to latest dash_dev add additional tests, update docs, & fix lint downgrade Matplotlib 3.1 for pytest warning rename dash_helpers to utils_dash sync local changes for database & cache add upload image to README implement validation layout. Closes #2 add username control for upload module add video for testing utils_static cleanup TODO items & fix some linting errors rename utils cache to json_cache initialize upload module example tests are failing for rolling chart refactor and cleanup of time vis and add img initialize new highlighted time section add events to time vis compress task list and add app_px image rename gantt.py to gantt_chart.py expand testing for dash helpers move source data to CSV and add to README cleanup and refactor create legendgroups to toggle projects sort and show Gantt tasks using Scatter @WIP initialize Gantt with plotly shapes @WIP cleanup px app update requirements and changelog set default dropdown values in child class add additional tests merge untested code from kitsu project merge rolling and fitted charts (inc: 0.0.5)","title":"Change (Old)"},{"location":"docs/CHANGELOG/#fix-old","text":"fix #3 for broken image paths to main branch minor bugs in datatable & drop snoop experiment with isort corrections isort and dash testing requirements make cache_dir configurable test errors and standardize log checks chart load errors. Resolves #1 gantt chart image name\u2026 tests and add ex_gantt test Gantt sort and date range","title":"Fix (Old)"},{"location":"docs/CHANGELOG/#004-2020-05-03","text":"","title":"0.0.4 (2020-05-03)"},{"location":"docs/CHANGELOG/#new-old_1","text":"ability to create Plotly HTML from markdown add utils_static function tag_markdown improve utils_static with dominate refactor fitted and rolling figures initialize module for writing static HTML add slider to the rolling chart implement sqlite realtime demo @wip DataCache and general updates migrate to dash_dev remove files moved to dash_dev add design principles to README add linting to DoIt doit methods for placing content into README add example for marginal chart BaseDataTable class and example initialize \u201cmodules\u201d move AppMultiPage and AppWithTabs to new file move examples to test/ and init dash.testing fitted line chart initialize the coordinate chart and example Cerberus property validation and tests default navbar for multipage applications added multi-page application base class @dataclass for pareto to reduce method args update plotly express example add Bootstrap example use external stylesheets for Bulma example first refactored example with Pareto chart","title":"New (Old)"},{"location":"docs/CHANGELOG/#change-old_1","text":"update documentation split AppWithTabs into inline and FullScreen update images and dependencies add ex_utils_static to README update dash_dev for docs fixes use generate_data instead of _generate_data slightly improve annotations use RollingChart for SQL demo and capture gif set debug by CLI argument refactor to use dict instead of obj & use data_raw move some dash tutorials into tasks/package move px app into package reorganize some functions add filter inputs to datatable example move module to dash_charts improve datatable styling and module create initial module for datatable style sort and select in table & update docs refactor datatable for mutables and update ex add method to write sample code into README rename _create_traces back to create_traces() rename create_traces() to _create_traces() rename create_charts() to create_elements() expand tests and coverage minor refactor for pareto and AppBase add example cool hexagonal charts to WIP/ add planned sample code (commented out) @wip removed alignment chart badges! remove make_colorbar and add coord_chart img refactor make_colorbar and remove log_fire use itertools and * syntax in coord chart refactor coordinate chart standardize as chart_ , data_ , id_* group bar placeholder fix formatting of raw changelog refactor to split run/create tasks in app always call Dash stylesheets from init_app remove dataclass for pareto & move utils_dodo update color scheme for Pareto refactor AppWithTabs and update image remove TODOs from README and update links relax version requirements in toml rename dash tutorial folder update README and pareto chart initialize tests and move to plotly.express update dash tutorial examples additional snake_case refactor add notes update rolling chart simplify tab example update documentation reduce complexity for map_args refactor utilities and initilze AppWithTabs update TODO annotations refactor the app.callback utilities rename examples files to be different from package files update data members based on Pareto changes experimented and semi-broke 0.0.3 tag reference improve documentation","title":"Change (Old)"},{"location":"docs/CHANGELOG/#fix-old_1","text":"remove mdx_gfm (doesn\u2019t work with markdown 3) fix error in path for task commit_docs add test for ex_sqlite sqlite demo spawning duplicate processes references to app_px finish migration to dash_dev missing example image & README indentation set css styles to React format (not dashed) improve dropdown_group and add examples to px rendering tabs. Move create() out of init() update ex_px for app changes & add TODOs rolling & alignment charts, still work to do pytest class warning Pareto chart dataclass pass kwargs to init and update README moving subdirectories to gh-pages branch tabs example","title":"Fix (Old)"},{"location":"docs/CHANGELOG/#003-2020-02-12","text":"","title":"0.0.3 (2020-02-12)"},{"location":"docs/CHANGELOG/#new-old_2","text":"show examples in documentation base application class add Tabbed Application GUI from PFE add annotations to rolling chart Add marginal charts with alignment demo create YearGrid and MonthGrid subtitles for each plot in coordinate chart log colors for coordinate chart coordinate chart move DoIt base utilities to separate file responsive Bulma example Dash app initApp selects assets from package add Bulma stylesheet to assets example dark theme w/ toggle","title":"New (Old)"},{"location":"docs/CHANGELOG/#change-old_2","text":"update imports for newly split helpers file split helpers into charts and app utility files select port at CLI and more doc updates update requirements start converting to snake_case and rethinking app structure @WIP add optional count to Pareto bars proper month grid for the current year/day migrate to Plotly v4 minor tweaks to alignment chart add customLayoutParams arg add plaid iframe style @wip add ddOpts to package and use MinGraph cleaned up README and TODO list @cosmetic","title":"Change (Old)"},{"location":"docs/CHANGELOG/#fix-old_2","text":"move base DoDo file into package cleanup lockfile and requirements remove github dependencies","title":"Fix (Old)"},{"location":"docs/CHANGELOG/#002-2019-06-17","text":"","title":"0.0.2 (2019-06-17)"},{"location":"docs/CHANGELOG/#001-2019-06-13","text":"","title":"0.0.1 (2019-06-13)"},{"location":"docs/CHANGELOG/#fix-old_3","text":"assets paths","title":"Fix (Old)"},{"location":"docs/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct \u2693\ufe0e Our Pledge \u2693\ufe0e We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards \u2693\ufe0e Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others\u2019 private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities \u2693\ufe0e Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope \u2693\ufe0e This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement \u2693\ufe0e Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at dev.act.kyle@gmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines \u2693\ufe0e Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction \u2693\ufe0e Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning \u2693\ufe0e Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban \u2693\ufe0e Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban \u2693\ufe0e Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution \u2693\ufe0e This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla\u2019s code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Contributor Covenant Code of Conduct"},{"location":"docs/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"docs/CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"docs/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others\u2019 private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/CODE_OF_CONDUCT/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"docs/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"docs/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at dev.act.kyle@gmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"docs/CODE_OF_CONDUCT/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"docs/CODE_OF_CONDUCT/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"docs/CODE_OF_CONDUCT/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"docs/CODE_OF_CONDUCT/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"docs/CODE_OF_CONDUCT/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"docs/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla\u2019s code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Attribution"},{"location":"docs/CODE_TAG_SUMMARY/","text":"Task Summary \u2693\ufe0e Auto-Generated by dash_charts Type Comment Last Edit Source File TODO Migrate this sample code to ex_app_px.py 2020-03-22 .dash_tutorials/08_px-charts.py:3 PLANNED template should be able to be None 2020-05-03 dash_charts/app_px.py:65 PLANNED below items should be able to be None 2020-05-03 dash_charts/app_px.py:85 FIXME replace tabs-select with actual keyname (?) 2020-05-03 dash_charts/app_px.py:202 FIXME Implement user-customizable styles 2020-07-19 dash_charts/assets/09_user-styles.css:18 PLANNED subplots for multiple years of calendar charts (Subplot title is year) 2020-07-19 dash_charts/coordinate_chart.py:19 PLANNED make this configureable 2020-03-01 dash_charts/coordinate_chart.py:337 TODO See pattern mathing callbacks for adding buttons (to show modal) to datatables 2020-05-03 dash_charts/datatable.py:5 PLANNED see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting 2020-05-03 dash_charts/datatable.py:8 PLANNED These methods may be replaced in a future version of Dash 2020-03-22 dash_charts/datatable.py:10 PLANNED Maybe move parameters to attr.ib classes? 2021-03-11 dash_charts/datatable.py:89 PLANNED Revisit. Should filename be a name or the full path? 2020-05-03 dash_charts/modules_upload.py:74 TODO Add delete button for each table - need pattern matching callback: 2020-07-19 dash_charts/modules_upload.py:375 FIXME Better handle NaN values\u2026 2020-07-19 dash_charts/modules_upload.py:424 FIXME Need to decide if there is a better approach. Reading this code is confusing\u2026 2021-04-25 dash_charts/utils_app.py:156 TODO Try to see if I can resolve the interface differences or if I need make a subclass interface 2020-10-16 dash_charts/utils_app_with_navigation.py:33 PLANNED Make the tabs and chart compact as well when the compact argument is set to True 2020-05-03 dash_charts/utils_app_with_navigation.py:155 TODO Demo how pages could use parameters from pathname 2020-03-14 dash_charts/utils_app_with_navigation.py:372 TODO what does this set? 2020-10-15 dash_charts/utils_data.py:24 PLANNED Convert to FP and recursive calls? 2020-10-15 dash_charts/utils_data.py:84 FIXME Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ 2020-11-12 dash_charts/utils_json_cache.py:14 TODO Enable versioning of data and automatic deletion when the version changes 2020-10-29 dash_charts/utils_json_cache.py:32 FIXME Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) 2020-10-15 dash_charts/utils_static_toc.py:43 PLANNED template should be able to be None 2021-04-25 docs/CODE_TAG_SUMMARY.md:6 PLANNED below items should be able to be None 2021-04-25 docs/CODE_TAG_SUMMARY.md:7 FIXME replace tabs-select with actual keyname (?) 2021-04-25 docs/CODE_TAG_SUMMARY.md:8 PLANNED subplots for multiple years of calendar charts (Subplot title is year) 2021-04-25 docs/CODE_TAG_SUMMARY.md:11 PLANNED make this configureable 2021-04-25 docs/CODE_TAG_SUMMARY.md:12 TODO See pattern mathing callbacks for adding buttons (to show modal) to datatables 2021-04-25 docs/CODE_TAG_SUMMARY.md:15 PLANNED see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting 2021-04-25 docs/CODE_TAG_SUMMARY.md:16 PLANNED These methods may be replaced in a future version of Dash 2021-04-25 docs/CODE_TAG_SUMMARY.md:17 PLANNED Maybe move parameters to attr.ib classes? 2021-04-25 docs/CODE_TAG_SUMMARY.md:18 PLANNED Revisit. Should filename be a name or the full path? 2021-04-25 docs/CODE_TAG_SUMMARY.md:21 TODO Add delete button for each table - need pattern matching callback: 2021-04-25 docs/CODE_TAG_SUMMARY.md:22 FIXME Better handle NaN values\u2026 2021-04-25 docs/CODE_TAG_SUMMARY.md:23 FIXME Need to decide if there is a better approach. Reading this code is confusing\u2026 2021-04-26 docs/CODE_TAG_SUMMARY.md:29 TODO Try to see if I can resolve the interface differences or if I need make a subclass interface 2021-04-25 docs/CODE_TAG_SUMMARY.md:32 PLANNED Make the tabs and chart compact as well when the compact argument is set to True 2021-04-25 docs/CODE_TAG_SUMMARY.md:33 TODO Demo how pages could use parameters from pathname 2021-04-25 docs/CODE_TAG_SUMMARY.md:34 TODO what does this set? 2021-04-25 docs/CODE_TAG_SUMMARY.md:37 PLANNED Convert to FP and recursive calls? 2021-04-25 docs/CODE_TAG_SUMMARY.md:38 FIXME Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ 2021-04-25 docs/CODE_TAG_SUMMARY.md:41 TODO Enable versioning of data and automatic deletion when the version changes 2021-04-25 docs/CODE_TAG_SUMMARY.md:42 FIXME Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) 2021-04-25 docs/CODE_TAG_SUMMARY.md:45 TODO Currently not online ) 2021-04-25 docs/CODE_TAG_SUMMARY.md:48 FIXME Keep updates up to date! \u2013> 2021-04-25 docs/CODE_TAG_SUMMARY.md:49 FIXME the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases 2021-04-26 docs/CODE_TAG_SUMMARY.md:50 TODO See https://github.com/KyleKing/calcipy/issues/38 \u2013> 2021-04-26 docs/CODE_TAG_SUMMARY.md:51 TODO Show an example (screenshots, terminal recording, etc.) \u2013> 2021-04-26 docs/CODE_TAG_SUMMARY.md:52 PLANNED Move all of this into a function! (and/or task?) 2021-04-25 docs/CODE_TAG_SUMMARY.md:55 TODO pypi package wasn\u2019t working. Used local version 2021-04-25 docs/CODE_TAG_SUMMARY.md:56 PLANNED needs to be a bit more efficient\u2026 2021-04-25 docs/CODE_TAG_SUMMARY.md:57 TODO CLICKABLE POPUPS 2021-04-26 docs/CODE_TAG_SUMMARY.md:60 TODO See: https://dash.plot.ly/datatable/interactivity 2021-04-26 docs/CODE_TAG_SUMMARY.md:61 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2021-04-26 docs/CODE_TAG_SUMMARY.md:62 PLANNED Move all of this into a function! (and/or task?) 2021-04-25 docs/CODE_TAG_SUMMARY.md:65 PLANNED Output the test name and other information to the test.log file. Currently only used in no_log_errors 2021-04-25 docs/CODE_TAG_SUMMARY.md:66 PLANNED move to dash_dev 2021-04-25 docs/CODE_TAG_SUMMARY.md:67 HACK get_logs always return None with webdrivers other than Chrome 2021-04-25 docs/CODE_TAG_SUMMARY.md:68 FIXME Handle path to the executable. Example with Firefox when the Gecko Drive is installed and on path 2021-04-25 docs/CODE_TAG_SUMMARY.md:69 TODO Also set marker size based on value? 2021-04-25 docs/CODE_TAG_SUMMARY.md:72 TODO Re-align alignment charts into line and update screenshot 2021-04-25 docs/CODE_TAG_SUMMARY.md:73 TODO Maybe green heat map like Github? For one year? 2021-04-25 docs/CODE_TAG_SUMMARY.md:74 FIXME AttributeError: \u2018DataTableDemo\u2019 object has no attribute \u2018ids\u2019 2021-04-26 docs/CODE_TAG_SUMMARY.md:77 TODO CLICKABLE POPUPS 2021-04-26 docs/CODE_TAG_SUMMARY.md:78 TODO See: https://dash.plot.ly/datatable/interactivity 2021-04-26 docs/CODE_TAG_SUMMARY.md:79 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2021-04-26 docs/CODE_TAG_SUMMARY.md:80 TODO Decide which styles from Bulma should be compared here 2021-04-25 docs/CODE_TAG_SUMMARY.md:83 TODO Currently not online ) 2021-04-25 docs/README.md:5 FIXME Keep updates up to date! \u2013> 2020-11-09 docs/README.md:48 FIXME the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases 2021-04-25 docs/README.md:98 FIXME Document use of the calcipy_template instead of manual configuration \u2013> 2021-06-02 docs/README.md:172 TODO See https://github.com/KyleKing/calcipy/issues/38 \u2013> 2021-04-25 docs/README.md:423 TODO Show an example (screenshots, terminal recording, etc.) \u2013> 2021-04-25 docs/README.md:438 TODO pypi package wasn\u2019t working. Used local version 2020-10-29 dodo.py:40 PLANNED needs to be a bit more efficient\u2026 2020-10-29 dodo.py:43 FIXME Required only for nox_coverage and optional for subset of use cases 2022-02-06 pyproject.toml:89 FIXME In-progress testing of a better dash table 2021-06-04 pyproject.toml:94 FIXME testing extras are required for nox-coverage 2022-02-06 pyproject.toml:111 TODO Replace with imports to test 2021-12-09 scripts/check_imports.py:14 TODO CLICKABLE POPUPS 2021-03-11 scripts/jsonl_viewer.py:78 TODO See: https://dash.plot.ly/datatable/interactivity 2021-03-11 scripts/jsonl_viewer.py:86 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2021-03-11 scripts/jsonl_viewer.py:92 PLANNED Output the test name and other information to the test.log file. Currently only used in no_log_errors 2020-08-16 tests/configuration.py:28 PLANNED move to a lazy import within dash_charts? 2021-06-02 tests/configuration.py:29 HACK get_logs always return None with webdrivers other than Chrome 2021-03-11 tests/configuration.py:46 FIXME Handle path to the executable. Example with Firefox when the Gecko Drive is installed and on path 2021-03-11 tests/configuration.py:47 TODO Also set marker size based on value? 2020-03-10 tests/examples/ex_coordinate_chart.py:17 TODO Re-align alignment charts into line and update screenshot 2020-04-27 tests/examples/ex_coordinate_chart.py:18 TODO Maybe green heat map like Github? For one year? 2020-04-27 tests/examples/ex_coordinate_chart.py:19 FIXME AttributeError: \u2018DataTableDemo\u2019 object has no attribute \u2018ids\u2019 2021-04-25 tests/examples/ex_datatable.py:17 TODO CLICKABLE POPUPS 2020-03-22 tests/examples/ex_datatable.py:79 TODO See: https://dash.plot.ly/datatable/interactivity 2020-03-22 tests/examples/ex_datatable.py:87 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2020-03-22 tests/examples/ex_datatable.py:93 TODO Decide which styles from Bulma should be compared here 2021-12-09 tests/examples/ex_style_bootstrap.py:97 FIXME Fix the \u201cids\u201d error 2021-04-26 tests/test_examples_ex_datatable.py:14 Found code tags for FIXME (24), TODO (42), PLANNED (28), HACK (2)","title":"Task Summary"},{"location":"docs/CODE_TAG_SUMMARY/#task-summary","text":"Auto-Generated by dash_charts Type Comment Last Edit Source File TODO Migrate this sample code to ex_app_px.py 2020-03-22 .dash_tutorials/08_px-charts.py:3 PLANNED template should be able to be None 2020-05-03 dash_charts/app_px.py:65 PLANNED below items should be able to be None 2020-05-03 dash_charts/app_px.py:85 FIXME replace tabs-select with actual keyname (?) 2020-05-03 dash_charts/app_px.py:202 FIXME Implement user-customizable styles 2020-07-19 dash_charts/assets/09_user-styles.css:18 PLANNED subplots for multiple years of calendar charts (Subplot title is year) 2020-07-19 dash_charts/coordinate_chart.py:19 PLANNED make this configureable 2020-03-01 dash_charts/coordinate_chart.py:337 TODO See pattern mathing callbacks for adding buttons (to show modal) to datatables 2020-05-03 dash_charts/datatable.py:5 PLANNED see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting 2020-05-03 dash_charts/datatable.py:8 PLANNED These methods may be replaced in a future version of Dash 2020-03-22 dash_charts/datatable.py:10 PLANNED Maybe move parameters to attr.ib classes? 2021-03-11 dash_charts/datatable.py:89 PLANNED Revisit. Should filename be a name or the full path? 2020-05-03 dash_charts/modules_upload.py:74 TODO Add delete button for each table - need pattern matching callback: 2020-07-19 dash_charts/modules_upload.py:375 FIXME Better handle NaN values\u2026 2020-07-19 dash_charts/modules_upload.py:424 FIXME Need to decide if there is a better approach. Reading this code is confusing\u2026 2021-04-25 dash_charts/utils_app.py:156 TODO Try to see if I can resolve the interface differences or if I need make a subclass interface 2020-10-16 dash_charts/utils_app_with_navigation.py:33 PLANNED Make the tabs and chart compact as well when the compact argument is set to True 2020-05-03 dash_charts/utils_app_with_navigation.py:155 TODO Demo how pages could use parameters from pathname 2020-03-14 dash_charts/utils_app_with_navigation.py:372 TODO what does this set? 2020-10-15 dash_charts/utils_data.py:24 PLANNED Convert to FP and recursive calls? 2020-10-15 dash_charts/utils_data.py:84 FIXME Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ 2020-11-12 dash_charts/utils_json_cache.py:14 TODO Enable versioning of data and automatic deletion when the version changes 2020-10-29 dash_charts/utils_json_cache.py:32 FIXME Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) 2020-10-15 dash_charts/utils_static_toc.py:43 PLANNED template should be able to be None 2021-04-25 docs/CODE_TAG_SUMMARY.md:6 PLANNED below items should be able to be None 2021-04-25 docs/CODE_TAG_SUMMARY.md:7 FIXME replace tabs-select with actual keyname (?) 2021-04-25 docs/CODE_TAG_SUMMARY.md:8 PLANNED subplots for multiple years of calendar charts (Subplot title is year) 2021-04-25 docs/CODE_TAG_SUMMARY.md:11 PLANNED make this configureable 2021-04-25 docs/CODE_TAG_SUMMARY.md:12 TODO See pattern mathing callbacks for adding buttons (to show modal) to datatables 2021-04-25 docs/CODE_TAG_SUMMARY.md:15 PLANNED see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting 2021-04-25 docs/CODE_TAG_SUMMARY.md:16 PLANNED These methods may be replaced in a future version of Dash 2021-04-25 docs/CODE_TAG_SUMMARY.md:17 PLANNED Maybe move parameters to attr.ib classes? 2021-04-25 docs/CODE_TAG_SUMMARY.md:18 PLANNED Revisit. Should filename be a name or the full path? 2021-04-25 docs/CODE_TAG_SUMMARY.md:21 TODO Add delete button for each table - need pattern matching callback: 2021-04-25 docs/CODE_TAG_SUMMARY.md:22 FIXME Better handle NaN values\u2026 2021-04-25 docs/CODE_TAG_SUMMARY.md:23 FIXME Need to decide if there is a better approach. Reading this code is confusing\u2026 2021-04-26 docs/CODE_TAG_SUMMARY.md:29 TODO Try to see if I can resolve the interface differences or if I need make a subclass interface 2021-04-25 docs/CODE_TAG_SUMMARY.md:32 PLANNED Make the tabs and chart compact as well when the compact argument is set to True 2021-04-25 docs/CODE_TAG_SUMMARY.md:33 TODO Demo how pages could use parameters from pathname 2021-04-25 docs/CODE_TAG_SUMMARY.md:34 TODO what does this set? 2021-04-25 docs/CODE_TAG_SUMMARY.md:37 PLANNED Convert to FP and recursive calls? 2021-04-25 docs/CODE_TAG_SUMMARY.md:38 FIXME Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ 2021-04-25 docs/CODE_TAG_SUMMARY.md:41 TODO Enable versioning of data and automatic deletion when the version changes 2021-04-25 docs/CODE_TAG_SUMMARY.md:42 FIXME Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) 2021-04-25 docs/CODE_TAG_SUMMARY.md:45 TODO Currently not online ) 2021-04-25 docs/CODE_TAG_SUMMARY.md:48 FIXME Keep updates up to date! \u2013> 2021-04-25 docs/CODE_TAG_SUMMARY.md:49 FIXME the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases 2021-04-26 docs/CODE_TAG_SUMMARY.md:50 TODO See https://github.com/KyleKing/calcipy/issues/38 \u2013> 2021-04-26 docs/CODE_TAG_SUMMARY.md:51 TODO Show an example (screenshots, terminal recording, etc.) \u2013> 2021-04-26 docs/CODE_TAG_SUMMARY.md:52 PLANNED Move all of this into a function! (and/or task?) 2021-04-25 docs/CODE_TAG_SUMMARY.md:55 TODO pypi package wasn\u2019t working. Used local version 2021-04-25 docs/CODE_TAG_SUMMARY.md:56 PLANNED needs to be a bit more efficient\u2026 2021-04-25 docs/CODE_TAG_SUMMARY.md:57 TODO CLICKABLE POPUPS 2021-04-26 docs/CODE_TAG_SUMMARY.md:60 TODO See: https://dash.plot.ly/datatable/interactivity 2021-04-26 docs/CODE_TAG_SUMMARY.md:61 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2021-04-26 docs/CODE_TAG_SUMMARY.md:62 PLANNED Move all of this into a function! (and/or task?) 2021-04-25 docs/CODE_TAG_SUMMARY.md:65 PLANNED Output the test name and other information to the test.log file. Currently only used in no_log_errors 2021-04-25 docs/CODE_TAG_SUMMARY.md:66 PLANNED move to dash_dev 2021-04-25 docs/CODE_TAG_SUMMARY.md:67 HACK get_logs always return None with webdrivers other than Chrome 2021-04-25 docs/CODE_TAG_SUMMARY.md:68 FIXME Handle path to the executable. Example with Firefox when the Gecko Drive is installed and on path 2021-04-25 docs/CODE_TAG_SUMMARY.md:69 TODO Also set marker size based on value? 2021-04-25 docs/CODE_TAG_SUMMARY.md:72 TODO Re-align alignment charts into line and update screenshot 2021-04-25 docs/CODE_TAG_SUMMARY.md:73 TODO Maybe green heat map like Github? For one year? 2021-04-25 docs/CODE_TAG_SUMMARY.md:74 FIXME AttributeError: \u2018DataTableDemo\u2019 object has no attribute \u2018ids\u2019 2021-04-26 docs/CODE_TAG_SUMMARY.md:77 TODO CLICKABLE POPUPS 2021-04-26 docs/CODE_TAG_SUMMARY.md:78 TODO See: https://dash.plot.ly/datatable/interactivity 2021-04-26 docs/CODE_TAG_SUMMARY.md:79 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2021-04-26 docs/CODE_TAG_SUMMARY.md:80 TODO Decide which styles from Bulma should be compared here 2021-04-25 docs/CODE_TAG_SUMMARY.md:83 TODO Currently not online ) 2021-04-25 docs/README.md:5 FIXME Keep updates up to date! \u2013> 2020-11-09 docs/README.md:48 FIXME the change to use Box/_ID needs to be implemented in the examples. This is causing failures in the test cases 2021-04-25 docs/README.md:98 FIXME Document use of the calcipy_template instead of manual configuration \u2013> 2021-06-02 docs/README.md:172 TODO See https://github.com/KyleKing/calcipy/issues/38 \u2013> 2021-04-25 docs/README.md:423 TODO Show an example (screenshots, terminal recording, etc.) \u2013> 2021-04-25 docs/README.md:438 TODO pypi package wasn\u2019t working. Used local version 2020-10-29 dodo.py:40 PLANNED needs to be a bit more efficient\u2026 2020-10-29 dodo.py:43 FIXME Required only for nox_coverage and optional for subset of use cases 2022-02-06 pyproject.toml:89 FIXME In-progress testing of a better dash table 2021-06-04 pyproject.toml:94 FIXME testing extras are required for nox-coverage 2022-02-06 pyproject.toml:111 TODO Replace with imports to test 2021-12-09 scripts/check_imports.py:14 TODO CLICKABLE POPUPS 2021-03-11 scripts/jsonl_viewer.py:78 TODO See: https://dash.plot.ly/datatable/interactivity 2021-03-11 scripts/jsonl_viewer.py:86 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2021-03-11 scripts/jsonl_viewer.py:92 PLANNED Output the test name and other information to the test.log file. Currently only used in no_log_errors 2020-08-16 tests/configuration.py:28 PLANNED move to a lazy import within dash_charts? 2021-06-02 tests/configuration.py:29 HACK get_logs always return None with webdrivers other than Chrome 2021-03-11 tests/configuration.py:46 FIXME Handle path to the executable. Example with Firefox when the Gecko Drive is installed and on path 2021-03-11 tests/configuration.py:47 TODO Also set marker size based on value? 2020-03-10 tests/examples/ex_coordinate_chart.py:17 TODO Re-align alignment charts into line and update screenshot 2020-04-27 tests/examples/ex_coordinate_chart.py:18 TODO Maybe green heat map like Github? For one year? 2020-04-27 tests/examples/ex_coordinate_chart.py:19 FIXME AttributeError: \u2018DataTableDemo\u2019 object has no attribute \u2018ids\u2019 2021-04-25 tests/examples/ex_datatable.py:17 TODO CLICKABLE POPUPS 2020-03-22 tests/examples/ex_datatable.py:79 TODO See: https://dash.plot.ly/datatable/interactivity 2020-03-22 tests/examples/ex_datatable.py:87 TODO Formatting (Typing): https://dash.plot.ly/datatable/typing 2020-03-22 tests/examples/ex_datatable.py:93 TODO Decide which styles from Bulma should be compared here 2021-12-09 tests/examples/ex_style_bootstrap.py:97 FIXME Fix the \u201cids\u201d error 2021-04-26 tests/test_examples_ex_datatable.py:14 Found code tags for FIXME (24), TODO (42), PLANNED (28), HACK (2)","title":"Task Summary"},{"location":"docs/CONTRIBUTING/","text":"Contributing \u2693\ufe0e Thanks for taking a look! This is primarily a personal project, but Pull Requests and Issues (questions, feature requests, etc.) are welcome. If you would like to submit a Pull Request, please open an issue first to discuss what you would like to change Pull Requests (PR) \u2693\ufe0e Code Development \u2693\ufe0e See ./DEVELOPER_GUIDE.md PR Process \u2693\ufe0e Fork the Project and Clone Create a new branch ( git checkout -b feat/feature-name ) Edit code; update documentation and tests; commit and push Before submitting the review and pushing, make sure to run poetry run doit Open a new Pull Request See the style guide for commit message format ( ./STYLE_GUIDE ) If you run into any issues, please check to see if there is an open issues or open a new one Other PR Tips \u2693\ufe0e Link the issue with Fixes #N in the Pull Request body Please add a short summary of why the change was made, what changed , and any relevant information or screenshots # SHA is the SHA of the commit you want to fix git commit --fixup = SHA # Once all the changes are approved, you can squash your commits: git rebase --interactive --autosquash main # Force Push git push --force","title":"Contributing"},{"location":"docs/CONTRIBUTING/#contributing","text":"Thanks for taking a look! This is primarily a personal project, but Pull Requests and Issues (questions, feature requests, etc.) are welcome. If you would like to submit a Pull Request, please open an issue first to discuss what you would like to change","title":"Contributing"},{"location":"docs/CONTRIBUTING/#pull-requests-pr","text":"","title":"Pull Requests (PR)"},{"location":"docs/CONTRIBUTING/#code-development","text":"See ./DEVELOPER_GUIDE.md","title":"Code Development"},{"location":"docs/CONTRIBUTING/#pr-process","text":"Fork the Project and Clone Create a new branch ( git checkout -b feat/feature-name ) Edit code; update documentation and tests; commit and push Before submitting the review and pushing, make sure to run poetry run doit Open a new Pull Request See the style guide for commit message format ( ./STYLE_GUIDE ) If you run into any issues, please check to see if there is an open issues or open a new one","title":"PR Process"},{"location":"docs/CONTRIBUTING/#other-pr-tips","text":"Link the issue with Fixes #N in the Pull Request body Please add a short summary of why the change was made, what changed , and any relevant information or screenshots # SHA is the SHA of the commit you want to fix git commit --fixup = SHA # Once all the changes are approved, you can squash your commits: git rebase --interactive --autosquash main # Force Push git push --force","title":"Other PR Tips"},{"location":"docs/DEVELOPER_GUIDE/","text":"Developer Notes \u2693\ufe0e Local Development \u2693\ufe0e git clone https://github.com/kyleking/dash_charts.git cd dash_charts poetry install # See the available tasks poetry run doit list # Run the default task list (lint, auto-format, test coverage, etc.) poetry run doit --continue # Make code changes and run specific tasks as needed: poetry run doit run test Publishing \u2693\ufe0e For testing, create an account on TestPyPi . Replace ... with the API token generated on TestPyPi|PyPi respectively poetry config repositories.testpypi https://test.pypi.org/legacy/ poetry config pypi-token.testpypi ... poetry run doit run publish_test_pypi # If you didn't configure a token, you will need to provide your username and password to publish To publish to the real PyPi poetry config pypi-token.pypi ... poetry run doit run publish # For a full release, triple check the default tasks, increment the version, rebuild documentation, and publish! poetry run doit run --continue poetry run doit run cl_bump lock document deploy_docs publish # For pre-releases use cl_bump_pre poetry run doit run cl_bump_pre -p rc poetry run doit run lock document deploy_docs publish Current Status \u2693\ufe0e File Statements Missing Excluded Coverage dash_charts/__init__.py 4 0 0 100.0% dash_charts/app_px.py 130 11 0 91.5% dash_charts/components.py 13 0 0 100.0% dash_charts/coordinate_chart.py 102 1 6 99.0% dash_charts/custom_colorscales.py 3 0 0 100.0% dash_charts/datatable.py 79 25 0 68.4% dash_charts/equations.py 11 0 0 100.0% dash_charts/gantt_chart.py 54 0 0 100.0% dash_charts/modules_datatable.py 100 33 0 67.0% dash_charts/modules_upload.py 130 60 0 53.8% dash_charts/pareto_chart.py 42 0 2 100.0% dash_charts/scatter_line_charts.py 45 0 3 100.0% dash_charts/time_vis_chart.py 61 0 0 100.0% dash_charts/utils_app.py 103 14 6 86.4% dash_charts/utils_app_modules.py 26 3 4 88.5% dash_charts/utils_app_with_navigation.py 118 9 6 92.4% dash_charts/utils_callbacks.py 31 6 0 80.6% dash_charts/utils_data.py 63 1 0 98.4% dash_charts/utils_dataset.py 76 43 0 43.4% dash_charts/utils_fig.py 74 3 4 95.9% dash_charts/utils_helpers.py 19 8 7 57.9% dash_charts/utils_json_cache.py 51 10 0 80.4% dash_charts/utils_static.py 111 5 0 95.5% dash_charts/utils_static_toc.py 22 1 0 95.5% Totals 1468 233 38 84.1% Generated on: 2022-08-04T20:47:35.216758","title":"Developer Notes"},{"location":"docs/DEVELOPER_GUIDE/#developer-notes","text":"","title":"Developer Notes"},{"location":"docs/DEVELOPER_GUIDE/#local-development","text":"git clone https://github.com/kyleking/dash_charts.git cd dash_charts poetry install # See the available tasks poetry run doit list # Run the default task list (lint, auto-format, test coverage, etc.) poetry run doit --continue # Make code changes and run specific tasks as needed: poetry run doit run test","title":"Local Development"},{"location":"docs/DEVELOPER_GUIDE/#publishing","text":"For testing, create an account on TestPyPi . Replace ... with the API token generated on TestPyPi|PyPi respectively poetry config repositories.testpypi https://test.pypi.org/legacy/ poetry config pypi-token.testpypi ... poetry run doit run publish_test_pypi # If you didn't configure a token, you will need to provide your username and password to publish To publish to the real PyPi poetry config pypi-token.pypi ... poetry run doit run publish # For a full release, triple check the default tasks, increment the version, rebuild documentation, and publish! poetry run doit run --continue poetry run doit run cl_bump lock document deploy_docs publish # For pre-releases use cl_bump_pre poetry run doit run cl_bump_pre -p rc poetry run doit run lock document deploy_docs publish","title":"Publishing"},{"location":"docs/DEVELOPER_GUIDE/#current-status","text":"File Statements Missing Excluded Coverage dash_charts/__init__.py 4 0 0 100.0% dash_charts/app_px.py 130 11 0 91.5% dash_charts/components.py 13 0 0 100.0% dash_charts/coordinate_chart.py 102 1 6 99.0% dash_charts/custom_colorscales.py 3 0 0 100.0% dash_charts/datatable.py 79 25 0 68.4% dash_charts/equations.py 11 0 0 100.0% dash_charts/gantt_chart.py 54 0 0 100.0% dash_charts/modules_datatable.py 100 33 0 67.0% dash_charts/modules_upload.py 130 60 0 53.8% dash_charts/pareto_chart.py 42 0 2 100.0% dash_charts/scatter_line_charts.py 45 0 3 100.0% dash_charts/time_vis_chart.py 61 0 0 100.0% dash_charts/utils_app.py 103 14 6 86.4% dash_charts/utils_app_modules.py 26 3 4 88.5% dash_charts/utils_app_with_navigation.py 118 9 6 92.4% dash_charts/utils_callbacks.py 31 6 0 80.6% dash_charts/utils_data.py 63 1 0 98.4% dash_charts/utils_dataset.py 76 43 0 43.4% dash_charts/utils_fig.py 74 3 4 95.9% dash_charts/utils_helpers.py 19 8 7 57.9% dash_charts/utils_json_cache.py 51 10 0 80.4% dash_charts/utils_static.py 111 5 0 95.5% dash_charts/utils_static_toc.py 22 1 0 95.5% Totals 1468 233 38 84.1% Generated on: 2022-08-04T20:47:35.216758","title":"Current Status"},{"location":"docs/SECURITY/","text":"Security \u2693\ufe0e Reporting Security Issues \u2693\ufe0e Do not open issues that might have security implications! It is critical that security related issues are reported privately so we have time to address them before they become public knowledge. Vulnerabilities can be reported by emailing core members: Kyle King ( dev.act.kyle@gmail.com ) Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Environment (e.g. Linux / Windows / macOS) Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. Preferred Languages \u2693\ufe0e We prefer all communications to be in English. Attribution \u2693\ufe0e This file was based on the template from TezRomacH/python-package-template/SECURITY.md","title":"Security"},{"location":"docs/SECURITY/#security","text":"","title":"Security"},{"location":"docs/SECURITY/#reporting-security-issues","text":"Do not open issues that might have security implications! It is critical that security related issues are reported privately so we have time to address them before they become public knowledge. Vulnerabilities can be reported by emailing core members: Kyle King ( dev.act.kyle@gmail.com ) Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Environment (e.g. Linux / Windows / macOS) Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly.","title":"Reporting Security Issues"},{"location":"docs/SECURITY/#preferred-languages","text":"We prefer all communications to be in English.","title":"Preferred Languages"},{"location":"docs/SECURITY/#attribution","text":"This file was based on the template from TezRomacH/python-package-template/SECURITY.md","title":"Attribution"},{"location":"docs/STYLE_GUIDE/","text":"Personal Style Guides \u2693\ufe0e Git \u2693\ufe0e Use Conventional Commits and Commitizen The Changelog is an important part of a project (built with commitizen ). Use semver Conventional Commits \u2693\ufe0e type(scope): description / body The type feat MUST be used when a commit adds a new feature to your application or library. The type fix MUST be used when a commit represents a bug fix for your application. A scope MUST consist of a noun describing a section of the codebase surrounded by parenthesis, e.g., fix(parser): or issue number fix(#32): A ! can be used to indicate a breaking change, e.g. refactor!: drop support for Node 6 What if a commit fits multiple types? Go back and make multiple commits whenever possible. Part of the benefit of Conventional Commits is its ability to drive us to make more organized commits and PRs. It discourages moving fast in a disorganized way. It helps you be able to move fast long term across multiple projects with varied contributors. semver : fix : PATCH / feat : MINOR / BREAKING CHANGE : MAJOR Use git rebase -i to fix commit names prior to merging if incorrect types/scopes are used Commitizen Types and Scopes \u2693\ufe0e Types fix: A bug fix feat: A new feature docs: Documentation-only changes (code comments, separate docs) style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons) perf: A code change that improves performance refactor: A change to production code that is not fix, feat, or perf test: Adding missing or correcting existing tests build: Changes that affect the build system or external dependencies (example scopes: pip, docker, npm) ci: Changes to our CI configuration files and scripts (example scopes: GitLabCI) Scopes Class, File name, Issue Number, other approved noun Git Message Guidelines \u2693\ufe0e Commit message guidelines Full sentence with verb ( lowercase ) and concise description. Below are modified examples for Conventional Commits fix(roles): bug in admin role permissions feat(ui): implement new button design build(pip): upgrade package to remove vulnerabilities refactor: file structure to improve code readability perf(cli): rewrite methods feat(api): endpoints to implement new customer dashboard How to write a good commit message A diff will tell you what changed, but only the commit message can properly tell you why. Keep in mind: This has all been said before . The seven rules of a great Git commit message Try for 50 characters, but consider 72 the hard limit Use the body to explain what and why vs. how Issue Labels and Milestones \u2693\ufe0e Personal Guide Labels Needs Discussion : (#ff5722) Ticket needs discussion and prioritization Type: Bug : (#d73a4a) Something isn\u2019t working Type: Documentation : (#69cde9) Documentation changes Type: Maintenance : (#c5def5) Chore including build/dep, CI, refactor, or perf Type: Idea : (#fbca04) General idea or concept that could become a feature request Type: Feature : (#0075ca) Clearly defined new feature request Milestones Current Tasks (Main Milestone) - name could change based on a specific project, sprint, or month Next Tasks Blue Sky Search is:open is:issue assignee:KyleKing archived:false milestone:\"blue sky\" or no:milestone etc. Research [Sane Github Labels](https://medium.com/@dave_lunny/sane-github-labels-c5d2e6004b63) and see [sensible-github-labels](https://github.com/Relequestual/sensible-github-labels) for full descriptions of each \u201cit is much more helpful to see the status and type of all issues at a glance.\u201d One of each: Status: \u2026 Abandoned, Accepted, Available, Blocked, Completed, In Progress, On Hold, Pending, Review Needed, Revision Needed Type: \u2026 Bug, Maintenance, Question, Enhancement Priority: \u2026 Critical, High, Medium, Low [Britecharts](https://britecharts.github.io/britecharts/github-labels.html) Status: \u2026 On Review \u2013 Request that we are pondering if including or not Needs Reproducing \u2013 For bugs that need to be reproduced in order to get fixed Needs Design \u2013 Feature that needs a design Ready to Go \u2013 Issue that has been defined and is ready to get started with In Progress \u2013 Issue that is being worked on right now. Completed \u2013 Finished feature or fix Type: \u2026 Bug \u2013 An unexpected problem or unintended behavior Feature \u2013 A new feature request Maintenance \u2013 A regular maintenance chore or task, including refactors, build system, CI, performance improvements Documentation \u2013 A documentation improvement task Question \u2013 An issue or PR that needs more information or a user question Not Included Priority: They would add complexity and overhead due to the discussions, but could help with the roadmap Technology Labels: It can create too much overhead, as properly tag with technologies all the issues could be time consuming [Ian Bicking Blog](https://www.ianbicking.org/blog/2014/03/use-github-issues-to-organize-a-project.html) Milestone Overview What are we doing right now? What aren\u2019t we doing right now? 2a. Stuff we\u2019ll probably do soon 2b. Stuff we probably won\u2019t do soon What aren\u2019t we sure about? Milestone Descriptions Stuff we are doing right now: this is the \u201cmain\u201d milestone. We give it a name (like Alpha 2 or Strawberry Rhubarb Pie) and we write down what we are trying to accomplish with the milestone. We create a new milestone when we are ready for the next iteration. Stuff we\u2019ll probably do soon: this is a standing \u201c**Next Tasks**\u201d milestone. We never change or rename this milestone. We use a permanent \u201cNext Tasks\u201d milestone (as opposed to renaming it to \u201cAlpha 3\u201d or actual-next-iteration milestone) because we don\u2019t want to presume or default to including something in the real next iteration. When we\u2019re ready to start planning the next iteration we\u2019ll create a new milestone, and only deliberately move things into that milestone. Stuff we probably won\u2019t do soon: this is a standing \u201c**Blue Sky**\u201d milestone. We refer to these tickets and sometimes look through them, but they are easy to ignore, somewhat intentionally ignored. What aren\u2019t we sure about?: issues with no milestone. Label: \u201cNeeds Discussion\u201d - (addressed in a triage meeting) - use liberally for either big or small tickets \u201cIt\u2019s better to give people more power: it\u2019s actually helpful if people can overreach because it is an opportunity to establish where the limits really are and what purpose those limits have\u201d External Links \u2693\ufe0e TODO: Revisit Git: The Simple Guide Commit Messages and why use the present tense Github\u2019s Advice on Github Most Comprehensive Guide Git Pro Book (free) Bash Tab-Completion Snippet Python \u2693\ufe0e TODO: Revisit Python Style Guides https://gist.github.com/sloria/7001839 http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/ https://innoq.github.io/cards42org_en/ https://docs.openstack.org/hacking/latest/user/hacking.html#styleguide https://www.python.org/doc/humor/ https://docs.python-guide.org/writing/reading/ https://realpython.com/python-refactoring/ ADRs \u2693\ufe0e TODO: Revisit Examples https://github.com/pawamoy/mkdocstrings/issues/28","title":"Personal Style Guides"},{"location":"docs/STYLE_GUIDE/#personal-style-guides","text":"","title":"Personal Style Guides"},{"location":"docs/STYLE_GUIDE/#git","text":"Use Conventional Commits and Commitizen The Changelog is an important part of a project (built with commitizen ). Use semver","title":"Git"},{"location":"docs/STYLE_GUIDE/#conventional-commits","text":"type(scope): description / body The type feat MUST be used when a commit adds a new feature to your application or library. The type fix MUST be used when a commit represents a bug fix for your application. A scope MUST consist of a noun describing a section of the codebase surrounded by parenthesis, e.g., fix(parser): or issue number fix(#32): A ! can be used to indicate a breaking change, e.g. refactor!: drop support for Node 6 What if a commit fits multiple types? Go back and make multiple commits whenever possible. Part of the benefit of Conventional Commits is its ability to drive us to make more organized commits and PRs. It discourages moving fast in a disorganized way. It helps you be able to move fast long term across multiple projects with varied contributors. semver : fix : PATCH / feat : MINOR / BREAKING CHANGE : MAJOR Use git rebase -i to fix commit names prior to merging if incorrect types/scopes are used","title":"Conventional Commits"},{"location":"docs/STYLE_GUIDE/#commitizen-types-and-scopes","text":"Types fix: A bug fix feat: A new feature docs: Documentation-only changes (code comments, separate docs) style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons) perf: A code change that improves performance refactor: A change to production code that is not fix, feat, or perf test: Adding missing or correcting existing tests build: Changes that affect the build system or external dependencies (example scopes: pip, docker, npm) ci: Changes to our CI configuration files and scripts (example scopes: GitLabCI) Scopes Class, File name, Issue Number, other approved noun","title":"Commitizen Types and Scopes"},{"location":"docs/STYLE_GUIDE/#git-message-guidelines","text":"Commit message guidelines Full sentence with verb ( lowercase ) and concise description. Below are modified examples for Conventional Commits fix(roles): bug in admin role permissions feat(ui): implement new button design build(pip): upgrade package to remove vulnerabilities refactor: file structure to improve code readability perf(cli): rewrite methods feat(api): endpoints to implement new customer dashboard How to write a good commit message A diff will tell you what changed, but only the commit message can properly tell you why. Keep in mind: This has all been said before . The seven rules of a great Git commit message Try for 50 characters, but consider 72 the hard limit Use the body to explain what and why vs. how","title":"Git Message Guidelines"},{"location":"docs/STYLE_GUIDE/#issue-labels-and-milestones","text":"Personal Guide Labels Needs Discussion : (#ff5722) Ticket needs discussion and prioritization Type: Bug : (#d73a4a) Something isn\u2019t working Type: Documentation : (#69cde9) Documentation changes Type: Maintenance : (#c5def5) Chore including build/dep, CI, refactor, or perf Type: Idea : (#fbca04) General idea or concept that could become a feature request Type: Feature : (#0075ca) Clearly defined new feature request Milestones Current Tasks (Main Milestone) - name could change based on a specific project, sprint, or month Next Tasks Blue Sky Search is:open is:issue assignee:KyleKing archived:false milestone:\"blue sky\" or no:milestone etc. Research [Sane Github Labels](https://medium.com/@dave_lunny/sane-github-labels-c5d2e6004b63) and see [sensible-github-labels](https://github.com/Relequestual/sensible-github-labels) for full descriptions of each \u201cit is much more helpful to see the status and type of all issues at a glance.\u201d One of each: Status: \u2026 Abandoned, Accepted, Available, Blocked, Completed, In Progress, On Hold, Pending, Review Needed, Revision Needed Type: \u2026 Bug, Maintenance, Question, Enhancement Priority: \u2026 Critical, High, Medium, Low [Britecharts](https://britecharts.github.io/britecharts/github-labels.html) Status: \u2026 On Review \u2013 Request that we are pondering if including or not Needs Reproducing \u2013 For bugs that need to be reproduced in order to get fixed Needs Design \u2013 Feature that needs a design Ready to Go \u2013 Issue that has been defined and is ready to get started with In Progress \u2013 Issue that is being worked on right now. Completed \u2013 Finished feature or fix Type: \u2026 Bug \u2013 An unexpected problem or unintended behavior Feature \u2013 A new feature request Maintenance \u2013 A regular maintenance chore or task, including refactors, build system, CI, performance improvements Documentation \u2013 A documentation improvement task Question \u2013 An issue or PR that needs more information or a user question Not Included Priority: They would add complexity and overhead due to the discussions, but could help with the roadmap Technology Labels: It can create too much overhead, as properly tag with technologies all the issues could be time consuming [Ian Bicking Blog](https://www.ianbicking.org/blog/2014/03/use-github-issues-to-organize-a-project.html) Milestone Overview What are we doing right now? What aren\u2019t we doing right now? 2a. Stuff we\u2019ll probably do soon 2b. Stuff we probably won\u2019t do soon What aren\u2019t we sure about? Milestone Descriptions Stuff we are doing right now: this is the \u201cmain\u201d milestone. We give it a name (like Alpha 2 or Strawberry Rhubarb Pie) and we write down what we are trying to accomplish with the milestone. We create a new milestone when we are ready for the next iteration. Stuff we\u2019ll probably do soon: this is a standing \u201c**Next Tasks**\u201d milestone. We never change or rename this milestone. We use a permanent \u201cNext Tasks\u201d milestone (as opposed to renaming it to \u201cAlpha 3\u201d or actual-next-iteration milestone) because we don\u2019t want to presume or default to including something in the real next iteration. When we\u2019re ready to start planning the next iteration we\u2019ll create a new milestone, and only deliberately move things into that milestone. Stuff we probably won\u2019t do soon: this is a standing \u201c**Blue Sky**\u201d milestone. We refer to these tickets and sometimes look through them, but they are easy to ignore, somewhat intentionally ignored. What aren\u2019t we sure about?: issues with no milestone. Label: \u201cNeeds Discussion\u201d - (addressed in a triage meeting) - use liberally for either big or small tickets \u201cIt\u2019s better to give people more power: it\u2019s actually helpful if people can overreach because it is an opportunity to establish where the limits really are and what purpose those limits have\u201d","title":"Issue Labels and Milestones"},{"location":"docs/STYLE_GUIDE/#external-links","text":"TODO: Revisit Git: The Simple Guide Commit Messages and why use the present tense Github\u2019s Advice on Github Most Comprehensive Guide Git Pro Book (free) Bash Tab-Completion Snippet","title":"External Links"},{"location":"docs/STYLE_GUIDE/#python","text":"TODO: Revisit Python Style Guides https://gist.github.com/sloria/7001839 http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/ https://innoq.github.io/cards42org_en/ https://docs.openstack.org/hacking/latest/user/hacking.html#styleguide https://www.python.org/doc/humor/ https://docs.python-guide.org/writing/reading/ https://realpython.com/python-refactoring/","title":"Python"},{"location":"docs/STYLE_GUIDE/#adrs","text":"TODO: Revisit Examples https://github.com/pawamoy/mkdocstrings/issues/28","title":"ADRs"},{"location":"modules/dash_charts/","text":"dash_charts \u2693\ufe0e dash_charts. View Source \"\"\"dash_charts.\"\"\" from loguru import logger __version__ = '0.1.2' __pkg_name__ = 'dash_charts' logger . disable ( __pkg_name__ ) # ====== Above is the recommended code from calcipy_template and may be updated on new releases ====== Sub-modules \u2693\ufe0e dash_charts.app_px dash_charts.components dash_charts.coordinate_chart dash_charts.custom_colorscales dash_charts.datatable dash_charts.equations dash_charts.gantt_chart dash_charts.modules_datatable dash_charts.modules_upload dash_charts.pareto_chart dash_charts.scatter_line_charts dash_charts.time_vis_chart dash_charts.utils_app dash_charts.utils_app_modules dash_charts.utils_app_with_navigation dash_charts.utils_callbacks dash_charts.utils_data dash_charts.utils_dataset dash_charts.utils_fig dash_charts.utils_helpers dash_charts.utils_json_cache dash_charts.utils_static dash_charts.utils_static_toc","title":"dash_charts"},{"location":"modules/dash_charts/#dash_charts","text":"dash_charts. View Source \"\"\"dash_charts.\"\"\" from loguru import logger __version__ = '0.1.2' __pkg_name__ = 'dash_charts' logger . disable ( __pkg_name__ ) # ====== Above is the recommended code from calcipy_template and may be updated on new releases ======","title":"dash_charts"},{"location":"modules/dash_charts/#sub-modules","text":"dash_charts.app_px dash_charts.components dash_charts.coordinate_chart dash_charts.custom_colorscales dash_charts.datatable dash_charts.equations dash_charts.gantt_chart dash_charts.modules_datatable dash_charts.modules_upload dash_charts.pareto_chart dash_charts.scatter_line_charts dash_charts.time_vis_chart dash_charts.utils_app dash_charts.utils_app_modules dash_charts.utils_app_with_navigation dash_charts.utils_callbacks dash_charts.utils_data dash_charts.utils_dataset dash_charts.utils_fig dash_charts.utils_helpers dash_charts.utils_json_cache dash_charts.utils_static dash_charts.utils_static_toc","title":"Sub-modules"},{"location":"modules/dash_charts/_code_diagrams/","text":"Code Diagrams \u2693\ufe0e Auto-generated with pylint-pyreverse Packages \u2693\ufe0e Full Size Classes \u2693\ufe0e Full Size","title":"Code Diagrams"},{"location":"modules/dash_charts/_code_diagrams/#code-diagrams","text":"Auto-generated with pylint-pyreverse","title":"Code Diagrams"},{"location":"modules/dash_charts/_code_diagrams/#packages","text":"Full Size","title":"Packages"},{"location":"modules/dash_charts/_code_diagrams/#classes","text":"Full Size","title":"Classes"},{"location":"modules/dash_charts/app_px/","text":"dash_charts.app_px \u2693\ufe0e Generic Plotly Express Data Analysis App(s). Examples: https://www.plotly.express/ Docs: https://www.plotly.express/plotly_express/ (Currently) Unsupported plotly express types \u2693\ufe0e px . parallel_coordinates ( px . data . iris (), color = \"species_id\" , dimensions = [ 'sepal_width' , 'sepal_length' , 'petal_width' , 'petal_length' ]) px . treemap ( px . data . tips (), path = [ 'day' , 'time' , 'sex' ], values = 'total_bill' ) px . sunburst ( px . data . tips (), path = [ 'day' , 'time' , 'sex' ], values = 'total_bill) Other charts that could be useful (but won\u2019t work with simple dropdowns) scatter_matrix([data_frame, dimensions, \u2026]) In a scatter plot matrix (or SPLOM), each row of data_frame is https://plotly.com/python/splom/ parallel_coordinates([data_frame, \u2026]) In a parallel coordinates plot, each row of data_frame is represented https://plotly.com/python-api-reference/generated/plotly.express.parallel_coordinates.html parallel_categories([data_frame, \u2026]) In a parallel categories (or parallel sets) plot, each row of https://plotly.com/python-api-reference/generated/plotly.express.parallel_categories.html density_heatmap([data_frame, x, y, z, \u2026]) In a density heatmap, rows of data_frame are grouped together into https://plotly.com/python-api-reference/generated/plotly.express.density_heatmap.html imshow(img[, zmin, zmax, origin, \u2026]) Display an image, i.e. https://plotly.com/python/imshow/ View Source \"\"\"Generic Plotly Express Data Analysis App(s). Examples: https://www.plotly.express/ Docs: https://www.plotly.express/plotly_express/ # (Currently) Unsupported plotly express types ```py px.parallel_coordinates(px.data.iris(), color=\"species_id\", dimensions=['sepal_width', 'sepal_length', 'petal_width', 'petal_length']) px.treemap(px.data.tips(), path=['day', 'time', 'sex'], values='total_bill') px.sunburst(px.data.tips(), path=['day', 'time', 'sex'], values='total_bill) Other charts that could be useful (but won\u2019t work with simple dropdowns) scatter_matrix([data_frame, dimensions, \u2026]) In a scatter plot matrix (or SPLOM), each row of data_frame is https://plotly.com/python/splom/ parallel_coordinates([data_frame, \u2026]) In a parallel coordinates plot, each row of data_frame is represented https://plotly.com/python-api-reference/generated/plotly.express.parallel_coordinates.html parallel_categories([data_frame, \u2026]) In a parallel categories (or parallel sets) plot, each row of https://plotly.com/python-api-reference/generated/plotly.express.parallel_categories.html density_heatmap([data_frame, x, y, z, \u2026]) In a density heatmap, rows of data_frame are grouped together into https://plotly.com/python-api-reference/generated/plotly.express.density_heatmap.html imshow(img[, zmin, zmax, origin, \u2026]) Display an image, i.e. https://plotly.com/python/imshow/ \u201d\u201c\u201d from collections import OrderedDict import dash import dash_bootstrap_components as dbc import pandas as pd import plotly.express as px from dash import html from implements import implements from .components import dropdown_group, opts_dd from .utils_app import AppBase, AppInterface from .utils_app_with_navigation import FullScreenAppWithTabs from .utils_callbacks import map_args, map_outputs from .utils_fig import min_graph ====================================================================================================================== \u2693\ufe0e Create classes to manage tabs state. Easy to scale up or down \u2693\ufe0e >> Demo uses sample data. User could replace with data loaded from a static CSV file, TinyDB, SQLite, etc. \u2693\ufe0e @implements(AppInterface) # noqa: H601 class TabBase(AppBase): \u201c\u201d\u201cBase tab class with helper methods.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 external_stylesheets = [ dbc . themes . FLATLY ] # ID Elements for UI id_chart : str = 'chart' id_func : str = 'func' id_template : str = 'template' # PLANNED: template should be able to be None takes_args : bool = True \"\"\"If True, will pass arguments from UI to function.\"\"\" templates : list = [ 'ggplot2' , 'seaborn' , 'simple_white' , 'plotly' , 'plotly_white' , 'plotly_dark' , 'presentation' , 'xgridoff' , 'ygridoff' , 'gridon' , 'none' , ] \"\"\"List of templates from: `import plotly.io as pio; pio.templates`\"\"\" # Must override in child class name : str = None \"\"\"Unique tab component name. Must be overridden in child class.\"\"\" data : pd . DataFrame = None \"\"\"Dataframe. Must be overridden in child class.\"\"\" func_map : OrderedDict = None \"\"\"Map of functions to keywords. Must be overridden in child class.\"\"\" # PLANNED: below items should be able to be None dims : tuple = () \"\"\"Keyword from function for dropdowns with column names as options. Must be overridden in child class.\"\"\" dims_dict : OrderedDict = OrderedDict ([]) \"\"\"OrderedDict of keyword from function to allowed values. Must be overridden in child class.\"\"\" default_dim_name = {} \"\"\"Lookup for dim:column name to use as default in dropdown.\"\"\" def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) @implements(AppInterface) # noqa: H601 class TabTip(TabBase): \u201c\u201d\u201cTabTip properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name = 'Tip Data' data = px.data.tips() func_map = OrderedDict([ ('scatter', px.scatter), ('density_contour', px.density_contour), ]) dims = ('x', 'y', 'color', 'facet_row', 'facet_col') dims_dict = OrderedDict([ ('marginal_x', ('histogram', 'rag', 'violin', 'box')), ('marginal_y', ('histogram', 'rag', 'violin', 'box')), ('trendline', ('ols', 'lowess')), ]) default_dim_name = { 'x': 'total_bill', 'y': 'tip', 'color': 'smoker', } @implements(AppInterface) # noqa: H601 class TabIris(TabBase): \u201c\u201d\u201cTabIris properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name = 'Iris Data' data = px.data.iris() func_map = OrderedDict([ ('histogram', px.histogram), ('bar', px.bar), ('strip', px.strip), ('box', px.box), ('violin', px.violin), ]) dims = ('x', 'y', 'color', 'facet_row', 'facet_col') default_dim_name = { 'x': 'sepal_width', 'color': 'species', } @implements(AppInterface) # noqa: H601 class TabGapminder(TabBase): \u201c\u201d\u201cTabGapminder properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 name = 'Gapminder Data' data = px.data.gapminder() func_map = OrderedDict([ ('area', px.area), ('line', px.line), ]) dims = ('x', 'y', 'color', 'line_group', 'facet_row', 'facet_col') default_dim_name = { 'x': 'year', 'y': 'pop', 'color': 'continent', 'line_group': 'country', } @implements(AppInterface) # noqa: H601 class TabTernary(TabBase): \u201c\u201d\u201cTabTernary properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name = ' Ternary ' data = px . data . election () func_map = OrderedDict ( [ ( ' scatter_ternary ' , px . scatter_ternary ) , ( ' line_ternary ' , px . line_ternary ) , ] ) dims = ( ' a ' , ' b ' , ' c ' , ' color ' , ' hover_name ' ) # size - only for scatter default_dim_name = { ' a ' : ' Joly ' , ' b ' : ' Coderre ' , ' c ' : ' Bergeron ' , ' color ' : ' winner ' , ' hover_name ' : ' district ' , } @implements(AppInterface) # noqa: H601 class TabWind(TabBase): \u201c\u201d\u201cTabWind properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name = 'Wind' data = px.data.wind() func_map = OrderedDict([ ('scatter_polar', px.scatter_polar), ('line_polar', px.line_polar), # (line_close=True) ('bar_polar', px.bar_polar), ]) dims = ('r', 'theta', 'color') default_dim_name = { 'r': 'frequency', 'theta': 'direction', 'color': 'strength', 'symbol': 'strength', } @implements(AppInterface) # noqa: H601 class TabColor(TabBase): \u201c\u201d\u201cTabColor properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 name = 'Color Swatches' takes_args = False func_map = OrderedDict([ ('colors.qualitative', px.colors.qualitative.swatches), ('colors.sequential', px.colors.sequential.swatches), ('colors.diverging', px.colors.diverging.swatches), ('colors.cyclical', px.colors.cyclical.swatches), ('colors.colorbrewer', px.colors.colorbrewer.swatches), ('colors.cmocean', px.colors.cmocean.swatches), ('colors.carto', px.colors.carto.swatches), ]) default_dim_name = { 'x': 'sepal_width', 'y': 'sepal_length', } ====================================================================================================================== \u2693\ufe0e Create class for application to control manage variable scopes \u2693\ufe0e class InteractivePXApp(FullScreenAppWithTabs): # noqa: H601 \u201c\u201d\u201cPlotly Express Demo application.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name = 'TabAppDemo' tabs_location = 'right' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '175px' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def define_nav_elements ( self ) : \"\"\"Return list of initialized tabs. Returns: list: each item is an initialized tab (ex `[AppBase(self.app)]` in the order each tab is rendered \"\"\" return [ TabTip ( app = self . app ), TabIris ( app = self . app ), TabGapminder ( app = self . app ), TabTernary ( app = self . app ), TabWind ( app = self . app ), TabColor ( app = self . app ), ] def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . H1 ( 'Dash/Plotly Express Data Exploration Demo' , style = { 'padding' : '15px 0 0 15px' }), super (). return_layout (), ]) ``` Classes \u2693\ufe0e InteractivePXApp \u2693\ufe0e class InteractivePXApp ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class InteractivePXApp ( FullScreenAppWithTabs ): # noqa: H601 \"\"\"Plotly Express Demo application.\"\"\" name = 'TabAppDemo' tabs_location = 'right' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '175px' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def define_nav_elements ( self ): \"\"\"Return list of initialized tabs. Returns: list: each item is an initialized tab (ex `[AppBase(self.app)]` in the order each tab is rendered \"\"\" return [ TabTip ( app = self . app ), TabIris ( app = self . app ), TabGapminder ( app = self . app ), TabTernary ( app = self . app ), TabWind ( app = self . app ), TabColor ( app = self . app ), ] def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . H1 ( 'Dash/Plotly Express Data Exploration Demo' , style = { 'padding' : '15px 0 0 15px' }), super () . return_layout (), ]) Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_with_navigation.FullScreenAppWithTabs dash_charts.utils_app_with_navigation.AppWithTabs dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase Class variables \u2693\ufe0e app app_ids external_stylesheets id_tabs_content id_tabs_select init_app_kwargs modules name nav_layouts nav_lookup nsi tabs_compact Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True. tabs_location Tab orientation setting. One of (left, top, bottom, right) . tabs_margin Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs. validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]] create_elements \u2693\ufe0e def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover define_nav_elements \u2693\ufe0e def define_nav_elements ( self ) Return list of initialized tabs. Returns: Type Description list each item is an initialized tab (ex [AppBase(self.app)] in the order each tab is rendered View Source def define_nav_elements ( self ): \"\"\"Return list of initialized tabs. Returns: list: each item is an initialized tab (ex `[AppBase(self.app)]` in the order each tab is rendered \"\"\" return [ TabTip ( app = self . app ), TabIris ( app = self . app ), TabGapminder ( app = self . app ), TabTernary ( app = self . app ), TabWind ( app = self . app ), TabColor ( app = self . app ), ] generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... generate_tab_kwargs \u2693\ufe0e def generate_tab_kwargs ( self ) Create the tab keyword arguments. Intended to be modified through inheritance. Returns: Type Description tuple keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys (style, selected_style) for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element View Source def generate_tab_kwargs ( self ): \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys `(style, selected_style)` for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact : tab_style = { 'padding' : '2px 4px 2px 4px' } tabs_padding = '6px 0 0 2px' else : tab_style = { 'padding' : '10px 20px 10px 20px' } tabs_padding = '15px 0 0 5px' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = { 'top' : 'bottom' , 'bottom' : 'top' , 'left' : 'right' , 'right' : 'left' } tabs_style = { # noqa: ECE001 'backgroundColor' : '#F9F9F9' , 'padding' : tabs_padding , 'position' : 'fixed' , 'zIndex' : '999' , f 'border { opposite_lookup [ self . tabs_location ] . title () } ' : '1px solid #d6d6d6' , self . tabs_location : '0' , } if self . tabs_location in [ 'left' , 'right' ]: # Configure for vertical case selected_style [ 'border-left' ] = '3px solid #119DFF' tabs_kwargs = { 'vertical' : True , 'style' : { 'width' : '100%' }, 'parent_style' : { 'width' : '100%' }, } tabs_style [ 'top' ] = '0' tabs_style [ 'bottom' ] = '0' tabs_style [ 'width' ] = 'auto' else : # Configure for horizontal case selected_style [ 'border-top' ] = '3px solid #119DFF' tabs_kwargs = {} tabs_style [ 'height' ] = 'auto' tabs_style [ 'right' ] = '0' tabs_style [ 'left' ] = '0' tab_kwargs = { 'style' : tab_style , 'selected_style' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style ) get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . H1 ( 'Dash/Plotly Express Data Exploration Demo' , style = { 'padding' : '15px 0 0 15px' }), super () . return_layout (), ]) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover tab_menu \u2693\ufe0e def tab_menu ( self ) Return the HTML elements for the tab menu. Returns: Type Description dict Dash HTML object View Source def tab_menu ( self ): \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , ) verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ): \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" super () . verify_app_initialization () allowed_locations = ( 'left' , 'top' , 'bottom' , 'right' ) if self . tabs_location not in allowed_locations : # pragma: no cover raise RuntimeError ( f '`self.tabs_location = { self . tabs_location } ` is not in { allowed_locations } ' ) TabBase \u2693\ufe0e class TabBase ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabBase ( AppBase ): \"\"\"Base tab class with helper methods.\"\"\" external_stylesheets = [ dbc . themes . FLATLY ] # ID Elements for UI id_chart : str = 'chart' id_func : str = 'func' id_template : str = 'template' # PLANNED: template should be able to be None takes_args : bool = True \"\"\"If True, will pass arguments from UI to function.\"\"\" templates : list = [ 'ggplot2' , 'seaborn' , 'simple_white' , 'plotly' , 'plotly_white' , 'plotly_dark' , 'presentation' , 'xgridoff' , 'ygridoff' , 'gridon' , 'none' , ] \"\"\"List of templates from: `import plotly.io as pio; pio.templates`\"\"\" # Must override in child class name : str = None \"\"\"Unique tab component name. Must be overridden in child class.\"\"\" data : pd . DataFrame = None \"\"\"Dataframe. Must be overridden in child class.\"\"\" func_map : OrderedDict = None \"\"\"Map of functions to keywords. Must be overridden in child class.\"\"\" # PLANNED: below items should be able to be None dims : tuple = () \"\"\"Keyword from function for dropdowns with column names as options. Must be overridden in child class.\"\"\" dims_dict : OrderedDict = OrderedDict ([]) \"\"\"OrderedDict of keyword from function to allowed values. Must be overridden in child class.\"\"\" default_dim_name = {} \"\"\"Lookup for dim:column name to use as default in dropdown.\"\"\" def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app.AppBase Descendants \u2693\ufe0e dash_charts.app_px.TabTip dash_charts.app_px.TabIris dash_charts.app_px.TabGapminder dash_charts.app_px.TabTernary dash_charts.app_px.TabWind dash_charts.app_px.TabColor Class variables \u2693\ufe0e data default_dim_name Lookup for dim:column name to use as default in dropdown. dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) TabColor \u2693\ufe0e class TabColor ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabColor ( TabBase ): \"\"\"TabColor properties.\"\"\" name = 'Color Swatches' takes_args = False func_map = OrderedDict ([ ( 'colors.qualitative' , px . colors . qualitative . swatches ), ( 'colors.sequential' , px . colors . sequential . swatches ), ( 'colors.diverging' , px . colors . diverging . swatches ), ( 'colors.cyclical' , px . colors . cyclical . swatches ), ( 'colors.colorbrewer' , px . colors . colorbrewer . swatches ), ( 'colors.cmocean' , px . colors . cmocean . swatches ), ( 'colors.carto' , px . colors . carto . swatches ), ]) default_dim_name = { 'x' : 'sepal_width' , 'y' : 'sepal_length' , } Ancestors (in MRO) \u2693\ufe0e dash_charts.app_px.TabBase dash_charts.utils_app.AppBase Class variables \u2693\ufe0e data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) TabGapminder \u2693\ufe0e class TabGapminder ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabGapminder ( TabBase ): \"\"\"TabGapminder properties.\"\"\" name = 'Gapminder Data' data = px . data . gapminder () func_map = OrderedDict ([ ( 'area' , px . area ), ( 'line' , px . line ), ]) dims = ( 'x' , 'y' , 'color' , 'line_group' , 'facet_row' , 'facet_col' ) default_dim_name = { 'x' : 'year' , 'y' : 'pop' , 'color' : 'continent' , 'line_group' : 'country' , } Ancestors (in MRO) \u2693\ufe0e dash_charts.app_px.TabBase dash_charts.utils_app.AppBase Class variables \u2693\ufe0e data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) TabIris \u2693\ufe0e class TabIris ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabIris ( TabBase ): \"\"\"TabIris properties.\"\"\" name = 'Iris Data' data = px . data . iris () func_map = OrderedDict ([ ( 'histogram' , px . histogram ), ( 'bar' , px . bar ), ( 'strip' , px . strip ), ( 'box' , px . box ), ( 'violin' , px . violin ), ]) dims = ( 'x' , 'y' , 'color' , 'facet_row' , 'facet_col' ) default_dim_name = { 'x' : 'sepal_width' , 'color' : 'species' , } Ancestors (in MRO) \u2693\ufe0e dash_charts.app_px.TabBase dash_charts.utils_app.AppBase Class variables \u2693\ufe0e data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) TabTernary \u2693\ufe0e class TabTernary ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabTernary ( TabBase ): \"\"\"TabTernary properties.\"\"\" name = 'Ternary' data = px . data . election () func_map = OrderedDict ([ ( 'scatter_ternary' , px . scatter_ternary ), ( 'line_ternary' , px . line_ternary ), ]) dims = ( 'a' , 'b' , 'c' , 'color' , 'hover_name' ) # size - only for scatter default_dim_name = { 'a' : 'Joly' , 'b' : 'Coderre' , 'c' : 'Bergeron' , 'color' : 'winner' , 'hover_name' : 'district' , } Ancestors (in MRO) \u2693\ufe0e dash_charts.app_px.TabBase dash_charts.utils_app.AppBase Class variables \u2693\ufe0e data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) TabTip \u2693\ufe0e class TabTip ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabTip ( TabBase ): \"\"\"TabTip properties.\"\"\" name = 'Tip Data' data = px . data . tips () func_map = OrderedDict ([ ( 'scatter' , px . scatter ), ( 'density_contour' , px . density_contour ), ]) dims = ( 'x' , 'y' , 'color' , 'facet_row' , 'facet_col' ) dims_dict = OrderedDict ([ ( 'marginal_x' , ( 'histogram' , 'rag' , 'violin' , 'box' )), ( 'marginal_y' , ( 'histogram' , 'rag' , 'violin' , 'box' )), ( 'trendline' , ( 'ols' , 'lowess' )), ]) default_dim_name = { 'x' : 'total_bill' , 'y' : 'tip' , 'color' : 'smoker' , } Ancestors (in MRO) \u2693\ufe0e dash_charts.app_px.TabBase dash_charts.utils_app.AppBase Class variables \u2693\ufe0e data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) TabWind \u2693\ufe0e class TabWind ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabWind ( TabBase ): \"\"\"TabWind properties.\"\"\" name = 'Wind' data = px . data . wind () func_map = OrderedDict ([ ( 'scatter_polar' , px . scatter_polar ), ( 'line_polar' , px . line_polar ), # (line_close=True) ( 'bar_polar' , px . bar_polar ), ]) dims = ( 'r' , 'theta' , 'color' ) default_dim_name = { 'r' : 'frequency' , 'theta' : 'direction' , 'color' : 'strength' , 'symbol' : 'strength' , } Ancestors (in MRO) \u2693\ufe0e dash_charts.app_px.TabBase dash_charts.utils_app.AppBase Class variables \u2693\ufe0e data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) register_update_chart \u2693\ufe0e def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) verify_types_for_callbacks \u2693\ufe0e def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) verify_types_for_layout \u2693\ufe0e def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"dash_charts.app_px"},{"location":"modules/dash_charts/app_px/#dash_chartsapp_px","text":"Generic Plotly Express Data Analysis App(s). Examples: https://www.plotly.express/ Docs: https://www.plotly.express/plotly_express/","title":"dash_charts.app_px"},{"location":"modules/dash_charts/app_px/#currently-unsupported-plotly-express-types","text":"px . parallel_coordinates ( px . data . iris (), color = \"species_id\" , dimensions = [ 'sepal_width' , 'sepal_length' , 'petal_width' , 'petal_length' ]) px . treemap ( px . data . tips (), path = [ 'day' , 'time' , 'sex' ], values = 'total_bill' ) px . sunburst ( px . data . tips (), path = [ 'day' , 'time' , 'sex' ], values = 'total_bill) Other charts that could be useful (but won\u2019t work with simple dropdowns) scatter_matrix([data_frame, dimensions, \u2026]) In a scatter plot matrix (or SPLOM), each row of data_frame is https://plotly.com/python/splom/ parallel_coordinates([data_frame, \u2026]) In a parallel coordinates plot, each row of data_frame is represented https://plotly.com/python-api-reference/generated/plotly.express.parallel_coordinates.html parallel_categories([data_frame, \u2026]) In a parallel categories (or parallel sets) plot, each row of https://plotly.com/python-api-reference/generated/plotly.express.parallel_categories.html density_heatmap([data_frame, x, y, z, \u2026]) In a density heatmap, rows of data_frame are grouped together into https://plotly.com/python-api-reference/generated/plotly.express.density_heatmap.html imshow(img[, zmin, zmax, origin, \u2026]) Display an image, i.e. https://plotly.com/python/imshow/ View Source \"\"\"Generic Plotly Express Data Analysis App(s). Examples: https://www.plotly.express/ Docs: https://www.plotly.express/plotly_express/ # (Currently) Unsupported plotly express types ```py px.parallel_coordinates(px.data.iris(), color=\"species_id\", dimensions=['sepal_width', 'sepal_length', 'petal_width', 'petal_length']) px.treemap(px.data.tips(), path=['day', 'time', 'sex'], values='total_bill') px.sunburst(px.data.tips(), path=['day', 'time', 'sex'], values='total_bill) Other charts that could be useful (but won\u2019t work with simple dropdowns) scatter_matrix([data_frame, dimensions, \u2026]) In a scatter plot matrix (or SPLOM), each row of data_frame is https://plotly.com/python/splom/ parallel_coordinates([data_frame, \u2026]) In a parallel coordinates plot, each row of data_frame is represented https://plotly.com/python-api-reference/generated/plotly.express.parallel_coordinates.html parallel_categories([data_frame, \u2026]) In a parallel categories (or parallel sets) plot, each row of https://plotly.com/python-api-reference/generated/plotly.express.parallel_categories.html density_heatmap([data_frame, x, y, z, \u2026]) In a density heatmap, rows of data_frame are grouped together into https://plotly.com/python-api-reference/generated/plotly.express.density_heatmap.html imshow(img[, zmin, zmax, origin, \u2026]) Display an image, i.e. https://plotly.com/python/imshow/ \u201d\u201c\u201d from collections import OrderedDict import dash import dash_bootstrap_components as dbc import pandas as pd import plotly.express as px from dash import html from implements import implements from .components import dropdown_group, opts_dd from .utils_app import AppBase, AppInterface from .utils_app_with_navigation import FullScreenAppWithTabs from .utils_callbacks import map_args, map_outputs from .utils_fig import min_graph","title":"(Currently) Unsupported plotly express types"},{"location":"modules/dash_charts/app_px/#_1","text":"","title":"======================================================================================================================"},{"location":"modules/dash_charts/app_px/#create-classes-to-manage-tabs-state-easy-to-scale-up-or-down","text":"","title":"Create classes to manage tabs state. Easy to scale up or down"},{"location":"modules/dash_charts/app_px/#demo-uses-sample-data-user-could-replace-with-data-loaded-from-a-static-csv-file-tinydb-sqlite-etc","text":"@implements(AppInterface) # noqa: H601 class TabBase(AppBase): \u201c\u201d\u201cBase tab class with helper methods.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 external_stylesheets = [ dbc . themes . FLATLY ] # ID Elements for UI id_chart : str = 'chart' id_func : str = 'func' id_template : str = 'template' # PLANNED: template should be able to be None takes_args : bool = True \"\"\"If True, will pass arguments from UI to function.\"\"\" templates : list = [ 'ggplot2' , 'seaborn' , 'simple_white' , 'plotly' , 'plotly_white' , 'plotly_dark' , 'presentation' , 'xgridoff' , 'ygridoff' , 'gridon' , 'none' , ] \"\"\"List of templates from: `import plotly.io as pio; pio.templates`\"\"\" # Must override in child class name : str = None \"\"\"Unique tab component name. Must be overridden in child class.\"\"\" data : pd . DataFrame = None \"\"\"Dataframe. Must be overridden in child class.\"\"\" func_map : OrderedDict = None \"\"\"Map of functions to keywords. Must be overridden in child class.\"\"\" # PLANNED: below items should be able to be None dims : tuple = () \"\"\"Keyword from function for dropdowns with column names as options. Must be overridden in child class.\"\"\" dims_dict : OrderedDict = OrderedDict ([]) \"\"\"OrderedDict of keyword from function to allowed values. Must be overridden in child class.\"\"\" default_dim_name = {} \"\"\"Lookup for dim:column name to use as default in dropdown.\"\"\" def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )]) @implements(AppInterface) # noqa: H601 class TabTip(TabBase): \u201c\u201d\u201cTabTip properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name = 'Tip Data' data = px.data.tips() func_map = OrderedDict([ ('scatter', px.scatter), ('density_contour', px.density_contour), ]) dims = ('x', 'y', 'color', 'facet_row', 'facet_col') dims_dict = OrderedDict([ ('marginal_x', ('histogram', 'rag', 'violin', 'box')), ('marginal_y', ('histogram', 'rag', 'violin', 'box')), ('trendline', ('ols', 'lowess')), ]) default_dim_name = { 'x': 'total_bill', 'y': 'tip', 'color': 'smoker', } @implements(AppInterface) # noqa: H601 class TabIris(TabBase): \u201c\u201d\u201cTabIris properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name = 'Iris Data' data = px.data.iris() func_map = OrderedDict([ ('histogram', px.histogram), ('bar', px.bar), ('strip', px.strip), ('box', px.box), ('violin', px.violin), ]) dims = ('x', 'y', 'color', 'facet_row', 'facet_col') default_dim_name = { 'x': 'sepal_width', 'color': 'species', } @implements(AppInterface) # noqa: H601 class TabGapminder(TabBase): \u201c\u201d\u201cTabGapminder properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 name = 'Gapminder Data' data = px.data.gapminder() func_map = OrderedDict([ ('area', px.area), ('line', px.line), ]) dims = ('x', 'y', 'color', 'line_group', 'facet_row', 'facet_col') default_dim_name = { 'x': 'year', 'y': 'pop', 'color': 'continent', 'line_group': 'country', } @implements(AppInterface) # noqa: H601 class TabTernary(TabBase): \u201c\u201d\u201cTabTernary properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name = ' Ternary ' data = px . data . election () func_map = OrderedDict ( [ ( ' scatter_ternary ' , px . scatter_ternary ) , ( ' line_ternary ' , px . line_ternary ) , ] ) dims = ( ' a ' , ' b ' , ' c ' , ' color ' , ' hover_name ' ) # size - only for scatter default_dim_name = { ' a ' : ' Joly ' , ' b ' : ' Coderre ' , ' c ' : ' Bergeron ' , ' color ' : ' winner ' , ' hover_name ' : ' district ' , } @implements(AppInterface) # noqa: H601 class TabWind(TabBase): \u201c\u201d\u201cTabWind properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name = 'Wind' data = px.data.wind() func_map = OrderedDict([ ('scatter_polar', px.scatter_polar), ('line_polar', px.line_polar), # (line_close=True) ('bar_polar', px.bar_polar), ]) dims = ('r', 'theta', 'color') default_dim_name = { 'r': 'frequency', 'theta': 'direction', 'color': 'strength', 'symbol': 'strength', } @implements(AppInterface) # noqa: H601 class TabColor(TabBase): \u201c\u201d\u201cTabColor properties.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 name = 'Color Swatches' takes_args = False func_map = OrderedDict([ ('colors.qualitative', px.colors.qualitative.swatches), ('colors.sequential', px.colors.sequential.swatches), ('colors.diverging', px.colors.diverging.swatches), ('colors.cyclical', px.colors.cyclical.swatches), ('colors.colorbrewer', px.colors.colorbrewer.swatches), ('colors.cmocean', px.colors.cmocean.swatches), ('colors.carto', px.colors.carto.swatches), ]) default_dim_name = { 'x': 'sepal_width', 'y': 'sepal_length', }","title":"&gt;&gt; Demo uses sample data. User could replace with data loaded from a static CSV file, TinyDB, SQLite, etc."},{"location":"modules/dash_charts/app_px/#_2","text":"","title":"======================================================================================================================"},{"location":"modules/dash_charts/app_px/#create-class-for-application-to-control-manage-variable-scopes","text":"class InteractivePXApp(FullScreenAppWithTabs): # noqa: H601 \u201c\u201d\u201cPlotly Express Demo application.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name = 'TabAppDemo' tabs_location = 'right' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '175px' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def define_nav_elements ( self ) : \"\"\"Return list of initialized tabs. Returns: list: each item is an initialized tab (ex `[AppBase(self.app)]` in the order each tab is rendered \"\"\" return [ TabTip ( app = self . app ), TabIris ( app = self . app ), TabGapminder ( app = self . app ), TabTernary ( app = self . app ), TabWind ( app = self . app ), TabColor ( app = self . app ), ] def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . H1 ( 'Dash/Plotly Express Data Exploration Demo' , style = { 'padding' : '15px 0 0 15px' }), super (). return_layout (), ]) ```","title":"Create class for application to control manage variable scopes"},{"location":"modules/dash_charts/app_px/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/app_px/#interactivepxapp","text":"class InteractivePXApp ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class InteractivePXApp ( FullScreenAppWithTabs ): # noqa: H601 \"\"\"Plotly Express Demo application.\"\"\" name = 'TabAppDemo' tabs_location = 'right' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '175px' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def define_nav_elements ( self ): \"\"\"Return list of initialized tabs. Returns: list: each item is an initialized tab (ex `[AppBase(self.app)]` in the order each tab is rendered \"\"\" return [ TabTip ( app = self . app ), TabIris ( app = self . app ), TabGapminder ( app = self . app ), TabTernary ( app = self . app ), TabWind ( app = self . app ), TabColor ( app = self . app ), ] def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . H1 ( 'Dash/Plotly Express Data Exploration Demo' , style = { 'padding' : '15px 0 0 15px' }), super () . return_layout (), ])","title":"InteractivePXApp"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro","text":"dash_charts.utils_app_with_navigation.FullScreenAppWithTabs dash_charts.utils_app_with_navigation.AppWithTabs dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables","text":"app app_ids external_stylesheets id_tabs_content id_tabs_select init_app_kwargs modules name nav_layouts nav_lookup nsi tabs_compact Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True. tabs_location Tab orientation setting. One of (left, top, bottom, right) . tabs_margin Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs. validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create","text":"def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs )","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks","text":"def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]]","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements","text":"def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/app_px/#define_nav_elements","text":"def define_nav_elements ( self ) Return list of initialized tabs. Returns: Type Description list each item is an initialized tab (ex [AppBase(self.app)] in the order each tab is rendered View Source def define_nav_elements ( self ): \"\"\"Return list of initialized tabs. Returns: list: each item is an initialized tab (ex `[AppBase(self.app)]` in the order each tab is rendered \"\"\" return [ TabTip ( app = self . app ), TabIris ( app = self . app ), TabGapminder ( app = self . app ), TabTernary ( app = self . app ), TabWind ( app = self . app ), TabColor ( app = self . app ), ]","title":"define_nav_elements"},{"location":"modules/dash_charts/app_px/#generate_data","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#generate_tab_kwargs","text":"def generate_tab_kwargs ( self ) Create the tab keyword arguments. Intended to be modified through inheritance. Returns: Type Description tuple keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys (style, selected_style) for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element View Source def generate_tab_kwargs ( self ): \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys `(style, selected_style)` for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact : tab_style = { 'padding' : '2px 4px 2px 4px' } tabs_padding = '6px 0 0 2px' else : tab_style = { 'padding' : '10px 20px 10px 20px' } tabs_padding = '15px 0 0 5px' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = { 'top' : 'bottom' , 'bottom' : 'top' , 'left' : 'right' , 'right' : 'left' } tabs_style = { # noqa: ECE001 'backgroundColor' : '#F9F9F9' , 'padding' : tabs_padding , 'position' : 'fixed' , 'zIndex' : '999' , f 'border { opposite_lookup [ self . tabs_location ] . title () } ' : '1px solid #d6d6d6' , self . tabs_location : '0' , } if self . tabs_location in [ 'left' , 'right' ]: # Configure for vertical case selected_style [ 'border-left' ] = '3px solid #119DFF' tabs_kwargs = { 'vertical' : True , 'style' : { 'width' : '100%' }, 'parent_style' : { 'width' : '100%' }, } tabs_style [ 'top' ] = '0' tabs_style [ 'bottom' ] = '0' tabs_style [ 'width' ] = 'auto' else : # Configure for horizontal case selected_style [ 'border-top' ] = '3px solid #119DFF' tabs_kwargs = {} tabs_style [ 'height' ] = 'auto' tabs_style [ 'right' ] = '0' tabs_style [ 'left' ] = '0' tab_kwargs = { 'style' : tab_style , 'selected_style' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style )","title":"generate_tab_kwargs"},{"location":"modules/dash_charts/app_px/#get_server","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#return_layout","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ([ html . H1 ( 'Dash/Plotly Express Data Exploration Demo' , style = { 'padding' : '15px 0 0 15px' }), super () . return_layout (), ])","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#tab_menu","text":"def tab_menu ( self ) Return the HTML elements for the tab menu. Returns: Type Description dict Dash HTML object View Source def tab_menu ( self ): \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , )","title":"tab_menu"},{"location":"modules/dash_charts/app_px/#verify_app_initialization","text":"def verify_app_initialization ( self ) Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ): \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" super () . verify_app_initialization () allowed_locations = ( 'left' , 'top' , 'bottom' , 'right' ) if self . tabs_location not in allowed_locations : # pragma: no cover raise RuntimeError ( f '`self.tabs_location = { self . tabs_location } ` is not in { allowed_locations } ' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#tabbase","text":"class TabBase ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabBase ( AppBase ): \"\"\"Base tab class with helper methods.\"\"\" external_stylesheets = [ dbc . themes . FLATLY ] # ID Elements for UI id_chart : str = 'chart' id_func : str = 'func' id_template : str = 'template' # PLANNED: template should be able to be None takes_args : bool = True \"\"\"If True, will pass arguments from UI to function.\"\"\" templates : list = [ 'ggplot2' , 'seaborn' , 'simple_white' , 'plotly' , 'plotly_white' , 'plotly_dark' , 'presentation' , 'xgridoff' , 'ygridoff' , 'gridon' , 'none' , ] \"\"\"List of templates from: `import plotly.io as pio; pio.templates`\"\"\" # Must override in child class name : str = None \"\"\"Unique tab component name. Must be overridden in child class.\"\"\" data : pd . DataFrame = None \"\"\"Dataframe. Must be overridden in child class.\"\"\" func_map : OrderedDict = None \"\"\"Map of functions to keywords. Must be overridden in child class.\"\"\" # PLANNED: below items should be able to be None dims : tuple = () \"\"\"Keyword from function for dropdowns with column names as options. Must be overridden in child class.\"\"\" dims_dict : OrderedDict = OrderedDict ([]) \"\"\"OrderedDict of keyword from function to allowed values. Must be overridden in child class.\"\"\" default_dim_name = {} \"\"\"Lookup for dim:column name to use as default in dropdown.\"\"\" def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates ) def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ... def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, ) def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart () def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"TabBase"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_1","text":"dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#descendants","text":"dash_charts.app_px.TabTip dash_charts.app_px.TabIris dash_charts.app_px.TabGapminder dash_charts.app_px.TabTernary dash_charts.app_px.TabWind dash_charts.app_px.TabColor","title":"Descendants"},{"location":"modules/dash_charts/app_px/#class-variables_1","text":"data default_dim_name Lookup for dim:column name to use as default in dropdown. dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_1","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_1","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_1","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_1","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_1","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_1","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_1","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_1","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_1","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_1","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_1","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_1","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/app_px/#tabcolor","text":"class TabColor ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabColor ( TabBase ): \"\"\"TabColor properties.\"\"\" name = 'Color Swatches' takes_args = False func_map = OrderedDict ([ ( 'colors.qualitative' , px . colors . qualitative . swatches ), ( 'colors.sequential' , px . colors . sequential . swatches ), ( 'colors.diverging' , px . colors . diverging . swatches ), ( 'colors.cyclical' , px . colors . cyclical . swatches ), ( 'colors.colorbrewer' , px . colors . colorbrewer . swatches ), ( 'colors.cmocean' , px . colors . cmocean . swatches ), ( 'colors.carto' , px . colors . carto . swatches ), ]) default_dim_name = { 'x' : 'sepal_width' , 'y' : 'sepal_length' , }","title":"TabColor"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_2","text":"dash_charts.app_px.TabBase dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables_2","text":"data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_2","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_2","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_2","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_2","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_2","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_2","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_2","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_2","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_2","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_2","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart_1","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_2","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_2","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_2","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks_1","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout_1","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/app_px/#tabgapminder","text":"class TabGapminder ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabGapminder ( TabBase ): \"\"\"TabGapminder properties.\"\"\" name = 'Gapminder Data' data = px . data . gapminder () func_map = OrderedDict ([ ( 'area' , px . area ), ( 'line' , px . line ), ]) dims = ( 'x' , 'y' , 'color' , 'line_group' , 'facet_row' , 'facet_col' ) default_dim_name = { 'x' : 'year' , 'y' : 'pop' , 'color' : 'continent' , 'line_group' : 'country' , }","title":"TabGapminder"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_3","text":"dash_charts.app_px.TabBase dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables_3","text":"data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_3","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_3","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_3","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_3","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_3","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_3","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_3","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_3","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_3","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_3","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart_2","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_3","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_3","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_3","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks_2","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout_2","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/app_px/#tabiris","text":"class TabIris ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabIris ( TabBase ): \"\"\"TabIris properties.\"\"\" name = 'Iris Data' data = px . data . iris () func_map = OrderedDict ([ ( 'histogram' , px . histogram ), ( 'bar' , px . bar ), ( 'strip' , px . strip ), ( 'box' , px . box ), ( 'violin' , px . violin ), ]) dims = ( 'x' , 'y' , 'color' , 'facet_row' , 'facet_col' ) default_dim_name = { 'x' : 'sepal_width' , 'color' : 'species' , }","title":"TabIris"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_4","text":"dash_charts.app_px.TabBase dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables_4","text":"data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_4","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_4","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_4","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_4","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_4","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_4","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_4","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_4","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_4","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_4","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart_3","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_4","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_4","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_4","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks_3","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout_3","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/app_px/#tabternary","text":"class TabTernary ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabTernary ( TabBase ): \"\"\"TabTernary properties.\"\"\" name = 'Ternary' data = px . data . election () func_map = OrderedDict ([ ( 'scatter_ternary' , px . scatter_ternary ), ( 'line_ternary' , px . line_ternary ), ]) dims = ( 'a' , 'b' , 'c' , 'color' , 'hover_name' ) # size - only for scatter default_dim_name = { 'a' : 'Joly' , 'b' : 'Coderre' , 'c' : 'Bergeron' , 'color' : 'winner' , 'hover_name' : 'district' , }","title":"TabTernary"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_5","text":"dash_charts.app_px.TabBase dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables_5","text":"data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_5","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_5","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_5","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_5","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_5","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_5","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_5","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_5","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_5","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_5","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart_4","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_5","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_5","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_5","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks_4","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout_4","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/app_px/#tabtip","text":"class TabTip ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabTip ( TabBase ): \"\"\"TabTip properties.\"\"\" name = 'Tip Data' data = px . data . tips () func_map = OrderedDict ([ ( 'scatter' , px . scatter ), ( 'density_contour' , px . density_contour ), ]) dims = ( 'x' , 'y' , 'color' , 'facet_row' , 'facet_col' ) dims_dict = OrderedDict ([ ( 'marginal_x' , ( 'histogram' , 'rag' , 'violin' , 'box' )), ( 'marginal_y' , ( 'histogram' , 'rag' , 'violin' , 'box' )), ( 'trendline' , ( 'ols' , 'lowess' )), ]) default_dim_name = { 'x' : 'total_bill' , 'y' : 'tip' , 'color' : 'smoker' , }","title":"TabTip"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_6","text":"dash_charts.app_px.TabBase dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables_6","text":"data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_6","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_6","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_6","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_6","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_6","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_6","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_6","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_6","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_6","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_6","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart_5","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_6","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_6","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_6","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks_5","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout_5","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/app_px/#tabwind","text":"class TabWind ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class TabWind ( TabBase ): \"\"\"TabWind properties.\"\"\" name = 'Wind' data = px . data . wind () func_map = OrderedDict ([ ( 'scatter_polar' , px . scatter_polar ), ( 'line_polar' , px . line_polar ), # (line_close=True) ( 'bar_polar' , px . bar_polar ), ]) dims = ( 'r' , 'theta' , 'color' ) default_dim_name = { 'r' : 'frequency' , 'theta' : 'direction' , 'color' : 'strength' , 'symbol' : 'strength' , }","title":"TabWind"},{"location":"modules/dash_charts/app_px/#ancestors-in-mro_7","text":"dash_charts.app_px.TabBase dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/app_px/#class-variables_7","text":"data default_dim_name dims dims_dict external_stylesheets func_map id_chart id_func id_template init_app_kwargs modules name nsi takes_args templates validation_layout","title":"Class variables"},{"location":"modules/dash_charts/app_px/#methods_7","text":"","title":"Methods"},{"location":"modules/dash_charts/app_px/#callback_7","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/app_px/#create_7","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/app_px/#create_callbacks_7","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" self . verify_types_for_callbacks () self . register_update_chart ()","title":"create_callbacks"},{"location":"modules/dash_charts/app_px/#create_elements_7","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements.\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/app_px/#generate_data_7","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/app_px/#get_server_7","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/app_px/#initialization_7","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () # Register the the unique element IDs self . input_ids = [ self . id_func , self . id_template ] + [ * self . dims ] + [ * self . dims_dict . keys ()] self . register_uniq_ids ([ self . id_chart ] + self . input_ids ) # Configure the options for the various dropdowns self . col_opts = [] if self . data is None else tuple ( opts_dd ( _c , _c ) for _c in self . data . columns ) self . func_opts = tuple ( opts_dd ( lbl , lbl ) for lbl in self . func_map . keys ()) self . t_opts = tuple ( opts_dd ( template , template ) for template in self . templates )","title":"initialization"},{"location":"modules/dash_charts/app_px/#override_module_defaults_7","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/app_px/#register_uniq_ids_7","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/app_px/#register_update_chart_6","text":"def register_update_chart ( self ) Register the update_chart callback. View Source def register_update_chart ( self ): # noqa: CCR001 \"\"\"Register the update_chart callback.\"\"\" outputs = [( self . id_chart , 'figure' )] inputs = [( _id , 'value' ) for _id in self . input_ids ] states = () @self . callback ( outputs , inputs , states ) def update_chart ( * raw_args ): a_in , _a_states = map_args ( raw_args , inputs , states ) name_func = a_in [ self . id_func ][ 'value' ] properties = [ trigger [ 'prop_id' ] for trigger in dash . callback_context . triggered ] new_chart = {} # If event is not a tab change, return the updated chart if 'tabs-select.value' not in properties : # FIXME: replace tabs-select with actual keyname (?) if self . takes_args : # Parse the arguments to generate a new plot kwargs = { key : a_in [ key ][ 'value' ] for key in self . input_ids [ 1 :]} new_chart = self . func_map [ name_func ]( self . data , height = 650 , ** kwargs ) else : new_chart = self . func_map [ name_func ]() # Example Mapping Output. Alternatively, just: `return [new_chart]` return map_outputs ( outputs , [( self . id_chart , 'figure' , new_chart )])","title":"register_update_chart"},{"location":"modules/dash_charts/app_px/#return_layout_7","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" self . verify_types_for_layout () return html . Div ( [ # noqa: ECE001 html . Div ( [ dropdown_group ( 'Plot Type:' , self . _il [ self . id_func ], self . func_opts , value = self . func_opts [ 0 ][ 'label' ], ), dropdown_group ( 'Template:' , self . _il [ self . id_template ], self . t_opts , value = self . t_opts [ 0 ][ 'label' ], ), ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], self . col_opts , value = self . default_dim_name . get ( dim , None ), ) for dim in self . dims ] + [ dropdown_group ( f ' { dim } :' , self . _il [ dim ], [ opts_dd ( item , item ) for item in items ]) for dim , items in self . dims_dict . items () ], style = { 'width' : '25%' , 'float' : 'left' }, ), min_graph ( id = self . _il [ self . id_chart ], style = { 'width' : '75%' , 'display' : 'inline-block' }), ], style = { 'padding' : '15px' }, )","title":"return_layout"},{"location":"modules/dash_charts/app_px/#run_7","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/app_px/#verify_app_initialization_7","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/app_px/#verify_types_for_callbacks_6","text":"def verify_types_for_callbacks ( self ) Verify data types of data members necessary for the callbacks of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_callbacks ( self ): \"\"\"Verify data types of data members necessary for the callbacks of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . takes_args , bool ): errors . append ( f 'Expected self.takes_args=\" { self . takes_args } \" to be bool' ) if not ( isinstance ( self . data , pd . DataFrame ) or self . data is None ): errors . append ( f 'Expected self.data=\" { self . data } \" to be pd.DataFrame or None' ) if not isinstance ( self . func_map , OrderedDict ): errors . append ( f 'Expected self.func_map=\" { self . func_map } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_callbacks"},{"location":"modules/dash_charts/app_px/#verify_types_for_layout_6","text":"def verify_types_for_layout ( self ) Verify data types of data members necessary for the layout of this tab. Raises: Type Description RuntimeError if any relevant data members are of the wrong type View Source def verify_types_for_layout ( self ): \"\"\"Verify data types of data members necessary for the layout of this tab. Raises: RuntimeError: if any relevant data members are of the wrong type \"\"\" errors = [] if not isinstance ( self . name , str ): errors . append ( f 'Expected self.name=\" { self . name } \" to be str' ) if not isinstance ( self . dims , tuple ): errors . append ( f 'Expected self.dims=\" { self . dims } \" to be tuple' ) if not isinstance ( self . dims_dict , OrderedDict ): errors . append ( f 'Expected self.dims_dict=\" { self . dims_dict } \" to be OrderedDict' ) if errors : formatted_errors = ' \\n ' + ' \\n ' . join ( errors ) raise RuntimeError ( f 'Found errors in data members: { formatted_errors } ' )","title":"verify_types_for_layout"},{"location":"modules/dash_charts/components/","text":"dash_charts.components \u2693\ufe0e Application components built on Dash Bootstrap Components. View Source \"\"\"Application components built on Dash Bootstrap Components.\"\"\" import dash_bootstrap_components as dbc from dash import dcc def opts_dd ( lbl , value ): \"\"\"Format an individual item in a Dash dcc dropdown list. Args: lbl: Dropdown label value: Dropdown value Returns: dict: keys `label` and `value` for dcc.dropdown() \"\"\" return { 'label' : str ( lbl ), 'value' : value } def dropdown_group ( name , _id , options , form_style = None , ** dropdown_kwargs ): \"\"\"Return a Form Group with label and dropdown. Dropdown documentation: https://dash.plot.ly/dash-core-components/dropdown Args: name: label name of dropdown _id: element id options: list of dicts with keys `(value, label)` form_style: style keyword argument for dbc.FormGroup(). Default is None dropdown_kwargs: key word arguments for dropdown. Could be: `(persistence, multi, searchable, etc.)` Returns: Row: dbc row with label and dropdown \"\"\" if form_style is None : form_style = {} return dbc . Row ( [ dbc . Label ( name ), dcc . Dropdown ( id = _id , options = options , ** dropdown_kwargs ), ], style = form_style , ) def format_email_pass_id ( submit_id ): \"\"\"Return tuple of the formatted email and password IDs based on the base submit_id value. Args: submit_id: id used to create unique element IDs Returns: tuple: formatted IDs: `(email_id, pass_id)` \"\"\" return [ f ' { submit_id } - { key } ' for key in [ 'email' , 'password' ]] def login_form ( submit_id ): \"\"\"Return dbcForm with email and password inputs and submit button. Based on: https://dash-bootstrap-components.opensource.faculty.ai/docs/components/form/ Args: submit_id: id used to create unique element IDs Returns: form: dbc.Form with email and password inputs and submit button \"\"\" email_id , pass_id = format_email_pass_id ( submit_id ) return dbc . Form ( dbc . Row ( [ dbc . Label ( 'Email' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'email' , placeholder = 'Enter email' , id = email_id ), className = 'me-3' , ), dbc . Label ( 'Password' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'password' , placeholder = 'Enter password' , id = pass_id ), className = 'me-3' , ), dbc . Col ( dbc . Button ( 'Submit' , color = 'primary' , id = submit_id ), width = 'auto' ), ], className = 'g-2' , ), ) Functions \u2693\ufe0e dropdown_group \u2693\ufe0e def dropdown_group ( name , _id , options , form_style = None , ** dropdown_kwargs ) Return a Form Group with label and dropdown. Dropdown documentation: https://dash.plot.ly/dash-core-components/dropdown Parameters: Name Description name label name of dropdown _id element id options list of dicts with keys (value, label) form_style style keyword argument for dbc.FormGroup(). Default is None dropdown_kwargs key word arguments for dropdown. Could be: (persistence, multi, searchable, etc.) Returns: Type Description Row dbc row with label and dropdown View Source def dropdown_group ( name , _id , options , form_style = None , ** dropdown_kwargs ): \"\"\"Return a Form Group with label and dropdown. Dropdown documentation: https://dash.plot.ly/dash-core-components/dropdown Args: name: label name of dropdown _id: element id options: list of dicts with keys `(value, label)` form_style: style keyword argument for dbc.FormGroup(). Default is None dropdown_kwargs: key word arguments for dropdown. Could be: `(persistence, multi, searchable, etc.)` Returns: Row: dbc row with label and dropdown \"\"\" if form_style is None : form_style = {} return dbc . Row ( [ dbc . Label ( name ), dcc . Dropdown ( id = _id , options = options , ** dropdown_kwargs ), ], style = form_style , ) format_email_pass_id \u2693\ufe0e def format_email_pass_id ( submit_id ) Return tuple of the formatted email and password IDs based on the base submit_id value. Parameters: Name Description submit_id id used to create unique element IDs Returns: Type Description tuple formatted IDs: (email_id, pass_id) View Source def format_email_pass_id ( submit_id ): \"\"\"Return tuple of the formatted email and password IDs based on the base submit_id value. Args: submit_id: id used to create unique element IDs Returns: tuple: formatted IDs: `(email_id, pass_id)` \"\"\" return [ f ' { submit_id } - { key } ' for key in [ 'email' , 'password' ]] login_form \u2693\ufe0e def login_form ( submit_id ) Return dbcForm with email and password inputs and submit button. Based on: https://dash-bootstrap-components.opensource.faculty.ai/docs/components/form/ Parameters: Name Description submit_id id used to create unique element IDs Returns: Type Description form dbc.Form with email and password inputs and submit button View Source def login_form ( submit_id ): \"\"\"Return dbcForm with email and password inputs and submit button. Based on: https://dash-bootstrap-components.opensource.faculty.ai/docs/components/form/ Args: submit_id: id used to create unique element IDs Returns: form: dbc.Form with email and password inputs and submit button \"\"\" email_id , pass_id = format_email_pass_id ( submit_id ) return dbc . Form ( dbc . Row ( [ dbc . Label ( 'Email' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'email' , placeholder = 'Enter email' , id = email_id ), className = 'me-3' , ), dbc . Label ( 'Password' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'password' , placeholder = 'Enter password' , id = pass_id ), className = 'me-3' , ), dbc . Col ( dbc . Button ( 'Submit' , color = 'primary' , id = submit_id ), width = 'auto' ), ], className = 'g-2' , ), ) opts_dd \u2693\ufe0e def opts_dd ( lbl , value ) Format an individual item in a Dash dcc dropdown list. Parameters: Name Description lbl Dropdown label value Dropdown value Returns: Type Description dict keys label and value for dcc.dropdown() View Source def opts_dd ( lbl , value ): \"\"\"Format an individual item in a Dash dcc dropdown list. Args: lbl: Dropdown label value: Dropdown value Returns: dict: keys `label` and `value` for dcc.dropdown() \"\"\" return { 'label' : str ( lbl ), 'value' : value }","title":"dash_charts.components"},{"location":"modules/dash_charts/components/#dash_chartscomponents","text":"Application components built on Dash Bootstrap Components. View Source \"\"\"Application components built on Dash Bootstrap Components.\"\"\" import dash_bootstrap_components as dbc from dash import dcc def opts_dd ( lbl , value ): \"\"\"Format an individual item in a Dash dcc dropdown list. Args: lbl: Dropdown label value: Dropdown value Returns: dict: keys `label` and `value` for dcc.dropdown() \"\"\" return { 'label' : str ( lbl ), 'value' : value } def dropdown_group ( name , _id , options , form_style = None , ** dropdown_kwargs ): \"\"\"Return a Form Group with label and dropdown. Dropdown documentation: https://dash.plot.ly/dash-core-components/dropdown Args: name: label name of dropdown _id: element id options: list of dicts with keys `(value, label)` form_style: style keyword argument for dbc.FormGroup(). Default is None dropdown_kwargs: key word arguments for dropdown. Could be: `(persistence, multi, searchable, etc.)` Returns: Row: dbc row with label and dropdown \"\"\" if form_style is None : form_style = {} return dbc . Row ( [ dbc . Label ( name ), dcc . Dropdown ( id = _id , options = options , ** dropdown_kwargs ), ], style = form_style , ) def format_email_pass_id ( submit_id ): \"\"\"Return tuple of the formatted email and password IDs based on the base submit_id value. Args: submit_id: id used to create unique element IDs Returns: tuple: formatted IDs: `(email_id, pass_id)` \"\"\" return [ f ' { submit_id } - { key } ' for key in [ 'email' , 'password' ]] def login_form ( submit_id ): \"\"\"Return dbcForm with email and password inputs and submit button. Based on: https://dash-bootstrap-components.opensource.faculty.ai/docs/components/form/ Args: submit_id: id used to create unique element IDs Returns: form: dbc.Form with email and password inputs and submit button \"\"\" email_id , pass_id = format_email_pass_id ( submit_id ) return dbc . Form ( dbc . Row ( [ dbc . Label ( 'Email' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'email' , placeholder = 'Enter email' , id = email_id ), className = 'me-3' , ), dbc . Label ( 'Password' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'password' , placeholder = 'Enter password' , id = pass_id ), className = 'me-3' , ), dbc . Col ( dbc . Button ( 'Submit' , color = 'primary' , id = submit_id ), width = 'auto' ), ], className = 'g-2' , ), )","title":"dash_charts.components"},{"location":"modules/dash_charts/components/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/components/#dropdown_group","text":"def dropdown_group ( name , _id , options , form_style = None , ** dropdown_kwargs ) Return a Form Group with label and dropdown. Dropdown documentation: https://dash.plot.ly/dash-core-components/dropdown Parameters: Name Description name label name of dropdown _id element id options list of dicts with keys (value, label) form_style style keyword argument for dbc.FormGroup(). Default is None dropdown_kwargs key word arguments for dropdown. Could be: (persistence, multi, searchable, etc.) Returns: Type Description Row dbc row with label and dropdown View Source def dropdown_group ( name , _id , options , form_style = None , ** dropdown_kwargs ): \"\"\"Return a Form Group with label and dropdown. Dropdown documentation: https://dash.plot.ly/dash-core-components/dropdown Args: name: label name of dropdown _id: element id options: list of dicts with keys `(value, label)` form_style: style keyword argument for dbc.FormGroup(). Default is None dropdown_kwargs: key word arguments for dropdown. Could be: `(persistence, multi, searchable, etc.)` Returns: Row: dbc row with label and dropdown \"\"\" if form_style is None : form_style = {} return dbc . Row ( [ dbc . Label ( name ), dcc . Dropdown ( id = _id , options = options , ** dropdown_kwargs ), ], style = form_style , )","title":"dropdown_group"},{"location":"modules/dash_charts/components/#format_email_pass_id","text":"def format_email_pass_id ( submit_id ) Return tuple of the formatted email and password IDs based on the base submit_id value. Parameters: Name Description submit_id id used to create unique element IDs Returns: Type Description tuple formatted IDs: (email_id, pass_id) View Source def format_email_pass_id ( submit_id ): \"\"\"Return tuple of the formatted email and password IDs based on the base submit_id value. Args: submit_id: id used to create unique element IDs Returns: tuple: formatted IDs: `(email_id, pass_id)` \"\"\" return [ f ' { submit_id } - { key } ' for key in [ 'email' , 'password' ]]","title":"format_email_pass_id"},{"location":"modules/dash_charts/components/#login_form","text":"def login_form ( submit_id ) Return dbcForm with email and password inputs and submit button. Based on: https://dash-bootstrap-components.opensource.faculty.ai/docs/components/form/ Parameters: Name Description submit_id id used to create unique element IDs Returns: Type Description form dbc.Form with email and password inputs and submit button View Source def login_form ( submit_id ): \"\"\"Return dbcForm with email and password inputs and submit button. Based on: https://dash-bootstrap-components.opensource.faculty.ai/docs/components/form/ Args: submit_id: id used to create unique element IDs Returns: form: dbc.Form with email and password inputs and submit button \"\"\" email_id , pass_id = format_email_pass_id ( submit_id ) return dbc . Form ( dbc . Row ( [ dbc . Label ( 'Email' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'email' , placeholder = 'Enter email' , id = email_id ), className = 'me-3' , ), dbc . Label ( 'Password' , width = 'auto' ), dbc . Col ( dbc . Input ( type = 'password' , placeholder = 'Enter password' , id = pass_id ), className = 'me-3' , ), dbc . Col ( dbc . Button ( 'Submit' , color = 'primary' , id = submit_id ), width = 'auto' ), ], className = 'g-2' , ), )","title":"login_form"},{"location":"modules/dash_charts/components/#opts_dd","text":"def opts_dd ( lbl , value ) Format an individual item in a Dash dcc dropdown list. Parameters: Name Description lbl Dropdown label value Dropdown value Returns: Type Description dict keys label and value for dcc.dropdown() View Source def opts_dd ( lbl , value ): \"\"\"Format an individual item in a Dash dcc dropdown list. Args: lbl: Dropdown label value: Dropdown value Returns: dict: keys `label` and `value` for dcc.dropdown() \"\"\" return { 'label' : str ( lbl ), 'value' : value }","title":"opts_dd"},{"location":"modules/dash_charts/coordinate_chart/","text":"dash_charts.coordinate_chart \u2693\ufe0e Coordinate chart. Creates a grid of tiles with consistently spaced x/y positions. Provided data is plotted as a marker at each position unless None. This can be used to create all sorts of visualizations that have spatially related data, such as calendars View Source \"\"\"Coordinate chart. Creates a grid of tiles with consistently spaced x/y positions. Provided data is plotted as a marker at each position unless None. This can be used to create all sorts of visualizations that have spatially related data, such as calendars \"\"\" import calendar import cmath import math from itertools import chain import numpy as np import pandas as pd import plotly.graph_objects as go from .utils_fig import CustomChart , check_raw_data # PLANNED: subplots for multiple years of calendar charts (Subplot title is year) def calculate_grid ( grid_dims , corners , width , height ): \"\"\"Calculate the grid x and y coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates width: float width in pixels height: float height in pixels Returns: dict: with keys `(x, y)` with lists of lists containing float values \"\"\" grid = { 'x' : [], 'y' : []} for r_idx in range ( grid_dims [ 0 ]): y_offset = height * ( grid_dims [ 0 ] - r_idx ) y_grid = [ y_offset - _y for _y in corners [ 'y' ]] for c_idx in range ( grid_dims [ 1 ]): x_offset = width * c_idx grid [ 'x' ] . extend ([ x_offset + _x for _x in corners [ 'x' ]]) grid [ 'y' ] . extend ( y_grid ) return grid def calculate_border ( grid_dims , width , height ): \"\"\"Calculate each line in all borders. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` width: float width in pixels height: float height in pixels Returns: list: containing dictionaries keys `(x, y)` and values for the two points for each line in grid \"\"\" return [ { 'x' : [ c_idx * width ] * 2 , 'y' : [ 0 , height * grid_dims [ 0 ]], } for c_idx in range ( grid_dims [ 1 ] + 1 ) ] + [ { 'x' : [ 0 , width * grid_dims [ 1 ]], 'y' : [ r_idx * height ] * 2 , } for r_idx in range ( grid_dims [ 0 ] + 1 ) ] class CoordinateChart ( CustomChart ): # noqa: H601 \"\"\"Coordinate Chart.\"\"\" border_opacity : float = 0.2 \"\"\"Border opacity for grid. Value must be in [0-1] where 0 is none. Default is 0.2.\"\"\" border_line = None \"\"\"Dictionary passed to plotly `line`. Used to set thickness, color, dash style, etc. Default is None.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments used in `create_marker()`. Default is None.\"\"\" # Private states for managing coordinate chart dimensions _grid : dict _borders : list def __init__ ( self , * , title , grid_dims , corners , titles = None , layout_overrides = ()): \"\"\"Initialize Coordinate Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" # Initialize base method. Sets xlabel and ylabel to empty strings because coordinate chart use the x/y # axis for arranging points. Data is displayed by color or size super () . __init__ ( title = title , xlabel = '' , ylabel = '' , layout_overrides = layout_overrides ) # Initialize chart parameters self . calculate_layout ( grid_dims , corners , titles ) def calculate_layout ( self , grid_dims , corners , titles ): \"\"\"Calculate coordinate chart layout. Called by __init__, but can be called later to update the chart. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles \"\"\" # Calculate exterior height and width of grid width = float ( np . max ( corners [ 'x' ]) + np . min ( corners [ 'x' ])) height = float ( np . max ( corners [ 'y' ]) + np . min ( corners [ 'y' ])) # Set grid and border coordinates for traces self . _grid = calculate_grid ( grid_dims , corners , width , height ) self . _borders = calculate_border ( grid_dims , width , height ) # Add titles to annotations if provided if titles is None : self . annotations = [] else : v_offset = np . min ( corners [ 'y' ]) * 0.4 self . annotations = [ go . layout . Annotation ( ax = 0 , ay = 0 , x = ( idx % grid_dims [ 1 ] + 0.5 ) * width , # noqa: S001 y = ( grid_dims [ 0 ] - int ( idx / grid_dims [ 1 ]) % grid_dims [ 0 ]) * height - v_offset , text = title , ) for idx , title in enumerate ( titles ) if title is not None ] def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the column `values: str` Returns: list: Dash chart traces \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'values' ]) # Merge x/y grid data with values. Temporarily extend values with None, then drop those rows values = df_raw [ 'values' ] . to_list () values . extend ([ None ] * ( len ( self . _grid [ 'x' ]) - len ( values ))) df_grid = pd . DataFrame ( data = { 'values' : values , 'x' : self . _grid [ 'x' ], 'y' : self . _grid [ 'y' ], }, ) . dropna () return [ go . Scatter ( hoverinfo = 'none' , line = self . border_line or { 'color' : 'black' }, mode = 'lines' , opacity = self . border_opacity , showlegend = False , x = border [ 'x' ], y = border [ 'y' ], ) for border in self . _borders ] + [ go . Scatter ( hoverinfo = 'text' , mode = 'markers' , showlegend = False , text = df_grid [ 'values' ], x = df_grid [ 'x' ], y = df_grid [ 'y' ], marker = self . create_marker ( df_grid , ** ( self . marker_kwargs or {})), ), ] def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ): \"\"\"Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Args: df_grid: pandas dataframe with at minimum the column `values: str`, `x: float`, `y: float` colorscale: plotly colorscale, see doc link above. Default is 'Viridis' size: integer marker size symbol: marker symbol (square, circle, circle-open, x, etc.) Returns: dict: the chart marker shape, symbol, color, etc. \"\"\" return { 'color' : df_grid [ 'values' ], 'colorscale' : colorscale , 'showscale' : True , 'size' : size , 'symbol' : symbol , } def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () for axis in [ 'xaxis' , 'yaxis' ]: layout [ axis ][ 'showgrid' ] = False layout [ axis ][ 'showticklabels' ] = False layout [ axis ][ 'zeroline' ] = False layout [ 'yaxis' ][ 'scaleanchor' ] = 'x' layout [ 'yaxis' ][ 'scaleratio' ] = 1 return layout # ============================================================================== # Standard Coordinate Grids class GridClass : \"\"\"Base class for specifying a grid for the Coordinate chart.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments. Default is None.\"\"\" def __init__ ( self , grid_dims , titles ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element \"\"\" self . grid_dims = grid_dims self . titles = titles class CircleGrid ( GridClass ): # noqa: H601 \"\"\"Grid of circular coordinates.\"\"\" marker_kwargs = { 'size' : 10 } \"\"\"Marker keyword arguments. Default is `{'size': 10}`\"\"\" def __init__ ( self , grid_dims , titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element. Default is None \"\"\" if titles is None : titles = [] for idx in range ( grid_dims [ 0 ] * grid_dims [ 1 ]): x_coord = int ( idx / grid_dims [ 1 ]) + 1 y_coord = idx % ( grid_dims [ 0 ] + 1 ) + 1 # noqa: S001 titles . append ( f 'Subtitle for ( { x_coord } , { y_coord } )' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners opp = 0.5 * math . cos ( cmath . pi / 4 ) adj = 0.5 * math . sin ( cmath . pi / 4 ) self . corners = { 'x' : [ 0.5 , 1 - adj , 1.0 , 1 + adj , 1.5 , 1 + adj , 1.0 , 1 - adj ], 'y' : [ 1.0 , 1 - opp , 0.5 , 1 - opp , 1.0 , 1 + opp , 1.5 , 1 + opp ], } def calculate_calendar_grid_corners ( margin , days_in_week = 7 , max_weeks_in_month = 6 ): \"\"\"Calculate the four exterior corner coordinates of a calendar coordinate grid. Args: margin: float spacing between tiles days_in_week: number of days in week. Default is 7 max_weeks_in_month: max number of weeks in a month. Default is 6 Returns: list: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates \"\"\" y_indices = [[ idx ] * days_in_week for idx in range ( max_weeks_in_month )] return { 'x' : np . add ([ * range ( days_in_week )] * max_weeks_in_month , margin ), 'y' : np . add ([ * chain . from_iterable ( y_indices )], margin ), } class YearGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a grid of months in one year.\"\"\" marker_kwargs = { 'size' : 10 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 10, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 4 , 3 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (4, 3) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions \"\"\" if grid_dims [ 0 ] * grid_dims [ 1 ] != 12 : # pragma: no cover raise RuntimeError ( 'Calendar must show all 12 months Expected (12,1), (6,2), (4,3), (1,12), etc.' ) if titles is None : titles = calendar . month_name [ 1 :] super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 2 ) def format_data ( self , month_lists , year ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: month_lists: list of daily values where each sublist is one month starting with January year: year expressed in 4 decimal places (i.e. 2019) Returns: list: of values with additional None values to align with grid \"\"\" values = [] for idx_month , daily_list in enumerate ( month_lists ): idx_first_day , count_days = calendar . monthrange ( year , idx_month + 1 ) idx_first_day += 1 # Increment to start on Sunday -- PLANNED: make this configureable values . extend ([ None ] * idx_first_day ) values . extend ( daily_list ) values . extend ([ None ] * ( len ( self . corners [ 'x' ]) - idx_first_day - count_days )) return values class MonthGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a single month.\"\"\" marker_kwargs = { 'size' : 35 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 35, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 1 , 1 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (1, 1) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions or titles \"\"\" if grid_dims != ( 1 , 1 ): # pragma: no cover raise RuntimeError ( 'Day grid can only show one month, expected (1, 1)' ) if titles is not None and len ( titles ) != 1 : # pragma: no cover raise RuntimeError ( f 'Only one title is allowed for the MonthGrid. Received: { titles } ' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 1.25 ) def format_data ( self , daily_values , year , month ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: daily_values: list of values for each day of month year: year expressed in 4 digits (2019, 2020, etc.) month: month index in [1, 12] Returns: list: of values with additional None values to align with grid \"\"\" idx_first_day = calendar . monthrange ( year , month )[ 0 ] values = [ None ] * idx_first_day values . extend ( daily_values ) return values Functions \u2693\ufe0e calculate_border \u2693\ufe0e def calculate_border ( grid_dims , width , height ) Calculate each line in all borders. Parameters: Name Description grid_dims tuple of the number of tiles in grid. In format (row, column) width float width in pixels height float height in pixels Returns: Type Description list containing dictionaries keys (x, y) and values for the two points for each line in grid View Source def calculate_border ( grid_dims , width , height ): \"\"\"Calculate each line in all borders. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` width: float width in pixels height: float height in pixels Returns: list: containing dictionaries keys `(x, y)` and values for the two points for each line in grid \"\"\" return [ { 'x' : [ c_idx * width ] * 2 , 'y' : [ 0 , height * grid_dims [ 0 ]], } for c_idx in range ( grid_dims [ 1 ] + 1 ) ] + [ { 'x' : [ 0 , width * grid_dims [ 1 ]], 'y' : [ r_idx * height ] * 2 , } for r_idx in range ( grid_dims [ 0 ] + 1 ) ] calculate_calendar_grid_corners \u2693\ufe0e def calculate_calendar_grid_corners ( margin , days_in_week = 7 , max_weeks_in_month = 6 ) Calculate the four exterior corner coordinates of a calendar coordinate grid. Parameters: Name Description margin float spacing between tiles days_in_week number of days in week. Default is 7 max_weeks_in_month max number of weeks in a month. Default is 6 Returns: Type Description list dictionary with keys (x, y) containing lists of the four exterior corner coordinates View Source def calculate_calendar_grid_corners ( margin , days_in_week = 7 , max_weeks_in_month = 6 ): \"\"\"Calculate the four exterior corner coordinates of a calendar coordinate grid. Args: margin: float spacing between tiles days_in_week: number of days in week. Default is 7 max_weeks_in_month: max number of weeks in a month. Default is 6 Returns: list: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates \"\"\" y_indices = [[ idx ] * days_in_week for idx in range ( max_weeks_in_month )] return { 'x' : np . add ([ * range ( days_in_week )] * max_weeks_in_month , margin ), 'y' : np . add ([ * chain . from_iterable ( y_indices )], margin ), } calculate_grid \u2693\ufe0e def calculate_grid ( grid_dims , corners , width , height ) Calculate the grid x and y coordinates. Parameters: Name Description grid_dims tuple of the number of tiles in grid. In format (row, column) corners dictionary with keys (x, y) containing lists of the four exterior corner coordinates width float width in pixels height float height in pixels Returns: Type Description dict with keys (x, y) with lists of lists containing float values View Source def calculate_grid ( grid_dims , corners , width , height ): \"\"\"Calculate the grid x and y coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates width: float width in pixels height: float height in pixels Returns: dict: with keys `(x, y)` with lists of lists containing float values \"\"\" grid = { 'x' : [], 'y' : []} for r_idx in range ( grid_dims [ 0 ]): y_offset = height * ( grid_dims [ 0 ] - r_idx ) y_grid = [ y_offset - _y for _y in corners [ 'y' ]] for c_idx in range ( grid_dims [ 1 ]): x_offset = width * c_idx grid [ 'x' ] . extend ([ x_offset + _x for _x in corners [ 'x' ]]) grid [ 'y' ] . extend ( y_grid ) return grid Classes \u2693\ufe0e CircleGrid \u2693\ufe0e class CircleGrid ( grid_dims , titles = None ) View Source class CircleGrid ( GridClass ): # noqa: H601 \"\"\"Grid of circular coordinates.\"\"\" marker_kwargs = { 'size' : 10 } \"\"\"Marker keyword arguments. Default is `{'size': 10}`\"\"\" def __init__ ( self , grid_dims , titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element. Default is None \"\"\" if titles is None : titles = [] for idx in range ( grid_dims [ 0 ] * grid_dims [ 1 ]): x_coord = int ( idx / grid_dims [ 1 ]) + 1 y_coord = idx % ( grid_dims [ 0 ] + 1 ) + 1 # noqa: S001 titles . append ( f 'Subtitle for ( { x_coord } , { y_coord } )' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners opp = 0.5 * math . cos ( cmath . pi / 4 ) adj = 0.5 * math . sin ( cmath . pi / 4 ) self . corners = { 'x' : [ 0.5 , 1 - adj , 1.0 , 1 + adj , 1.5 , 1 + adj , 1.0 , 1 - adj ], 'y' : [ 1.0 , 1 - opp , 0.5 , 1 - opp , 1.0 , 1 + opp , 1.5 , 1 + opp ], } Ancestors (in MRO) \u2693\ufe0e dash_charts.coordinate_chart.GridClass Class variables \u2693\ufe0e marker_kwargs Marker keyword arguments. Default is {'size': 10} CoordinateChart \u2693\ufe0e class CoordinateChart ( * , title , grid_dims , corners , titles = None , layout_overrides = () ) View Source class CoordinateChart ( CustomChart ): # noqa: H601 \"\"\"Coordinate Chart.\"\"\" border_opacity : float = 0.2 \"\"\"Border opacity for grid. Value must be in [0-1] where 0 is none. Default is 0.2.\"\"\" border_line = None \"\"\"Dictionary passed to plotly `line`. Used to set thickness, color, dash style, etc. Default is None.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments used in `create_marker()`. Default is None.\"\"\" # Private states for managing coordinate chart dimensions _grid : dict _borders : list def __init__ ( self , * , title , grid_dims , corners , titles = None , layout_overrides = ()): \"\"\"Initialize Coordinate Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" # Initialize base method. Sets xlabel and ylabel to empty strings because coordinate chart use the x/y # axis for arranging points. Data is displayed by color or size super () . __init__ ( title = title , xlabel = '' , ylabel = '' , layout_overrides = layout_overrides ) # Initialize chart parameters self . calculate_layout ( grid_dims , corners , titles ) def calculate_layout ( self , grid_dims , corners , titles ): \"\"\"Calculate coordinate chart layout. Called by __init__, but can be called later to update the chart. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles \"\"\" # Calculate exterior height and width of grid width = float ( np . max ( corners [ 'x' ]) + np . min ( corners [ 'x' ])) height = float ( np . max ( corners [ 'y' ]) + np . min ( corners [ 'y' ])) # Set grid and border coordinates for traces self . _grid = calculate_grid ( grid_dims , corners , width , height ) self . _borders = calculate_border ( grid_dims , width , height ) # Add titles to annotations if provided if titles is None : self . annotations = [] else : v_offset = np . min ( corners [ 'y' ]) * 0.4 self . annotations = [ go . layout . Annotation ( ax = 0 , ay = 0 , x = ( idx % grid_dims [ 1 ] + 0.5 ) * width , # noqa: S001 y = ( grid_dims [ 0 ] - int ( idx / grid_dims [ 1 ]) % grid_dims [ 0 ]) * height - v_offset , text = title , ) for idx , title in enumerate ( titles ) if title is not None ] def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the column `values: str` Returns: list: Dash chart traces \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'values' ]) # Merge x/y grid data with values. Temporarily extend values with None, then drop those rows values = df_raw [ 'values' ] . to_list () values . extend ([ None ] * ( len ( self . _grid [ 'x' ]) - len ( values ))) df_grid = pd . DataFrame ( data = { 'values' : values , 'x' : self . _grid [ 'x' ], 'y' : self . _grid [ 'y' ], }, ) . dropna () return [ go . Scatter ( hoverinfo = 'none' , line = self . border_line or { 'color' : 'black' }, mode = 'lines' , opacity = self . border_opacity , showlegend = False , x = border [ 'x' ], y = border [ 'y' ], ) for border in self . _borders ] + [ go . Scatter ( hoverinfo = 'text' , mode = 'markers' , showlegend = False , text = df_grid [ 'values' ], x = df_grid [ 'x' ], y = df_grid [ 'y' ], marker = self . create_marker ( df_grid , ** ( self . marker_kwargs or {})), ), ] def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ): \"\"\"Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Args: df_grid: pandas dataframe with at minimum the column `values: str`, `x: float`, `y: float` colorscale: plotly colorscale, see doc link above. Default is 'Viridis' size: integer marker size symbol: marker symbol (square, circle, circle-open, x, etc.) Returns: dict: the chart marker shape, symbol, color, etc. \"\"\" return { 'color' : df_grid [ 'values' ], 'colorscale' : colorscale , 'showscale' : True , 'size' : size , 'symbol' : symbol , } def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () for axis in [ 'xaxis' , 'yaxis' ]: layout [ axis ][ 'showgrid' ] = False layout [ axis ][ 'showticklabels' ] = False layout [ axis ][ 'zeroline' ] = False layout [ 'yaxis' ][ 'scaleanchor' ] = 'x' layout [ 'yaxis' ][ 'scaleratio' ] = 1 return layout Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations border_line Dictionary passed to plotly line . Used to set thickness, color, dash style, etc. Default is None. border_opacity marker_kwargs Marker keyword arguments used in create_marker() . Default is None. Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout calculate_layout \u2693\ufe0e def calculate_layout ( self , grid_dims , corners , titles ) Calculate coordinate chart layout. Called by init , but can be called later to update the chart. Parameters: Name Description grid_dims tuple of the number of tiles in grid. In format (row, column) corners dictionary with keys (x, y) containing lists of the four corner coordinates titles list of strings that will appear in each tile. Default is None for no titles View Source def calculate_layout ( self , grid_dims , corners , titles ): \"\"\"Calculate coordinate chart layout. Called by __init__, but can be called later to update the chart. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles \"\"\" # Calculate exterior height and width of grid width = float ( np . max ( corners [ 'x' ]) + np . min ( corners [ 'x' ])) height = float ( np . max ( corners [ 'y' ]) + np . min ( corners [ 'y' ])) # Set grid and border coordinates for traces self . _grid = calculate_grid ( grid_dims , corners , width , height ) self . _borders = calculate_border ( grid_dims , width , height ) # Add titles to annotations if provided if titles is None : self . annotations = [] else : v_offset = np . min ( corners [ 'y' ]) * 0.4 self . annotations = [ go . layout . Annotation ( ax = 0 , ay = 0 , x = ( idx % grid_dims [ 1 ] + 0.5 ) * width , # noqa: S001 y = ( grid_dims [ 0 ] - int ( idx / grid_dims [ 1 ]) % grid_dims [ 0 ]) * height - v_offset , text = title , ) for idx , title in enumerate ( titles ) if title is not None ] create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () for axis in [ 'xaxis' , 'yaxis' ]: layout [ axis ][ 'showgrid' ] = False layout [ axis ][ 'showticklabels' ] = False layout [ axis ][ 'zeroline' ] = False layout [ 'yaxis' ][ 'scaleanchor' ] = 'x' layout [ 'yaxis' ][ 'scaleratio' ] = 1 return layout create_marker \u2693\ufe0e def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ) Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Parameters: Name Description df_grid pandas dataframe with at minimum the column values: str , x: float , y: float colorscale plotly colorscale, see doc link above. Default is \u2018Viridis\u2019 size integer marker size symbol marker symbol (square, circle, circle-open, x, etc.) Returns: Type Description dict the chart marker shape, symbol, color, etc. View Source def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ): \"\"\"Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Args: df_grid: pandas dataframe with at minimum the column `values: str`, `x: float`, `y: float` colorscale: plotly colorscale, see doc link above. Default is 'Viridis' size: integer marker size symbol: marker symbol (square, circle, circle-open, x, etc.) Returns: dict: the chart marker shape, symbol, color, etc. \"\"\" return { 'color' : df_grid [ 'values' ], 'colorscale' : colorscale , 'showscale' : True , 'size' : size , 'symbol' : symbol , } create_traces \u2693\ufe0e def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with at minimum the column values: str Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the column `values: str` Returns: list: Dash chart traces \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'values' ]) # Merge x/y grid data with values. Temporarily extend values with None, then drop those rows values = df_raw [ 'values' ] . to_list () values . extend ([ None ] * ( len ( self . _grid [ 'x' ]) - len ( values ))) df_grid = pd . DataFrame ( data = { 'values' : values , 'x' : self . _grid [ 'x' ], 'y' : self . _grid [ 'y' ], }, ) . dropna () return [ go . Scatter ( hoverinfo = 'none' , line = self . border_line or { 'color' : 'black' }, mode = 'lines' , opacity = self . border_opacity , showlegend = False , x = border [ 'x' ], y = border [ 'y' ], ) for border in self . _borders ] + [ go . Scatter ( hoverinfo = 'text' , mode = 'markers' , showlegend = False , text = df_grid [ 'values' ], x = df_grid [ 'x' ], y = df_grid [ 'y' ], marker = self . create_marker ( df_grid , ** ( self . marker_kwargs or {})), ), ] initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... GridClass \u2693\ufe0e class GridClass ( grid_dims , titles ) View Source class GridClass : \"\"\"Base class for specifying a grid for the Coordinate chart.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments. Default is None.\"\"\" def __init__ ( self , grid_dims , titles ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element \"\"\" self . grid_dims = grid_dims self . titles = titles Descendants \u2693\ufe0e dash_charts.coordinate_chart.CircleGrid dash_charts.coordinate_chart.YearGrid dash_charts.coordinate_chart.MonthGrid Class variables \u2693\ufe0e marker_kwargs Marker keyword arguments. Default is None. MonthGrid \u2693\ufe0e class MonthGrid ( grid_dims = ( 1 , 1 ), titles = None ) View Source class MonthGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a single month.\"\"\" marker_kwargs = { 'size' : 35 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 35, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 1 , 1 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (1, 1) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions or titles \"\"\" if grid_dims != ( 1 , 1 ): # pragma: no cover raise RuntimeError ( 'Day grid can only show one month, expected (1, 1)' ) if titles is not None and len ( titles ) != 1 : # pragma: no cover raise RuntimeError ( f 'Only one title is allowed for the MonthGrid. Received: { titles } ' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 1.25 ) def format_data ( self , daily_values , year , month ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: daily_values: list of values for each day of month year: year expressed in 4 digits (2019, 2020, etc.) month: month index in [1, 12] Returns: list: of values with additional None values to align with grid \"\"\" idx_first_day = calendar . monthrange ( year , month )[ 0 ] values = [ None ] * idx_first_day values . extend ( daily_values ) return values Ancestors (in MRO) \u2693\ufe0e dash_charts.coordinate_chart.GridClass Class variables \u2693\ufe0e marker_kwargs Marker keyword arguments. Default is {'size': 35, 'symbol': 'square'} Methods \u2693\ufe0e format_data \u2693\ufe0e def format_data ( self , daily_values , year , month ) Return the formatted list that can be passed to a coordinate chart. Parameters: Name Description daily_values list of values for each day of month year year expressed in 4 digits (2019, 2020, etc.) month month index in [1, 12] Returns: Type Description list of values with additional None values to align with grid View Source def format_data ( self , daily_values , year , month ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: daily_values: list of values for each day of month year: year expressed in 4 digits (2019, 2020, etc.) month: month index in [1, 12] Returns: list: of values with additional None values to align with grid \"\"\" idx_first_day = calendar . monthrange ( year , month )[ 0 ] values = [ None ] * idx_first_day values . extend ( daily_values ) return values YearGrid \u2693\ufe0e class YearGrid ( grid_dims = ( 4 , 3 ), titles = None ) View Source class YearGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a grid of months in one year.\"\"\" marker_kwargs = { 'size' : 10 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 10, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 4 , 3 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (4, 3) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions \"\"\" if grid_dims [ 0 ] * grid_dims [ 1 ] != 12 : # pragma: no cover raise RuntimeError ( 'Calendar must show all 12 months Expected (12,1), (6,2), (4,3), (1,12), etc.' ) if titles is None : titles = calendar . month_name [ 1 :] super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 2 ) def format_data ( self , month_lists , year ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: month_lists: list of daily values where each sublist is one month starting with January year: year expressed in 4 decimal places (i.e. 2019) Returns: list: of values with additional None values to align with grid \"\"\" values = [] for idx_month , daily_list in enumerate ( month_lists ): idx_first_day , count_days = calendar . monthrange ( year , idx_month + 1 ) idx_first_day += 1 # Increment to start on Sunday -- PLANNED: make this configureable values . extend ([ None ] * idx_first_day ) values . extend ( daily_list ) values . extend ([ None ] * ( len ( self . corners [ 'x' ]) - idx_first_day - count_days )) return values Ancestors (in MRO) \u2693\ufe0e dash_charts.coordinate_chart.GridClass Class variables \u2693\ufe0e marker_kwargs Marker keyword arguments. Default is {'size': 10, 'symbol': 'square'} Methods \u2693\ufe0e format_data \u2693\ufe0e def format_data ( self , month_lists , year ) Return the formatted list that can be passed to a coordinate chart. Parameters: Name Description month_lists list of daily values where each sublist is one month starting with January year year expressed in 4 decimal places (i.e. 2019) Returns: Type Description list of values with additional None values to align with grid View Source def format_data ( self , month_lists , year ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: month_lists: list of daily values where each sublist is one month starting with January year: year expressed in 4 decimal places (i.e. 2019) Returns: list: of values with additional None values to align with grid \"\"\" values = [] for idx_month , daily_list in enumerate ( month_lists ): idx_first_day , count_days = calendar . monthrange ( year , idx_month + 1 ) idx_first_day += 1 # Increment to start on Sunday -- PLANNED: make this configureable values . extend ([ None ] * idx_first_day ) values . extend ( daily_list ) values . extend ([ None ] * ( len ( self . corners [ 'x' ]) - idx_first_day - count_days )) return values","title":"dash_charts.coordinate_chart"},{"location":"modules/dash_charts/coordinate_chart/#dash_chartscoordinate_chart","text":"Coordinate chart. Creates a grid of tiles with consistently spaced x/y positions. Provided data is plotted as a marker at each position unless None. This can be used to create all sorts of visualizations that have spatially related data, such as calendars View Source \"\"\"Coordinate chart. Creates a grid of tiles with consistently spaced x/y positions. Provided data is plotted as a marker at each position unless None. This can be used to create all sorts of visualizations that have spatially related data, such as calendars \"\"\" import calendar import cmath import math from itertools import chain import numpy as np import pandas as pd import plotly.graph_objects as go from .utils_fig import CustomChart , check_raw_data # PLANNED: subplots for multiple years of calendar charts (Subplot title is year) def calculate_grid ( grid_dims , corners , width , height ): \"\"\"Calculate the grid x and y coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates width: float width in pixels height: float height in pixels Returns: dict: with keys `(x, y)` with lists of lists containing float values \"\"\" grid = { 'x' : [], 'y' : []} for r_idx in range ( grid_dims [ 0 ]): y_offset = height * ( grid_dims [ 0 ] - r_idx ) y_grid = [ y_offset - _y for _y in corners [ 'y' ]] for c_idx in range ( grid_dims [ 1 ]): x_offset = width * c_idx grid [ 'x' ] . extend ([ x_offset + _x for _x in corners [ 'x' ]]) grid [ 'y' ] . extend ( y_grid ) return grid def calculate_border ( grid_dims , width , height ): \"\"\"Calculate each line in all borders. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` width: float width in pixels height: float height in pixels Returns: list: containing dictionaries keys `(x, y)` and values for the two points for each line in grid \"\"\" return [ { 'x' : [ c_idx * width ] * 2 , 'y' : [ 0 , height * grid_dims [ 0 ]], } for c_idx in range ( grid_dims [ 1 ] + 1 ) ] + [ { 'x' : [ 0 , width * grid_dims [ 1 ]], 'y' : [ r_idx * height ] * 2 , } for r_idx in range ( grid_dims [ 0 ] + 1 ) ] class CoordinateChart ( CustomChart ): # noqa: H601 \"\"\"Coordinate Chart.\"\"\" border_opacity : float = 0.2 \"\"\"Border opacity for grid. Value must be in [0-1] where 0 is none. Default is 0.2.\"\"\" border_line = None \"\"\"Dictionary passed to plotly `line`. Used to set thickness, color, dash style, etc. Default is None.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments used in `create_marker()`. Default is None.\"\"\" # Private states for managing coordinate chart dimensions _grid : dict _borders : list def __init__ ( self , * , title , grid_dims , corners , titles = None , layout_overrides = ()): \"\"\"Initialize Coordinate Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" # Initialize base method. Sets xlabel and ylabel to empty strings because coordinate chart use the x/y # axis for arranging points. Data is displayed by color or size super () . __init__ ( title = title , xlabel = '' , ylabel = '' , layout_overrides = layout_overrides ) # Initialize chart parameters self . calculate_layout ( grid_dims , corners , titles ) def calculate_layout ( self , grid_dims , corners , titles ): \"\"\"Calculate coordinate chart layout. Called by __init__, but can be called later to update the chart. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles \"\"\" # Calculate exterior height and width of grid width = float ( np . max ( corners [ 'x' ]) + np . min ( corners [ 'x' ])) height = float ( np . max ( corners [ 'y' ]) + np . min ( corners [ 'y' ])) # Set grid and border coordinates for traces self . _grid = calculate_grid ( grid_dims , corners , width , height ) self . _borders = calculate_border ( grid_dims , width , height ) # Add titles to annotations if provided if titles is None : self . annotations = [] else : v_offset = np . min ( corners [ 'y' ]) * 0.4 self . annotations = [ go . layout . Annotation ( ax = 0 , ay = 0 , x = ( idx % grid_dims [ 1 ] + 0.5 ) * width , # noqa: S001 y = ( grid_dims [ 0 ] - int ( idx / grid_dims [ 1 ]) % grid_dims [ 0 ]) * height - v_offset , text = title , ) for idx , title in enumerate ( titles ) if title is not None ] def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the column `values: str` Returns: list: Dash chart traces \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'values' ]) # Merge x/y grid data with values. Temporarily extend values with None, then drop those rows values = df_raw [ 'values' ] . to_list () values . extend ([ None ] * ( len ( self . _grid [ 'x' ]) - len ( values ))) df_grid = pd . DataFrame ( data = { 'values' : values , 'x' : self . _grid [ 'x' ], 'y' : self . _grid [ 'y' ], }, ) . dropna () return [ go . Scatter ( hoverinfo = 'none' , line = self . border_line or { 'color' : 'black' }, mode = 'lines' , opacity = self . border_opacity , showlegend = False , x = border [ 'x' ], y = border [ 'y' ], ) for border in self . _borders ] + [ go . Scatter ( hoverinfo = 'text' , mode = 'markers' , showlegend = False , text = df_grid [ 'values' ], x = df_grid [ 'x' ], y = df_grid [ 'y' ], marker = self . create_marker ( df_grid , ** ( self . marker_kwargs or {})), ), ] def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ): \"\"\"Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Args: df_grid: pandas dataframe with at minimum the column `values: str`, `x: float`, `y: float` colorscale: plotly colorscale, see doc link above. Default is 'Viridis' size: integer marker size symbol: marker symbol (square, circle, circle-open, x, etc.) Returns: dict: the chart marker shape, symbol, color, etc. \"\"\" return { 'color' : df_grid [ 'values' ], 'colorscale' : colorscale , 'showscale' : True , 'size' : size , 'symbol' : symbol , } def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () for axis in [ 'xaxis' , 'yaxis' ]: layout [ axis ][ 'showgrid' ] = False layout [ axis ][ 'showticklabels' ] = False layout [ axis ][ 'zeroline' ] = False layout [ 'yaxis' ][ 'scaleanchor' ] = 'x' layout [ 'yaxis' ][ 'scaleratio' ] = 1 return layout # ============================================================================== # Standard Coordinate Grids class GridClass : \"\"\"Base class for specifying a grid for the Coordinate chart.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments. Default is None.\"\"\" def __init__ ( self , grid_dims , titles ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element \"\"\" self . grid_dims = grid_dims self . titles = titles class CircleGrid ( GridClass ): # noqa: H601 \"\"\"Grid of circular coordinates.\"\"\" marker_kwargs = { 'size' : 10 } \"\"\"Marker keyword arguments. Default is `{'size': 10}`\"\"\" def __init__ ( self , grid_dims , titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element. Default is None \"\"\" if titles is None : titles = [] for idx in range ( grid_dims [ 0 ] * grid_dims [ 1 ]): x_coord = int ( idx / grid_dims [ 1 ]) + 1 y_coord = idx % ( grid_dims [ 0 ] + 1 ) + 1 # noqa: S001 titles . append ( f 'Subtitle for ( { x_coord } , { y_coord } )' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners opp = 0.5 * math . cos ( cmath . pi / 4 ) adj = 0.5 * math . sin ( cmath . pi / 4 ) self . corners = { 'x' : [ 0.5 , 1 - adj , 1.0 , 1 + adj , 1.5 , 1 + adj , 1.0 , 1 - adj ], 'y' : [ 1.0 , 1 - opp , 0.5 , 1 - opp , 1.0 , 1 + opp , 1.5 , 1 + opp ], } def calculate_calendar_grid_corners ( margin , days_in_week = 7 , max_weeks_in_month = 6 ): \"\"\"Calculate the four exterior corner coordinates of a calendar coordinate grid. Args: margin: float spacing between tiles days_in_week: number of days in week. Default is 7 max_weeks_in_month: max number of weeks in a month. Default is 6 Returns: list: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates \"\"\" y_indices = [[ idx ] * days_in_week for idx in range ( max_weeks_in_month )] return { 'x' : np . add ([ * range ( days_in_week )] * max_weeks_in_month , margin ), 'y' : np . add ([ * chain . from_iterable ( y_indices )], margin ), } class YearGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a grid of months in one year.\"\"\" marker_kwargs = { 'size' : 10 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 10, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 4 , 3 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (4, 3) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions \"\"\" if grid_dims [ 0 ] * grid_dims [ 1 ] != 12 : # pragma: no cover raise RuntimeError ( 'Calendar must show all 12 months Expected (12,1), (6,2), (4,3), (1,12), etc.' ) if titles is None : titles = calendar . month_name [ 1 :] super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 2 ) def format_data ( self , month_lists , year ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: month_lists: list of daily values where each sublist is one month starting with January year: year expressed in 4 decimal places (i.e. 2019) Returns: list: of values with additional None values to align with grid \"\"\" values = [] for idx_month , daily_list in enumerate ( month_lists ): idx_first_day , count_days = calendar . monthrange ( year , idx_month + 1 ) idx_first_day += 1 # Increment to start on Sunday -- PLANNED: make this configureable values . extend ([ None ] * idx_first_day ) values . extend ( daily_list ) values . extend ([ None ] * ( len ( self . corners [ 'x' ]) - idx_first_day - count_days )) return values class MonthGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a single month.\"\"\" marker_kwargs = { 'size' : 35 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 35, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 1 , 1 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (1, 1) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions or titles \"\"\" if grid_dims != ( 1 , 1 ): # pragma: no cover raise RuntimeError ( 'Day grid can only show one month, expected (1, 1)' ) if titles is not None and len ( titles ) != 1 : # pragma: no cover raise RuntimeError ( f 'Only one title is allowed for the MonthGrid. Received: { titles } ' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 1.25 ) def format_data ( self , daily_values , year , month ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: daily_values: list of values for each day of month year: year expressed in 4 digits (2019, 2020, etc.) month: month index in [1, 12] Returns: list: of values with additional None values to align with grid \"\"\" idx_first_day = calendar . monthrange ( year , month )[ 0 ] values = [ None ] * idx_first_day values . extend ( daily_values ) return values","title":"dash_charts.coordinate_chart"},{"location":"modules/dash_charts/coordinate_chart/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/coordinate_chart/#calculate_border","text":"def calculate_border ( grid_dims , width , height ) Calculate each line in all borders. Parameters: Name Description grid_dims tuple of the number of tiles in grid. In format (row, column) width float width in pixels height float height in pixels Returns: Type Description list containing dictionaries keys (x, y) and values for the two points for each line in grid View Source def calculate_border ( grid_dims , width , height ): \"\"\"Calculate each line in all borders. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` width: float width in pixels height: float height in pixels Returns: list: containing dictionaries keys `(x, y)` and values for the two points for each line in grid \"\"\" return [ { 'x' : [ c_idx * width ] * 2 , 'y' : [ 0 , height * grid_dims [ 0 ]], } for c_idx in range ( grid_dims [ 1 ] + 1 ) ] + [ { 'x' : [ 0 , width * grid_dims [ 1 ]], 'y' : [ r_idx * height ] * 2 , } for r_idx in range ( grid_dims [ 0 ] + 1 ) ]","title":"calculate_border"},{"location":"modules/dash_charts/coordinate_chart/#calculate_calendar_grid_corners","text":"def calculate_calendar_grid_corners ( margin , days_in_week = 7 , max_weeks_in_month = 6 ) Calculate the four exterior corner coordinates of a calendar coordinate grid. Parameters: Name Description margin float spacing between tiles days_in_week number of days in week. Default is 7 max_weeks_in_month max number of weeks in a month. Default is 6 Returns: Type Description list dictionary with keys (x, y) containing lists of the four exterior corner coordinates View Source def calculate_calendar_grid_corners ( margin , days_in_week = 7 , max_weeks_in_month = 6 ): \"\"\"Calculate the four exterior corner coordinates of a calendar coordinate grid. Args: margin: float spacing between tiles days_in_week: number of days in week. Default is 7 max_weeks_in_month: max number of weeks in a month. Default is 6 Returns: list: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates \"\"\" y_indices = [[ idx ] * days_in_week for idx in range ( max_weeks_in_month )] return { 'x' : np . add ([ * range ( days_in_week )] * max_weeks_in_month , margin ), 'y' : np . add ([ * chain . from_iterable ( y_indices )], margin ), }","title":"calculate_calendar_grid_corners"},{"location":"modules/dash_charts/coordinate_chart/#calculate_grid","text":"def calculate_grid ( grid_dims , corners , width , height ) Calculate the grid x and y coordinates. Parameters: Name Description grid_dims tuple of the number of tiles in grid. In format (row, column) corners dictionary with keys (x, y) containing lists of the four exterior corner coordinates width float width in pixels height float height in pixels Returns: Type Description dict with keys (x, y) with lists of lists containing float values View Source def calculate_grid ( grid_dims , corners , width , height ): \"\"\"Calculate the grid x and y coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four exterior corner coordinates width: float width in pixels height: float height in pixels Returns: dict: with keys `(x, y)` with lists of lists containing float values \"\"\" grid = { 'x' : [], 'y' : []} for r_idx in range ( grid_dims [ 0 ]): y_offset = height * ( grid_dims [ 0 ] - r_idx ) y_grid = [ y_offset - _y for _y in corners [ 'y' ]] for c_idx in range ( grid_dims [ 1 ]): x_offset = width * c_idx grid [ 'x' ] . extend ([ x_offset + _x for _x in corners [ 'x' ]]) grid [ 'y' ] . extend ( y_grid ) return grid","title":"calculate_grid"},{"location":"modules/dash_charts/coordinate_chart/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/coordinate_chart/#circlegrid","text":"class CircleGrid ( grid_dims , titles = None ) View Source class CircleGrid ( GridClass ): # noqa: H601 \"\"\"Grid of circular coordinates.\"\"\" marker_kwargs = { 'size' : 10 } \"\"\"Marker keyword arguments. Default is `{'size': 10}`\"\"\" def __init__ ( self , grid_dims , titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element. Default is None \"\"\" if titles is None : titles = [] for idx in range ( grid_dims [ 0 ] * grid_dims [ 1 ]): x_coord = int ( idx / grid_dims [ 1 ]) + 1 y_coord = idx % ( grid_dims [ 0 ] + 1 ) + 1 # noqa: S001 titles . append ( f 'Subtitle for ( { x_coord } , { y_coord } )' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners opp = 0.5 * math . cos ( cmath . pi / 4 ) adj = 0.5 * math . sin ( cmath . pi / 4 ) self . corners = { 'x' : [ 0.5 , 1 - adj , 1.0 , 1 + adj , 1.5 , 1 + adj , 1.0 , 1 - adj ], 'y' : [ 1.0 , 1 - opp , 0.5 , 1 - opp , 1.0 , 1 + opp , 1.5 , 1 + opp ], }","title":"CircleGrid"},{"location":"modules/dash_charts/coordinate_chart/#ancestors-in-mro","text":"dash_charts.coordinate_chart.GridClass","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/coordinate_chart/#class-variables","text":"marker_kwargs Marker keyword arguments. Default is {'size': 10}","title":"Class variables"},{"location":"modules/dash_charts/coordinate_chart/#coordinatechart","text":"class CoordinateChart ( * , title , grid_dims , corners , titles = None , layout_overrides = () ) View Source class CoordinateChart ( CustomChart ): # noqa: H601 \"\"\"Coordinate Chart.\"\"\" border_opacity : float = 0.2 \"\"\"Border opacity for grid. Value must be in [0-1] where 0 is none. Default is 0.2.\"\"\" border_line = None \"\"\"Dictionary passed to plotly `line`. Used to set thickness, color, dash style, etc. Default is None.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments used in `create_marker()`. Default is None.\"\"\" # Private states for managing coordinate chart dimensions _grid : dict _borders : list def __init__ ( self , * , title , grid_dims , corners , titles = None , layout_overrides = ()): \"\"\"Initialize Coordinate Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" # Initialize base method. Sets xlabel and ylabel to empty strings because coordinate chart use the x/y # axis for arranging points. Data is displayed by color or size super () . __init__ ( title = title , xlabel = '' , ylabel = '' , layout_overrides = layout_overrides ) # Initialize chart parameters self . calculate_layout ( grid_dims , corners , titles ) def calculate_layout ( self , grid_dims , corners , titles ): \"\"\"Calculate coordinate chart layout. Called by __init__, but can be called later to update the chart. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles \"\"\" # Calculate exterior height and width of grid width = float ( np . max ( corners [ 'x' ]) + np . min ( corners [ 'x' ])) height = float ( np . max ( corners [ 'y' ]) + np . min ( corners [ 'y' ])) # Set grid and border coordinates for traces self . _grid = calculate_grid ( grid_dims , corners , width , height ) self . _borders = calculate_border ( grid_dims , width , height ) # Add titles to annotations if provided if titles is None : self . annotations = [] else : v_offset = np . min ( corners [ 'y' ]) * 0.4 self . annotations = [ go . layout . Annotation ( ax = 0 , ay = 0 , x = ( idx % grid_dims [ 1 ] + 0.5 ) * width , # noqa: S001 y = ( grid_dims [ 0 ] - int ( idx / grid_dims [ 1 ]) % grid_dims [ 0 ]) * height - v_offset , text = title , ) for idx , title in enumerate ( titles ) if title is not None ] def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the column `values: str` Returns: list: Dash chart traces \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'values' ]) # Merge x/y grid data with values. Temporarily extend values with None, then drop those rows values = df_raw [ 'values' ] . to_list () values . extend ([ None ] * ( len ( self . _grid [ 'x' ]) - len ( values ))) df_grid = pd . DataFrame ( data = { 'values' : values , 'x' : self . _grid [ 'x' ], 'y' : self . _grid [ 'y' ], }, ) . dropna () return [ go . Scatter ( hoverinfo = 'none' , line = self . border_line or { 'color' : 'black' }, mode = 'lines' , opacity = self . border_opacity , showlegend = False , x = border [ 'x' ], y = border [ 'y' ], ) for border in self . _borders ] + [ go . Scatter ( hoverinfo = 'text' , mode = 'markers' , showlegend = False , text = df_grid [ 'values' ], x = df_grid [ 'x' ], y = df_grid [ 'y' ], marker = self . create_marker ( df_grid , ** ( self . marker_kwargs or {})), ), ] def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ): \"\"\"Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Args: df_grid: pandas dataframe with at minimum the column `values: str`, `x: float`, `y: float` colorscale: plotly colorscale, see doc link above. Default is 'Viridis' size: integer marker size symbol: marker symbol (square, circle, circle-open, x, etc.) Returns: dict: the chart marker shape, symbol, color, etc. \"\"\" return { 'color' : df_grid [ 'values' ], 'colorscale' : colorscale , 'showscale' : True , 'size' : size , 'symbol' : symbol , } def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () for axis in [ 'xaxis' , 'yaxis' ]: layout [ axis ][ 'showgrid' ] = False layout [ axis ][ 'showticklabels' ] = False layout [ axis ][ 'zeroline' ] = False layout [ 'yaxis' ][ 'scaleanchor' ] = 'x' layout [ 'yaxis' ][ 'scaleratio' ] = 1 return layout","title":"CoordinateChart"},{"location":"modules/dash_charts/coordinate_chart/#ancestors-in-mro_1","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/coordinate_chart/#class-variables_1","text":"annotations border_line Dictionary passed to plotly line . Used to set thickness, color, dash style, etc. Default is None. border_opacity marker_kwargs Marker keyword arguments used in create_marker() . Default is None.","title":"Class variables"},{"location":"modules/dash_charts/coordinate_chart/#instance-variables","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/coordinate_chart/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/coordinate_chart/#apply_custom_layout","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/coordinate_chart/#calculate_layout","text":"def calculate_layout ( self , grid_dims , corners , titles ) Calculate coordinate chart layout. Called by init , but can be called later to update the chart. Parameters: Name Description grid_dims tuple of the number of tiles in grid. In format (row, column) corners dictionary with keys (x, y) containing lists of the four corner coordinates titles list of strings that will appear in each tile. Default is None for no titles View Source def calculate_layout ( self , grid_dims , corners , titles ): \"\"\"Calculate coordinate chart layout. Called by __init__, but can be called later to update the chart. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` corners: dictionary with keys `(x, y)` containing lists of the four corner coordinates titles: list of strings that will appear in each tile. Default is None for no titles \"\"\" # Calculate exterior height and width of grid width = float ( np . max ( corners [ 'x' ]) + np . min ( corners [ 'x' ])) height = float ( np . max ( corners [ 'y' ]) + np . min ( corners [ 'y' ])) # Set grid and border coordinates for traces self . _grid = calculate_grid ( grid_dims , corners , width , height ) self . _borders = calculate_border ( grid_dims , width , height ) # Add titles to annotations if provided if titles is None : self . annotations = [] else : v_offset = np . min ( corners [ 'y' ]) * 0.4 self . annotations = [ go . layout . Annotation ( ax = 0 , ay = 0 , x = ( idx % grid_dims [ 1 ] + 0.5 ) * width , # noqa: S001 y = ( grid_dims [ 0 ] - int ( idx / grid_dims [ 1 ]) % grid_dims [ 0 ]) * height - v_offset , text = title , ) for idx , title in enumerate ( titles ) if title is not None ]","title":"calculate_layout"},{"location":"modules/dash_charts/coordinate_chart/#create_figure","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/coordinate_chart/#create_layout","text":"def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () for axis in [ 'xaxis' , 'yaxis' ]: layout [ axis ][ 'showgrid' ] = False layout [ axis ][ 'showticklabels' ] = False layout [ axis ][ 'zeroline' ] = False layout [ 'yaxis' ][ 'scaleanchor' ] = 'x' layout [ 'yaxis' ][ 'scaleratio' ] = 1 return layout","title":"create_layout"},{"location":"modules/dash_charts/coordinate_chart/#create_marker","text":"def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ) Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Parameters: Name Description df_grid pandas dataframe with at minimum the column values: str , x: float , y: float colorscale plotly colorscale, see doc link above. Default is \u2018Viridis\u2019 size integer marker size symbol marker symbol (square, circle, circle-open, x, etc.) Returns: Type Description dict the chart marker shape, symbol, color, etc. View Source def create_marker ( self , df_grid , colorscale = 'Viridis' , size = 16 , symbol = 'circle' ): \"\"\"Return a dictionary for the scatter plot. See: https://plot.ly/python/colorscales/ (Named colorscales: Reds, Bluered, Jet, Viridis, Cividis, etc.) Args: df_grid: pandas dataframe with at minimum the column `values: str`, `x: float`, `y: float` colorscale: plotly colorscale, see doc link above. Default is 'Viridis' size: integer marker size symbol: marker symbol (square, circle, circle-open, x, etc.) Returns: dict: the chart marker shape, symbol, color, etc. \"\"\" return { 'color' : df_grid [ 'values' ], 'colorscale' : colorscale , 'showscale' : True , 'size' : size , 'symbol' : symbol , }","title":"create_marker"},{"location":"modules/dash_charts/coordinate_chart/#create_traces","text":"def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with at minimum the column values: str Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the column `values: str` Returns: list: Dash chart traces \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'values' ]) # Merge x/y grid data with values. Temporarily extend values with None, then drop those rows values = df_raw [ 'values' ] . to_list () values . extend ([ None ] * ( len ( self . _grid [ 'x' ]) - len ( values ))) df_grid = pd . DataFrame ( data = { 'values' : values , 'x' : self . _grid [ 'x' ], 'y' : self . _grid [ 'y' ], }, ) . dropna () return [ go . Scatter ( hoverinfo = 'none' , line = self . border_line or { 'color' : 'black' }, mode = 'lines' , opacity = self . border_opacity , showlegend = False , x = border [ 'x' ], y = border [ 'y' ], ) for border in self . _borders ] + [ go . Scatter ( hoverinfo = 'text' , mode = 'markers' , showlegend = False , text = df_grid [ 'values' ], x = df_grid [ 'x' ], y = df_grid [ 'y' ], marker = self . create_marker ( df_grid , ** ( self . marker_kwargs or {})), ), ]","title":"create_traces"},{"location":"modules/dash_charts/coordinate_chart/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/coordinate_chart/#gridclass","text":"class GridClass ( grid_dims , titles ) View Source class GridClass : \"\"\"Base class for specifying a grid for the Coordinate chart.\"\"\" marker_kwargs = None \"\"\"Marker keyword arguments. Default is None.\"\"\" def __init__ ( self , grid_dims , titles ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)` titles: list of titles to place in each grid element \"\"\" self . grid_dims = grid_dims self . titles = titles","title":"GridClass"},{"location":"modules/dash_charts/coordinate_chart/#descendants","text":"dash_charts.coordinate_chart.CircleGrid dash_charts.coordinate_chart.YearGrid dash_charts.coordinate_chart.MonthGrid","title":"Descendants"},{"location":"modules/dash_charts/coordinate_chart/#class-variables_2","text":"marker_kwargs Marker keyword arguments. Default is None.","title":"Class variables"},{"location":"modules/dash_charts/coordinate_chart/#monthgrid","text":"class MonthGrid ( grid_dims = ( 1 , 1 ), titles = None ) View Source class MonthGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a single month.\"\"\" marker_kwargs = { 'size' : 35 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 35, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 1 , 1 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (1, 1) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions or titles \"\"\" if grid_dims != ( 1 , 1 ): # pragma: no cover raise RuntimeError ( 'Day grid can only show one month, expected (1, 1)' ) if titles is not None and len ( titles ) != 1 : # pragma: no cover raise RuntimeError ( f 'Only one title is allowed for the MonthGrid. Received: { titles } ' ) super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 1.25 ) def format_data ( self , daily_values , year , month ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: daily_values: list of values for each day of month year: year expressed in 4 digits (2019, 2020, etc.) month: month index in [1, 12] Returns: list: of values with additional None values to align with grid \"\"\" idx_first_day = calendar . monthrange ( year , month )[ 0 ] values = [ None ] * idx_first_day values . extend ( daily_values ) return values","title":"MonthGrid"},{"location":"modules/dash_charts/coordinate_chart/#ancestors-in-mro_2","text":"dash_charts.coordinate_chart.GridClass","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/coordinate_chart/#class-variables_3","text":"marker_kwargs Marker keyword arguments. Default is {'size': 35, 'symbol': 'square'}","title":"Class variables"},{"location":"modules/dash_charts/coordinate_chart/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/coordinate_chart/#format_data","text":"def format_data ( self , daily_values , year , month ) Return the formatted list that can be passed to a coordinate chart. Parameters: Name Description daily_values list of values for each day of month year year expressed in 4 digits (2019, 2020, etc.) month month index in [1, 12] Returns: Type Description list of values with additional None values to align with grid View Source def format_data ( self , daily_values , year , month ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: daily_values: list of values for each day of month year: year expressed in 4 digits (2019, 2020, etc.) month: month index in [1, 12] Returns: list: of values with additional None values to align with grid \"\"\" idx_first_day = calendar . monthrange ( year , month )[ 0 ] values = [ None ] * idx_first_day values . extend ( daily_values ) return values","title":"format_data"},{"location":"modules/dash_charts/coordinate_chart/#yeargrid","text":"class YearGrid ( grid_dims = ( 4 , 3 ), titles = None ) View Source class YearGrid ( GridClass ): # noqa: H601 \"\"\"Coordinates of days within a grid of months in one year.\"\"\" marker_kwargs = { 'size' : 10 , 'symbol' : 'square' } \"\"\"Marker keyword arguments. Default is `{'size': 10, 'symbol': 'square'}`\"\"\" def __init__ ( self , grid_dims = ( 4 , 3 ), titles = None ): \"\"\"Initialize the coordinates. Args: grid_dims: tuple of the number of tiles in grid. In format `(row, column)`. Default is (4, 3) titles: list of titles to place in each grid element. Default is None Raises: RuntimeError: if error in the grid dimensions \"\"\" if grid_dims [ 0 ] * grid_dims [ 1 ] != 12 : # pragma: no cover raise RuntimeError ( 'Calendar must show all 12 months Expected (12,1), (6,2), (4,3), (1,12), etc.' ) if titles is None : titles = calendar . month_name [ 1 :] super () . __init__ ( grid_dims = grid_dims , titles = titles ) # Calculate four corners self . corners = calculate_calendar_grid_corners ( margin = 2 ) def format_data ( self , month_lists , year ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: month_lists: list of daily values where each sublist is one month starting with January year: year expressed in 4 decimal places (i.e. 2019) Returns: list: of values with additional None values to align with grid \"\"\" values = [] for idx_month , daily_list in enumerate ( month_lists ): idx_first_day , count_days = calendar . monthrange ( year , idx_month + 1 ) idx_first_day += 1 # Increment to start on Sunday -- PLANNED: make this configureable values . extend ([ None ] * idx_first_day ) values . extend ( daily_list ) values . extend ([ None ] * ( len ( self . corners [ 'x' ]) - idx_first_day - count_days )) return values","title":"YearGrid"},{"location":"modules/dash_charts/coordinate_chart/#ancestors-in-mro_3","text":"dash_charts.coordinate_chart.GridClass","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/coordinate_chart/#class-variables_4","text":"marker_kwargs Marker keyword arguments. Default is {'size': 10, 'symbol': 'square'}","title":"Class variables"},{"location":"modules/dash_charts/coordinate_chart/#methods_2","text":"","title":"Methods"},{"location":"modules/dash_charts/coordinate_chart/#format_data_1","text":"def format_data ( self , month_lists , year ) Return the formatted list that can be passed to a coordinate chart. Parameters: Name Description month_lists list of daily values where each sublist is one month starting with January year year expressed in 4 decimal places (i.e. 2019) Returns: Type Description list of values with additional None values to align with grid View Source def format_data ( self , month_lists , year ): \"\"\"Return the formatted list that can be passed to a coordinate chart. Args: month_lists: list of daily values where each sublist is one month starting with January year: year expressed in 4 decimal places (i.e. 2019) Returns: list: of values with additional None values to align with grid \"\"\" values = [] for idx_month , daily_list in enumerate ( month_lists ): idx_first_day , count_days = calendar . monthrange ( year , idx_month + 1 ) idx_first_day += 1 # Increment to start on Sunday -- PLANNED: make this configureable values . extend ([ None ] * idx_first_day ) values . extend ( daily_list ) values . extend ([ None ] * ( len ( self . corners [ 'x' ]) - idx_first_day - count_days )) return values","title":"format_data"},{"location":"modules/dash_charts/custom_colorscales/","text":"dash_charts.custom_colorscales \u2693\ufe0e Custom Plotly Colorscales. View Source \"\"\"Custom Plotly Colorscales.\"\"\" DEFAULT_PLOTLY_COLORS = [ '#1f77b4' , # muted blue '#ff7f0e' , # safety orange '#2ca02c' , # cooked asparagus green '#d62728' , # brick red '#9467bd' , # muted purple '#8c564b' , # chestnut brown '#e377c2' , # raspberry yogurt pink '#7f7f7f' , # middle gray '#bcbd22' , # curry yellow-green '#17becf' , # blue-teal ] \"\"\"List of default Plotly colors in Hex strings.\"\"\" DEFAULT_PLOTLY_COLORS_RGB = [ 'rgb(31,119,180)' , # 0 'rgb(255,127,14)' , # 1 'rgb(44,160,44)' , # 2 'rgb(214,39,40)' , # 3 'rgb(148,103,189)' , # 4 'rgb(140,86,75)' , # 5 'rgb(227,119,194)' , # 6 'rgb(127,127,127)' , # 7 'rgb(188,189,34)' , # 8 'rgb(23,190,207)' , # 9 ] \"\"\"List of default Plotly colors in RGB strings.\"\"\" # From SF Example: (#fdae61, #abd9e9, #2c7bb6) # Plotly Colors: # ['Blackbody', 'Blackbody_r', 'Bluered', 'Bluered_r', 'Blues', 'Blues_r', 'Cividis', 'Cividis_r', 'Earth', 'Earth_r', # 'Electric', 'Electric_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'Hot', 'Hot_r', 'Jet', 'Jet_r', 'Picnic', # 'Picnic_r', 'Portland', 'Portland_r', 'Rainbow', 'Rainbow_r', 'RdBu', 'RdBu_r', 'Reds', 'Reds_r', 'Viridis', # 'Viridis_r', 'YlGnBu', 'YlGnBu_r', 'YlOrRd', 'YlOrRd_r', 'scale_name', 'scale_name_r', 'scale_pairs', # 'scale_pairs_r', 'scale_sequence', 'scale_sequence_r'] # plotly.colors.plotlyjs.Hot / `[rgb(0,0,0), rgb(230,0,0), rgb(255,210,0), rgb(255,255,255)]` Variables \u2693\ufe0e DEFAULT_PLOTLY_COLORS List of default Plotly colors in Hex strings. DEFAULT_PLOTLY_COLORS_RGB List of default Plotly colors in RGB strings.","title":"dash_charts.custom_colorscales"},{"location":"modules/dash_charts/custom_colorscales/#dash_chartscustom_colorscales","text":"Custom Plotly Colorscales. View Source \"\"\"Custom Plotly Colorscales.\"\"\" DEFAULT_PLOTLY_COLORS = [ '#1f77b4' , # muted blue '#ff7f0e' , # safety orange '#2ca02c' , # cooked asparagus green '#d62728' , # brick red '#9467bd' , # muted purple '#8c564b' , # chestnut brown '#e377c2' , # raspberry yogurt pink '#7f7f7f' , # middle gray '#bcbd22' , # curry yellow-green '#17becf' , # blue-teal ] \"\"\"List of default Plotly colors in Hex strings.\"\"\" DEFAULT_PLOTLY_COLORS_RGB = [ 'rgb(31,119,180)' , # 0 'rgb(255,127,14)' , # 1 'rgb(44,160,44)' , # 2 'rgb(214,39,40)' , # 3 'rgb(148,103,189)' , # 4 'rgb(140,86,75)' , # 5 'rgb(227,119,194)' , # 6 'rgb(127,127,127)' , # 7 'rgb(188,189,34)' , # 8 'rgb(23,190,207)' , # 9 ] \"\"\"List of default Plotly colors in RGB strings.\"\"\" # From SF Example: (#fdae61, #abd9e9, #2c7bb6) # Plotly Colors: # ['Blackbody', 'Blackbody_r', 'Bluered', 'Bluered_r', 'Blues', 'Blues_r', 'Cividis', 'Cividis_r', 'Earth', 'Earth_r', # 'Electric', 'Electric_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'Hot', 'Hot_r', 'Jet', 'Jet_r', 'Picnic', # 'Picnic_r', 'Portland', 'Portland_r', 'Rainbow', 'Rainbow_r', 'RdBu', 'RdBu_r', 'Reds', 'Reds_r', 'Viridis', # 'Viridis_r', 'YlGnBu', 'YlGnBu_r', 'YlOrRd', 'YlOrRd_r', 'scale_name', 'scale_name_r', 'scale_pairs', # 'scale_pairs_r', 'scale_sequence', 'scale_sequence_r'] # plotly.colors.plotlyjs.Hot / `[rgb(0,0,0), rgb(230,0,0), rgb(255,210,0), rgb(255,255,255)]`","title":"dash_charts.custom_colorscales"},{"location":"modules/dash_charts/custom_colorscales/#variables","text":"DEFAULT_PLOTLY_COLORS List of default Plotly colors in Hex strings. DEFAULT_PLOTLY_COLORS_RGB List of default Plotly colors in RGB strings.","title":"Variables"},{"location":"modules/dash_charts/datatable/","text":"dash_charts.datatable \u2693\ufe0e DataTable Base Classes. View Source \"\"\"DataTable Base Classes.\"\"\" from dash import dash_table # TODO: See pattern mathing callbacks for adding buttons (to show modal) to datatables # https://dash.plotly.com/pattern-matching-callbacks # PLANNED: see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting # PLANNED: These methods may be replaced in a future version of Dash # Currently, edge case when column is string, but filter could be a number # See: https://dash.plot.ly/datatable/callbacks & https://github.com/plotly/dash-table/issues/441 OPERATORS = [ [ 'ge ' , '>=' ], [ 'le ' , '<=' ], [ 'lt ' , '<' ], [ 'gt ' , '>' ], [ 'ne ' , '!=' ], [ 'eq ' , '=' ], [ 'contains ' ], [ 'datestartswith ' ], ] \"\"\"List of lists containing each possible filter string.\"\"\" def split_filter_part ( filter_part ): # noqa: CCR001 \"\"\"Split the filter into `(name, operator, value)` components. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: filter_part: string filter query Returns: tuple: `(name, operator, value)` which could be all None if no match was found \"\"\" for operator_type in OPERATORS : for operator in operator_type : if operator in filter_part : name_part , value_part = filter_part . split ( operator , 1 ) name = name_part [ name_part . find ( '{' ) + 1 : name_part . rfind ( '}' )] value_part = value_part . strip () v0 = value_part [ 0 ] if ( v0 == value_part [ - 1 ] and v0 in ( \"'\" , '\"' , '`' )): value = value_part [ 1 : - 1 ] . replace ( f ' \\\\ { v0 } ' , v0 ) else : try : value = float ( value_part ) except ValueError : value = value_part # Word operators need spaces after them in the filter string, but we don't want these later return ( name , operator_type [ 0 ] . strip (), value ) return [ None , None , None ] def apply_datatable_filters ( df_table , filter_query ): \"\"\"Filter a dataframe based on Dash datatable filterquery. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: df_table: pandas dataframe to filter filter_query: Dash datatable string filter query Returns: dataframe: filtered dataframe \"\"\" filtering_expressions = filter_query . split ( ' && ' ) for filter_part in filtering_expressions : col_name , operator , filter_value = split_filter_part ( filter_part ) if operator in ( 'eq' , 'ne' , 'lt' , 'le' , 'gt' , 'ge' ): # these operators match pandas series operator method names df_table = df_table . loc [ getattr ( df_table [ col_name ], operator )( filter_value )] elif operator == 'contains' : df_table = df_table . loc [ df_table [ col_name ] . str . contains ( filter_value )] elif operator == 'datestartswith' : # this is a simplification of the front-end filtering logic, # only works with complete fields in standard format df_table = df_table . loc [ df_table [ col_name ] . str . startswith ( filter_value )] return df_table # PLANNED: Maybe move parameters to attr.ib classes? class BaseDataTable : # noqa: H601 \"\"\"Base Class for Data Tables.\"\"\" filter_summary = \"\"\"Table Filter Syntax: Full documentation at: [https://dash.plot.ly/datatable/filtering](https://dash.plot.ly/datatable/filtering) - `eq`: exact match (applies to number columns and will try to convert string to number) - `contains`: search for exact (case-sensitive) substring in each cell - `datestartswith`: matches partial datetime. For example, datestartswith `2018-03-01` will match `2018-03-01 12:59` but not `2018-03` - `ne`, `gt`, `ge`, `lt`, `le`: comparison operators for not equal, greater than, greater or equal, less than, etc. Applies to numbers and string columns (uses numbers, symbols, uppercase letter, lowercase letters) Press enter of tab to apply the filter\"\"\" \"\"\"Markdown text explaining dash_table.DataTable filtering rules with link to full documentation.\"\"\" # dash_table.DataTable Parameters. Documentation: https://dash.plot.ly/datatable/reference style_table = None \"\"\"DataTable.style_table dictionary. Default enables overflowX scroll. Set in `initialize_mutables`.\"\"\" css = None \"\"\"DataTable.css list. Use the style_* properties first. Set in `initialize_mutables`. Default sets row margin to zero to fix a negative margin issue when using dash_table and Bootstrap See: https://github.com/facultyai/dash-bootstrap-components/issues/334 Also sets other various style tweaks to highlight the filter icons on hover, etc. \"\"\" style_cell = None \"\"\"DataTable.style_cell dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_cell_conditional = None \"\"\"DataTable.style_cell_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_data = None \"\"\"DataTable.style_data dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_data_conditional = None \"\"\"DataTable.style_data_conditional list. Default is for odd rows to have an off-white background (zebra stripe). Set in `initialize_mutables` \"\"\" style_header = None \"\"\"DataTable.style_header dictionary. Default is bold and off-white background. Set in `initialize_mutables`.\"\"\" style_header_conditional = None \"\"\"DataTable.style_header_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_filter = None \"\"\"DataTable.style_filter dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_filter_conditional = None \"\"\"DataTable.style_filter_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" column_selectable = None \"\"\"DataTable.column_selectable. Default is `None`.\"\"\" column_kwarg_lookup = None \"\"\"Lookup for keyword arguments for each column allowing deletable, selectable, etc. to be set per column.\"\"\" export_format = 'none' \"\"\"DataTable.export_format. Default is `'none'`. Could be one of `(csv, xlsx)`.\"\"\" export_headers = 'names' \"\"\"DataTable.export_headers. Default is `'names'`. See documentation.\"\"\" filter_action = 'native' \"\"\"DataTable.filter_action. Default is `'native'`.\"\"\" page_size = 25 \"\"\"DataTable.page_size. Default is `'25'`.\"\"\" row_selectable = None \"\"\"DataTable.row_selectable. Default is `None`.\"\"\" style_as_list_view = False \"\"\"DataTable.style_as_list_view. Default is False.\"\"\" sort_action = 'native' \"\"\"DataTable.sort_action. Default is `'native'`.\"\"\" sort_mode = 'single' \"\"\"DataTable.sort_mode. Default is `'single'`.\"\"\" # CSS Variables text_color = '#333333' \"\"\"Default text color.\"\"\" background_color = '#ffffff' \"\"\"Default background color.\"\"\" zebra_color = '#f9f9f9' \"\"\"Default background color for odd rows (zebra-stripe).\"\"\" selected_cell_color = '#eaeaea' \"\"\"Default color for selected cells.\"\"\" def __init__ ( self ): \"\"\"Initialize class.\"\"\" self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" self . style_table = { 'overflowX' : 'scroll' } self . css = [ # Fix width when overflow is True and using dash_bootstrap_components { 'selector' : '.row' , 'rule' : 'margin: 0' }, # Based on: https://community.plot.ly/t/dash-table-datatable-styling-examples/15594/ # Align the select icon to the left and the sort icon to the right { 'selector' : 'th.dash-header div' , 'rule' : 'display: flex; align-items: center;' , }, { 'selector' : 'th.dash-header div span.column-header--select' , 'rule' : 'order: 1; flex-shrink: 5; text-align: left;' , }, { 'selector' : 'th.dash-header div span.column-header-name' , 'rule' : 'order: 2; flex-grow: 5; text-align: center;' , }, { 'selector' : 'th.dash-header div span.column-header--sort' , 'rule' : 'order: 3; flex-shrink: 5; text-align: right;' , }, # Remove excess borders to better match JQuery DataTables styling # (Some border styles don't appear to work from `self.style_header`) { 'selector' : 'th.dash-filter' , 'rule' : 'border-bottom-color: rgb(17, 17, 17) !important;' }, ] self . style_cell = { 'backgroundColor' : self . background_color , 'borderStyle' : f '1px solid { self . zebra_color } ' , 'color' : self . text_color , } self . style_cell_conditional = [] self . style_data = {} self . style_data_conditional = [ { 'if' : { 'row_index' : 'even' }, 'backgroundColor' : self . zebra_color }, ] self . style_header = { 'borderLeft' : 'none' , 'borderRight' : 'none' , 'borderTop' : 'none' , 'fontWeight' : 'bold' , } self . style_header_conditional = [] self . style_filter = { 'borderBottomColor' : 'rgb(17, 17, 17)' , } self . style_filter_conditional = [] self . initialize_column_kwarg_lookup () # Must be called last def initialize_column_kwarg_lookup ( self ): \"\"\"Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type \"\"\" self . column_kwarg_lookup = { 'default_kwargs' : { 'selectable' : True , }, } def create_table ( self , df_raw , columns = None , ** kwargs_datatable ): \"\"\"Create the dash_table.DataTable. Args: df_raw: data to pass to datatable columns: list of column names to display. Default is None to use all columns from df_raw kwargs_datatable: keyword arguments to pass to the datatable Returns: DataTable: returns dash_table.DataTable object \"\"\" if columns is None : columns = df_raw . columns return dash_table . DataTable ( ** self . _create_datatable ( df_raw , columns ), ** kwargs_datatable ) def format_datatable_columns ( self , df_raw , columns ): \"\"\"Return a list of column names formatted for a dash_table. Uses `self.self.column_name_kwarg_lookup`. Args: df_raw: data to pass to datatable columns: list of strings or None Returns: list: of dict with keys `(name, id, deleteable, selectable)` in order of df_raw columns \"\"\" return [ { 'name' : col , 'id' : col , ** self . column_kwarg_lookup . get ( col , self . column_kwarg_lookup [ 'default_kwargs' ])} for col in df_raw . columns if ( columns is None or col in columns ) ] def _create_datatable ( self , df_raw , columns , ** table_kwargs ): \"\"\"Return dictionary of keyword arguments for datatable. Args: df_raw: data to pass to datatable columns: will auto format list of string column names to display or use list of dicts table_kwargs: additional keyword arguments to pass to datatable, such as id Returns: dict: keys include `(columns, data)` and all data members \"\"\" return { 'columns' : self . format_datatable_columns ( df_raw , columns ) if isinstance ( columns [ 0 ], str ) else columns , 'data' : ( df_raw . loc [:, columns ] if columns is not None else df_raw ) . to_dict ( 'records' ), # Add all datamembers 'css' : self . css , 'style_table' : self . style_table , 'style_cell' : self . style_cell , 'style_cell_conditional' : self . style_cell_conditional , 'style_data' : self . style_data , 'style_data_conditional' : self . style_data_conditional , 'style_header' : self . style_header , 'style_header_conditional' : self . style_header_conditional , 'style_filter' : self . style_filter , 'style_filter_conditional' : self . style_filter_conditional , 'column_selectable' : self . column_selectable , 'export_format' : self . export_format , 'export_headers' : self . export_headers , 'filter_action' : self . filter_action , 'page_size' : self . page_size , 'row_selectable' : self . row_selectable , 'style_as_list_view' : self . style_as_list_view , 'sort_action' : self . sort_action , 'sort_mode' : self . sort_mode , } Variables \u2693\ufe0e OPERATORS List of lists containing each possible filter string. Functions \u2693\ufe0e apply_datatable_filters \u2693\ufe0e def apply_datatable_filters ( df_table , filter_query ) Filter a dataframe based on Dash datatable filterquery. Based on Backend Paging with Filtering : https://dash.plot.ly/datatable/callbacks Parameters: Name Description df_table pandas dataframe to filter filter_query Dash datatable string filter query Returns: Type Description dataframe filtered dataframe View Source def apply_datatable_filters ( df_table , filter_query ): \"\"\"Filter a dataframe based on Dash datatable filterquery. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: df_table: pandas dataframe to filter filter_query: Dash datatable string filter query Returns: dataframe: filtered dataframe \"\"\" filtering_expressions = filter_query . split ( ' && ' ) for filter_part in filtering_expressions : col_name , operator , filter_value = split_filter_part ( filter_part ) if operator in ( 'eq' , 'ne' , 'lt' , 'le' , 'gt' , 'ge' ): # these operators match pandas series operator method names df_table = df_table . loc [ getattr ( df_table [ col_name ], operator )( filter_value )] elif operator == 'contains' : df_table = df_table . loc [ df_table [ col_name ] . str . contains ( filter_value )] elif operator == 'datestartswith' : # this is a simplification of the front-end filtering logic, # only works with complete fields in standard format df_table = df_table . loc [ df_table [ col_name ] . str . startswith ( filter_value )] return df_table split_filter_part \u2693\ufe0e def split_filter_part ( filter_part ) Split the filter into (name, operator, value) components. Based on Backend Paging with Filtering : https://dash.plot.ly/datatable/callbacks Parameters: Name Description filter_part string filter query Returns: Type Description tuple (name, operator, value) which could be all None if no match was found View Source def split_filter_part ( filter_part ): # noqa: CCR001 \"\"\"Split the filter into `(name, operator, value)` components. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: filter_part: string filter query Returns: tuple: `(name, operator, value)` which could be all None if no match was found \"\"\" for operator_type in OPERATORS : for operator in operator_type : if operator in filter_part : name_part , value_part = filter_part . split ( operator , 1 ) name = name_part [ name_part . find ( '{' ) + 1 : name_part . rfind ( '}' )] value_part = value_part . strip () v0 = value_part [ 0 ] if ( v0 == value_part [ - 1 ] and v0 in ( \"'\" , '\"' , '`' )): value = value_part [ 1 : - 1 ] . replace ( f ' \\\\ { v0 } ' , v0 ) else : try : value = float ( value_part ) except ValueError : value = value_part # Word operators need spaces after them in the filter string, but we don't want these later return ( name , operator_type [ 0 ] . strip (), value ) return [ None , None , None ] Classes \u2693\ufe0e BaseDataTable \u2693\ufe0e class BaseDataTable ( ) View Source class BaseDataTable : # noqa: H601 \"\"\"Base Class for Data Tables.\"\"\" filter_summary = \"\"\"Table Filter Syntax: Full documentation at: [https://dash.plot.ly/datatable/filtering](https://dash.plot.ly/datatable/filtering) - `eq`: exact match (applies to number columns and will try to convert string to number) - `contains`: search for exact (case-sensitive) substring in each cell - `datestartswith`: matches partial datetime. For example, datestartswith `2018-03-01` will match `2018-03-01 12:59` but not `2018-03` - `ne`, `gt`, `ge`, `lt`, `le`: comparison operators for not equal, greater than, greater or equal, less than, etc. Applies to numbers and string columns (uses numbers, symbols, uppercase letter, lowercase letters) Press enter of tab to apply the filter\"\"\" \"\"\"Markdown text explaining dash_table.DataTable filtering rules with link to full documentation.\"\"\" # dash_table.DataTable Parameters. Documentation: https://dash.plot.ly/datatable/reference style_table = None \"\"\"DataTable.style_table dictionary. Default enables overflowX scroll. Set in `initialize_mutables`.\"\"\" css = None \"\"\"DataTable.css list. Use the style_* properties first. Set in `initialize_mutables`. Default sets row margin to zero to fix a negative margin issue when using dash_table and Bootstrap See: https://github.com/facultyai/dash-bootstrap-components/issues/334 Also sets other various style tweaks to highlight the filter icons on hover, etc. \"\"\" style_cell = None \"\"\"DataTable.style_cell dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_cell_conditional = None \"\"\"DataTable.style_cell_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_data = None \"\"\"DataTable.style_data dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_data_conditional = None \"\"\"DataTable.style_data_conditional list. Default is for odd rows to have an off-white background (zebra stripe). Set in `initialize_mutables` \"\"\" style_header = None \"\"\"DataTable.style_header dictionary. Default is bold and off-white background. Set in `initialize_mutables`.\"\"\" style_header_conditional = None \"\"\"DataTable.style_header_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_filter = None \"\"\"DataTable.style_filter dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_filter_conditional = None \"\"\"DataTable.style_filter_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" column_selectable = None \"\"\"DataTable.column_selectable. Default is `None`.\"\"\" column_kwarg_lookup = None \"\"\"Lookup for keyword arguments for each column allowing deletable, selectable, etc. to be set per column.\"\"\" export_format = 'none' \"\"\"DataTable.export_format. Default is `'none'`. Could be one of `(csv, xlsx)`.\"\"\" export_headers = 'names' \"\"\"DataTable.export_headers. Default is `'names'`. See documentation.\"\"\" filter_action = 'native' \"\"\"DataTable.filter_action. Default is `'native'`.\"\"\" page_size = 25 \"\"\"DataTable.page_size. Default is `'25'`.\"\"\" row_selectable = None \"\"\"DataTable.row_selectable. Default is `None`.\"\"\" style_as_list_view = False \"\"\"DataTable.style_as_list_view. Default is False.\"\"\" sort_action = 'native' \"\"\"DataTable.sort_action. Default is `'native'`.\"\"\" sort_mode = 'single' \"\"\"DataTable.sort_mode. Default is `'single'`.\"\"\" # CSS Variables text_color = '#333333' \"\"\"Default text color.\"\"\" background_color = '#ffffff' \"\"\"Default background color.\"\"\" zebra_color = '#f9f9f9' \"\"\"Default background color for odd rows (zebra-stripe).\"\"\" selected_cell_color = '#eaeaea' \"\"\"Default color for selected cells.\"\"\" def __init__ ( self ): \"\"\"Initialize class.\"\"\" self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" self . style_table = { 'overflowX' : 'scroll' } self . css = [ # Fix width when overflow is True and using dash_bootstrap_components { 'selector' : '.row' , 'rule' : 'margin: 0' }, # Based on: https://community.plot.ly/t/dash-table-datatable-styling-examples/15594/ # Align the select icon to the left and the sort icon to the right { 'selector' : 'th.dash-header div' , 'rule' : 'display: flex; align-items: center;' , }, { 'selector' : 'th.dash-header div span.column-header--select' , 'rule' : 'order: 1; flex-shrink: 5; text-align: left;' , }, { 'selector' : 'th.dash-header div span.column-header-name' , 'rule' : 'order: 2; flex-grow: 5; text-align: center;' , }, { 'selector' : 'th.dash-header div span.column-header--sort' , 'rule' : 'order: 3; flex-shrink: 5; text-align: right;' , }, # Remove excess borders to better match JQuery DataTables styling # (Some border styles don't appear to work from `self.style_header`) { 'selector' : 'th.dash-filter' , 'rule' : 'border-bottom-color: rgb(17, 17, 17) !important;' }, ] self . style_cell = { 'backgroundColor' : self . background_color , 'borderStyle' : f '1px solid { self . zebra_color } ' , 'color' : self . text_color , } self . style_cell_conditional = [] self . style_data = {} self . style_data_conditional = [ { 'if' : { 'row_index' : 'even' }, 'backgroundColor' : self . zebra_color }, ] self . style_header = { 'borderLeft' : 'none' , 'borderRight' : 'none' , 'borderTop' : 'none' , 'fontWeight' : 'bold' , } self . style_header_conditional = [] self . style_filter = { 'borderBottomColor' : 'rgb(17, 17, 17)' , } self . style_filter_conditional = [] self . initialize_column_kwarg_lookup () # Must be called last def initialize_column_kwarg_lookup ( self ): \"\"\"Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type \"\"\" self . column_kwarg_lookup = { 'default_kwargs' : { 'selectable' : True , }, } def create_table ( self , df_raw , columns = None , ** kwargs_datatable ): \"\"\"Create the dash_table.DataTable. Args: df_raw: data to pass to datatable columns: list of column names to display. Default is None to use all columns from df_raw kwargs_datatable: keyword arguments to pass to the datatable Returns: DataTable: returns dash_table.DataTable object \"\"\" if columns is None : columns = df_raw . columns return dash_table . DataTable ( ** self . _create_datatable ( df_raw , columns ), ** kwargs_datatable ) def format_datatable_columns ( self , df_raw , columns ): \"\"\"Return a list of column names formatted for a dash_table. Uses `self.self.column_name_kwarg_lookup`. Args: df_raw: data to pass to datatable columns: list of strings or None Returns: list: of dict with keys `(name, id, deleteable, selectable)` in order of df_raw columns \"\"\" return [ { 'name' : col , 'id' : col , ** self . column_kwarg_lookup . get ( col , self . column_kwarg_lookup [ 'default_kwargs' ])} for col in df_raw . columns if ( columns is None or col in columns ) ] def _create_datatable ( self , df_raw , columns , ** table_kwargs ): \"\"\"Return dictionary of keyword arguments for datatable. Args: df_raw: data to pass to datatable columns: will auto format list of string column names to display or use list of dicts table_kwargs: additional keyword arguments to pass to datatable, such as id Returns: dict: keys include `(columns, data)` and all data members \"\"\" return { 'columns' : self . format_datatable_columns ( df_raw , columns ) if isinstance ( columns [ 0 ], str ) else columns , 'data' : ( df_raw . loc [:, columns ] if columns is not None else df_raw ) . to_dict ( 'records' ), # Add all datamembers 'css' : self . css , 'style_table' : self . style_table , 'style_cell' : self . style_cell , 'style_cell_conditional' : self . style_cell_conditional , 'style_data' : self . style_data , 'style_data_conditional' : self . style_data_conditional , 'style_header' : self . style_header , 'style_header_conditional' : self . style_header_conditional , 'style_filter' : self . style_filter , 'style_filter_conditional' : self . style_filter_conditional , 'column_selectable' : self . column_selectable , 'export_format' : self . export_format , 'export_headers' : self . export_headers , 'filter_action' : self . filter_action , 'page_size' : self . page_size , 'row_selectable' : self . row_selectable , 'style_as_list_view' : self . style_as_list_view , 'sort_action' : self . sort_action , 'sort_mode' : self . sort_mode , } Class variables \u2693\ufe0e background_color Default background color. column_kwarg_lookup Lookup for keyword arguments for each column allowing deletable, selectable, etc. to be set per column. column_selectable DataTable.column_selectable. Default is None . css DataTable.css list. Use the style_* properties first. Set in initialize_mutables . Default sets row margin to zero to fix a negative margin issue when using dash_table and Bootstrap See: https://github.com/facultyai/dash-bootstrap-components/issues/334 Also sets other various style tweaks to highlight the filter icons on hover, etc. export_format DataTable.export_format. Default is 'none' . Could be one of (csv, xlsx) . export_headers DataTable.export_headers. Default is 'names' . See documentation. filter_action DataTable.filter_action. Default is 'native' . filter_summary Markdown text explaining dash_table.DataTable filtering rules with link to full documentation. page_size DataTable.page_size. Default is '25' . row_selectable DataTable.row_selectable. Default is None . selected_cell_color Default color for selected cells. sort_action DataTable.sort_action. Default is 'native' . sort_mode DataTable.sort_mode. Default is 'single' . style_as_list_view DataTable.style_as_list_view. Default is False. style_cell DataTable.style_cell dictionary. Default is empty dictionary. Set in initialize_mutables . style_cell_conditional DataTable.style_cell_conditional list. Default is empty list. Set in initialize_mutables . style_data DataTable.style_data dictionary. Default is empty dictionary. Set in initialize_mutables . style_data_conditional DataTable.style_data_conditional list. Default is for odd rows to have an off-white background (zebra stripe). Set in initialize_mutables style_filter DataTable.style_filter dictionary. Default is empty dictionary. Set in initialize_mutables . style_filter_conditional DataTable.style_filter_conditional list. Default is empty list. Set in initialize_mutables . style_header DataTable.style_header dictionary. Default is bold and off-white background. Set in initialize_mutables . style_header_conditional DataTable.style_header_conditional list. Default is empty list. Set in initialize_mutables . style_table DataTable.style_table dictionary. Default enables overflowX scroll. Set in initialize_mutables . text_color Default text color. zebra_color Default background color for odd rows (zebra-stripe). Methods \u2693\ufe0e create_table \u2693\ufe0e def create_table ( self , df_raw , columns = None , ** kwargs_datatable ) Create the dash_table.DataTable. Parameters: Name Description df_raw data to pass to datatable columns list of column names to display. Default is None to use all columns from df_raw kwargs_datatable keyword arguments to pass to the datatable Returns: Type Description DataTable returns dash_table.DataTable object View Source def create_table ( self , df_raw , columns = None , ** kwargs_datatable ): \"\"\"Create the dash_table.DataTable. Args: df_raw: data to pass to datatable columns: list of column names to display. Default is None to use all columns from df_raw kwargs_datatable: keyword arguments to pass to the datatable Returns: DataTable: returns dash_table.DataTable object \"\"\" if columns is None : columns = df_raw . columns return dash_table . DataTable ( ** self . _create_datatable ( df_raw , columns ), ** kwargs_datatable ) format_datatable_columns \u2693\ufe0e def format_datatable_columns ( self , df_raw , columns ) Return a list of column names formatted for a dash_table. Uses self.self.column_name_kwarg_lookup . Parameters: Name Description df_raw data to pass to datatable columns list of strings or None Returns: Type Description list of dict with keys (name, id, deleteable, selectable) in order of df_raw columns View Source def format_datatable_columns ( self , df_raw , columns ): \"\"\"Return a list of column names formatted for a dash_table. Uses `self.self.column_name_kwarg_lookup`. Args: df_raw: data to pass to datatable columns: list of strings or None Returns: list: of dict with keys `(name, id, deleteable, selectable)` in order of df_raw columns \"\"\" return [ { 'name' : col , 'id' : col , ** self . column_kwarg_lookup . get ( col , self . column_kwarg_lookup [ 'default_kwargs' ])} for col in df_raw . columns if ( columns is None or col in columns ) ] initialize_column_kwarg_lookup \u2693\ufe0e def initialize_column_kwarg_lookup ( self ) Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type View Source def initialize_column_kwarg_lookup ( self ): \"\"\"Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type \"\"\" self . column_kwarg_lookup = { 'default_kwargs' : { 'selectable' : True , }, } initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" self . style_table = { 'overflowX' : 'scroll' } self . css = [ # Fix width when overflow is True and using dash_bootstrap_components { 'selector' : '.row' , 'rule' : 'margin: 0' }, # Based on: https://community.plot.ly/t/dash-table-datatable-styling-examples/15594/ # Align the select icon to the left and the sort icon to the right { 'selector' : 'th.dash-header div' , 'rule' : 'display: flex; align-items: center;' , }, { 'selector' : 'th.dash-header div span.column-header--select' , 'rule' : 'order: 1; flex-shrink: 5; text-align: left;' , }, { 'selector' : 'th.dash-header div span.column-header-name' , 'rule' : 'order: 2; flex-grow: 5; text-align: center;' , }, { 'selector' : 'th.dash-header div span.column-header--sort' , 'rule' : 'order: 3; flex-shrink: 5; text-align: right;' , }, # Remove excess borders to better match JQuery DataTables styling # (Some border styles don't appear to work from `self.style_header`) { 'selector' : 'th.dash-filter' , 'rule' : 'border-bottom-color: rgb(17, 17, 17) !important;' }, ] self . style_cell = { 'backgroundColor' : self . background_color , 'borderStyle' : f '1px solid { self . zebra_color } ' , 'color' : self . text_color , } self . style_cell_conditional = [] self . style_data = {} self . style_data_conditional = [ { 'if' : { 'row_index' : 'even' }, 'backgroundColor' : self . zebra_color }, ] self . style_header = { 'borderLeft' : 'none' , 'borderRight' : 'none' , 'borderTop' : 'none' , 'fontWeight' : 'bold' , } self . style_header_conditional = [] self . style_filter = { 'borderBottomColor' : 'rgb(17, 17, 17)' , } self . style_filter_conditional = [] self . initialize_column_kwarg_lookup () # Must be called last","title":"dash_charts.datatable"},{"location":"modules/dash_charts/datatable/#dash_chartsdatatable","text":"DataTable Base Classes. View Source \"\"\"DataTable Base Classes.\"\"\" from dash import dash_table # TODO: See pattern mathing callbacks for adding buttons (to show modal) to datatables # https://dash.plotly.com/pattern-matching-callbacks # PLANNED: see conditional formatting: https://dash.plotly.com/datatable/conditional-formatting # PLANNED: These methods may be replaced in a future version of Dash # Currently, edge case when column is string, but filter could be a number # See: https://dash.plot.ly/datatable/callbacks & https://github.com/plotly/dash-table/issues/441 OPERATORS = [ [ 'ge ' , '>=' ], [ 'le ' , '<=' ], [ 'lt ' , '<' ], [ 'gt ' , '>' ], [ 'ne ' , '!=' ], [ 'eq ' , '=' ], [ 'contains ' ], [ 'datestartswith ' ], ] \"\"\"List of lists containing each possible filter string.\"\"\" def split_filter_part ( filter_part ): # noqa: CCR001 \"\"\"Split the filter into `(name, operator, value)` components. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: filter_part: string filter query Returns: tuple: `(name, operator, value)` which could be all None if no match was found \"\"\" for operator_type in OPERATORS : for operator in operator_type : if operator in filter_part : name_part , value_part = filter_part . split ( operator , 1 ) name = name_part [ name_part . find ( '{' ) + 1 : name_part . rfind ( '}' )] value_part = value_part . strip () v0 = value_part [ 0 ] if ( v0 == value_part [ - 1 ] and v0 in ( \"'\" , '\"' , '`' )): value = value_part [ 1 : - 1 ] . replace ( f ' \\\\ { v0 } ' , v0 ) else : try : value = float ( value_part ) except ValueError : value = value_part # Word operators need spaces after them in the filter string, but we don't want these later return ( name , operator_type [ 0 ] . strip (), value ) return [ None , None , None ] def apply_datatable_filters ( df_table , filter_query ): \"\"\"Filter a dataframe based on Dash datatable filterquery. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: df_table: pandas dataframe to filter filter_query: Dash datatable string filter query Returns: dataframe: filtered dataframe \"\"\" filtering_expressions = filter_query . split ( ' && ' ) for filter_part in filtering_expressions : col_name , operator , filter_value = split_filter_part ( filter_part ) if operator in ( 'eq' , 'ne' , 'lt' , 'le' , 'gt' , 'ge' ): # these operators match pandas series operator method names df_table = df_table . loc [ getattr ( df_table [ col_name ], operator )( filter_value )] elif operator == 'contains' : df_table = df_table . loc [ df_table [ col_name ] . str . contains ( filter_value )] elif operator == 'datestartswith' : # this is a simplification of the front-end filtering logic, # only works with complete fields in standard format df_table = df_table . loc [ df_table [ col_name ] . str . startswith ( filter_value )] return df_table # PLANNED: Maybe move parameters to attr.ib classes? class BaseDataTable : # noqa: H601 \"\"\"Base Class for Data Tables.\"\"\" filter_summary = \"\"\"Table Filter Syntax: Full documentation at: [https://dash.plot.ly/datatable/filtering](https://dash.plot.ly/datatable/filtering) - `eq`: exact match (applies to number columns and will try to convert string to number) - `contains`: search for exact (case-sensitive) substring in each cell - `datestartswith`: matches partial datetime. For example, datestartswith `2018-03-01` will match `2018-03-01 12:59` but not `2018-03` - `ne`, `gt`, `ge`, `lt`, `le`: comparison operators for not equal, greater than, greater or equal, less than, etc. Applies to numbers and string columns (uses numbers, symbols, uppercase letter, lowercase letters) Press enter of tab to apply the filter\"\"\" \"\"\"Markdown text explaining dash_table.DataTable filtering rules with link to full documentation.\"\"\" # dash_table.DataTable Parameters. Documentation: https://dash.plot.ly/datatable/reference style_table = None \"\"\"DataTable.style_table dictionary. Default enables overflowX scroll. Set in `initialize_mutables`.\"\"\" css = None \"\"\"DataTable.css list. Use the style_* properties first. Set in `initialize_mutables`. Default sets row margin to zero to fix a negative margin issue when using dash_table and Bootstrap See: https://github.com/facultyai/dash-bootstrap-components/issues/334 Also sets other various style tweaks to highlight the filter icons on hover, etc. \"\"\" style_cell = None \"\"\"DataTable.style_cell dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_cell_conditional = None \"\"\"DataTable.style_cell_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_data = None \"\"\"DataTable.style_data dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_data_conditional = None \"\"\"DataTable.style_data_conditional list. Default is for odd rows to have an off-white background (zebra stripe). Set in `initialize_mutables` \"\"\" style_header = None \"\"\"DataTable.style_header dictionary. Default is bold and off-white background. Set in `initialize_mutables`.\"\"\" style_header_conditional = None \"\"\"DataTable.style_header_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_filter = None \"\"\"DataTable.style_filter dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_filter_conditional = None \"\"\"DataTable.style_filter_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" column_selectable = None \"\"\"DataTable.column_selectable. Default is `None`.\"\"\" column_kwarg_lookup = None \"\"\"Lookup for keyword arguments for each column allowing deletable, selectable, etc. to be set per column.\"\"\" export_format = 'none' \"\"\"DataTable.export_format. Default is `'none'`. Could be one of `(csv, xlsx)`.\"\"\" export_headers = 'names' \"\"\"DataTable.export_headers. Default is `'names'`. See documentation.\"\"\" filter_action = 'native' \"\"\"DataTable.filter_action. Default is `'native'`.\"\"\" page_size = 25 \"\"\"DataTable.page_size. Default is `'25'`.\"\"\" row_selectable = None \"\"\"DataTable.row_selectable. Default is `None`.\"\"\" style_as_list_view = False \"\"\"DataTable.style_as_list_view. Default is False.\"\"\" sort_action = 'native' \"\"\"DataTable.sort_action. Default is `'native'`.\"\"\" sort_mode = 'single' \"\"\"DataTable.sort_mode. Default is `'single'`.\"\"\" # CSS Variables text_color = '#333333' \"\"\"Default text color.\"\"\" background_color = '#ffffff' \"\"\"Default background color.\"\"\" zebra_color = '#f9f9f9' \"\"\"Default background color for odd rows (zebra-stripe).\"\"\" selected_cell_color = '#eaeaea' \"\"\"Default color for selected cells.\"\"\" def __init__ ( self ): \"\"\"Initialize class.\"\"\" self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" self . style_table = { 'overflowX' : 'scroll' } self . css = [ # Fix width when overflow is True and using dash_bootstrap_components { 'selector' : '.row' , 'rule' : 'margin: 0' }, # Based on: https://community.plot.ly/t/dash-table-datatable-styling-examples/15594/ # Align the select icon to the left and the sort icon to the right { 'selector' : 'th.dash-header div' , 'rule' : 'display: flex; align-items: center;' , }, { 'selector' : 'th.dash-header div span.column-header--select' , 'rule' : 'order: 1; flex-shrink: 5; text-align: left;' , }, { 'selector' : 'th.dash-header div span.column-header-name' , 'rule' : 'order: 2; flex-grow: 5; text-align: center;' , }, { 'selector' : 'th.dash-header div span.column-header--sort' , 'rule' : 'order: 3; flex-shrink: 5; text-align: right;' , }, # Remove excess borders to better match JQuery DataTables styling # (Some border styles don't appear to work from `self.style_header`) { 'selector' : 'th.dash-filter' , 'rule' : 'border-bottom-color: rgb(17, 17, 17) !important;' }, ] self . style_cell = { 'backgroundColor' : self . background_color , 'borderStyle' : f '1px solid { self . zebra_color } ' , 'color' : self . text_color , } self . style_cell_conditional = [] self . style_data = {} self . style_data_conditional = [ { 'if' : { 'row_index' : 'even' }, 'backgroundColor' : self . zebra_color }, ] self . style_header = { 'borderLeft' : 'none' , 'borderRight' : 'none' , 'borderTop' : 'none' , 'fontWeight' : 'bold' , } self . style_header_conditional = [] self . style_filter = { 'borderBottomColor' : 'rgb(17, 17, 17)' , } self . style_filter_conditional = [] self . initialize_column_kwarg_lookup () # Must be called last def initialize_column_kwarg_lookup ( self ): \"\"\"Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type \"\"\" self . column_kwarg_lookup = { 'default_kwargs' : { 'selectable' : True , }, } def create_table ( self , df_raw , columns = None , ** kwargs_datatable ): \"\"\"Create the dash_table.DataTable. Args: df_raw: data to pass to datatable columns: list of column names to display. Default is None to use all columns from df_raw kwargs_datatable: keyword arguments to pass to the datatable Returns: DataTable: returns dash_table.DataTable object \"\"\" if columns is None : columns = df_raw . columns return dash_table . DataTable ( ** self . _create_datatable ( df_raw , columns ), ** kwargs_datatable ) def format_datatable_columns ( self , df_raw , columns ): \"\"\"Return a list of column names formatted for a dash_table. Uses `self.self.column_name_kwarg_lookup`. Args: df_raw: data to pass to datatable columns: list of strings or None Returns: list: of dict with keys `(name, id, deleteable, selectable)` in order of df_raw columns \"\"\" return [ { 'name' : col , 'id' : col , ** self . column_kwarg_lookup . get ( col , self . column_kwarg_lookup [ 'default_kwargs' ])} for col in df_raw . columns if ( columns is None or col in columns ) ] def _create_datatable ( self , df_raw , columns , ** table_kwargs ): \"\"\"Return dictionary of keyword arguments for datatable. Args: df_raw: data to pass to datatable columns: will auto format list of string column names to display or use list of dicts table_kwargs: additional keyword arguments to pass to datatable, such as id Returns: dict: keys include `(columns, data)` and all data members \"\"\" return { 'columns' : self . format_datatable_columns ( df_raw , columns ) if isinstance ( columns [ 0 ], str ) else columns , 'data' : ( df_raw . loc [:, columns ] if columns is not None else df_raw ) . to_dict ( 'records' ), # Add all datamembers 'css' : self . css , 'style_table' : self . style_table , 'style_cell' : self . style_cell , 'style_cell_conditional' : self . style_cell_conditional , 'style_data' : self . style_data , 'style_data_conditional' : self . style_data_conditional , 'style_header' : self . style_header , 'style_header_conditional' : self . style_header_conditional , 'style_filter' : self . style_filter , 'style_filter_conditional' : self . style_filter_conditional , 'column_selectable' : self . column_selectable , 'export_format' : self . export_format , 'export_headers' : self . export_headers , 'filter_action' : self . filter_action , 'page_size' : self . page_size , 'row_selectable' : self . row_selectable , 'style_as_list_view' : self . style_as_list_view , 'sort_action' : self . sort_action , 'sort_mode' : self . sort_mode , }","title":"dash_charts.datatable"},{"location":"modules/dash_charts/datatable/#variables","text":"OPERATORS List of lists containing each possible filter string.","title":"Variables"},{"location":"modules/dash_charts/datatable/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/datatable/#apply_datatable_filters","text":"def apply_datatable_filters ( df_table , filter_query ) Filter a dataframe based on Dash datatable filterquery. Based on Backend Paging with Filtering : https://dash.plot.ly/datatable/callbacks Parameters: Name Description df_table pandas dataframe to filter filter_query Dash datatable string filter query Returns: Type Description dataframe filtered dataframe View Source def apply_datatable_filters ( df_table , filter_query ): \"\"\"Filter a dataframe based on Dash datatable filterquery. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: df_table: pandas dataframe to filter filter_query: Dash datatable string filter query Returns: dataframe: filtered dataframe \"\"\" filtering_expressions = filter_query . split ( ' && ' ) for filter_part in filtering_expressions : col_name , operator , filter_value = split_filter_part ( filter_part ) if operator in ( 'eq' , 'ne' , 'lt' , 'le' , 'gt' , 'ge' ): # these operators match pandas series operator method names df_table = df_table . loc [ getattr ( df_table [ col_name ], operator )( filter_value )] elif operator == 'contains' : df_table = df_table . loc [ df_table [ col_name ] . str . contains ( filter_value )] elif operator == 'datestartswith' : # this is a simplification of the front-end filtering logic, # only works with complete fields in standard format df_table = df_table . loc [ df_table [ col_name ] . str . startswith ( filter_value )] return df_table","title":"apply_datatable_filters"},{"location":"modules/dash_charts/datatable/#split_filter_part","text":"def split_filter_part ( filter_part ) Split the filter into (name, operator, value) components. Based on Backend Paging with Filtering : https://dash.plot.ly/datatable/callbacks Parameters: Name Description filter_part string filter query Returns: Type Description tuple (name, operator, value) which could be all None if no match was found View Source def split_filter_part ( filter_part ): # noqa: CCR001 \"\"\"Split the filter into `(name, operator, value)` components. Based on `Backend Paging with Filtering`: https://dash.plot.ly/datatable/callbacks Args: filter_part: string filter query Returns: tuple: `(name, operator, value)` which could be all None if no match was found \"\"\" for operator_type in OPERATORS : for operator in operator_type : if operator in filter_part : name_part , value_part = filter_part . split ( operator , 1 ) name = name_part [ name_part . find ( '{' ) + 1 : name_part . rfind ( '}' )] value_part = value_part . strip () v0 = value_part [ 0 ] if ( v0 == value_part [ - 1 ] and v0 in ( \"'\" , '\"' , '`' )): value = value_part [ 1 : - 1 ] . replace ( f ' \\\\ { v0 } ' , v0 ) else : try : value = float ( value_part ) except ValueError : value = value_part # Word operators need spaces after them in the filter string, but we don't want these later return ( name , operator_type [ 0 ] . strip (), value ) return [ None , None , None ]","title":"split_filter_part"},{"location":"modules/dash_charts/datatable/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/datatable/#basedatatable","text":"class BaseDataTable ( ) View Source class BaseDataTable : # noqa: H601 \"\"\"Base Class for Data Tables.\"\"\" filter_summary = \"\"\"Table Filter Syntax: Full documentation at: [https://dash.plot.ly/datatable/filtering](https://dash.plot.ly/datatable/filtering) - `eq`: exact match (applies to number columns and will try to convert string to number) - `contains`: search for exact (case-sensitive) substring in each cell - `datestartswith`: matches partial datetime. For example, datestartswith `2018-03-01` will match `2018-03-01 12:59` but not `2018-03` - `ne`, `gt`, `ge`, `lt`, `le`: comparison operators for not equal, greater than, greater or equal, less than, etc. Applies to numbers and string columns (uses numbers, symbols, uppercase letter, lowercase letters) Press enter of tab to apply the filter\"\"\" \"\"\"Markdown text explaining dash_table.DataTable filtering rules with link to full documentation.\"\"\" # dash_table.DataTable Parameters. Documentation: https://dash.plot.ly/datatable/reference style_table = None \"\"\"DataTable.style_table dictionary. Default enables overflowX scroll. Set in `initialize_mutables`.\"\"\" css = None \"\"\"DataTable.css list. Use the style_* properties first. Set in `initialize_mutables`. Default sets row margin to zero to fix a negative margin issue when using dash_table and Bootstrap See: https://github.com/facultyai/dash-bootstrap-components/issues/334 Also sets other various style tweaks to highlight the filter icons on hover, etc. \"\"\" style_cell = None \"\"\"DataTable.style_cell dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_cell_conditional = None \"\"\"DataTable.style_cell_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_data = None \"\"\"DataTable.style_data dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_data_conditional = None \"\"\"DataTable.style_data_conditional list. Default is for odd rows to have an off-white background (zebra stripe). Set in `initialize_mutables` \"\"\" style_header = None \"\"\"DataTable.style_header dictionary. Default is bold and off-white background. Set in `initialize_mutables`.\"\"\" style_header_conditional = None \"\"\"DataTable.style_header_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" style_filter = None \"\"\"DataTable.style_filter dictionary. Default is empty dictionary. Set in `initialize_mutables`.\"\"\" style_filter_conditional = None \"\"\"DataTable.style_filter_conditional list. Default is empty list. Set in `initialize_mutables`.\"\"\" column_selectable = None \"\"\"DataTable.column_selectable. Default is `None`.\"\"\" column_kwarg_lookup = None \"\"\"Lookup for keyword arguments for each column allowing deletable, selectable, etc. to be set per column.\"\"\" export_format = 'none' \"\"\"DataTable.export_format. Default is `'none'`. Could be one of `(csv, xlsx)`.\"\"\" export_headers = 'names' \"\"\"DataTable.export_headers. Default is `'names'`. See documentation.\"\"\" filter_action = 'native' \"\"\"DataTable.filter_action. Default is `'native'`.\"\"\" page_size = 25 \"\"\"DataTable.page_size. Default is `'25'`.\"\"\" row_selectable = None \"\"\"DataTable.row_selectable. Default is `None`.\"\"\" style_as_list_view = False \"\"\"DataTable.style_as_list_view. Default is False.\"\"\" sort_action = 'native' \"\"\"DataTable.sort_action. Default is `'native'`.\"\"\" sort_mode = 'single' \"\"\"DataTable.sort_mode. Default is `'single'`.\"\"\" # CSS Variables text_color = '#333333' \"\"\"Default text color.\"\"\" background_color = '#ffffff' \"\"\"Default background color.\"\"\" zebra_color = '#f9f9f9' \"\"\"Default background color for odd rows (zebra-stripe).\"\"\" selected_cell_color = '#eaeaea' \"\"\"Default color for selected cells.\"\"\" def __init__ ( self ): \"\"\"Initialize class.\"\"\" self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" self . style_table = { 'overflowX' : 'scroll' } self . css = [ # Fix width when overflow is True and using dash_bootstrap_components { 'selector' : '.row' , 'rule' : 'margin: 0' }, # Based on: https://community.plot.ly/t/dash-table-datatable-styling-examples/15594/ # Align the select icon to the left and the sort icon to the right { 'selector' : 'th.dash-header div' , 'rule' : 'display: flex; align-items: center;' , }, { 'selector' : 'th.dash-header div span.column-header--select' , 'rule' : 'order: 1; flex-shrink: 5; text-align: left;' , }, { 'selector' : 'th.dash-header div span.column-header-name' , 'rule' : 'order: 2; flex-grow: 5; text-align: center;' , }, { 'selector' : 'th.dash-header div span.column-header--sort' , 'rule' : 'order: 3; flex-shrink: 5; text-align: right;' , }, # Remove excess borders to better match JQuery DataTables styling # (Some border styles don't appear to work from `self.style_header`) { 'selector' : 'th.dash-filter' , 'rule' : 'border-bottom-color: rgb(17, 17, 17) !important;' }, ] self . style_cell = { 'backgroundColor' : self . background_color , 'borderStyle' : f '1px solid { self . zebra_color } ' , 'color' : self . text_color , } self . style_cell_conditional = [] self . style_data = {} self . style_data_conditional = [ { 'if' : { 'row_index' : 'even' }, 'backgroundColor' : self . zebra_color }, ] self . style_header = { 'borderLeft' : 'none' , 'borderRight' : 'none' , 'borderTop' : 'none' , 'fontWeight' : 'bold' , } self . style_header_conditional = [] self . style_filter = { 'borderBottomColor' : 'rgb(17, 17, 17)' , } self . style_filter_conditional = [] self . initialize_column_kwarg_lookup () # Must be called last def initialize_column_kwarg_lookup ( self ): \"\"\"Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type \"\"\" self . column_kwarg_lookup = { 'default_kwargs' : { 'selectable' : True , }, } def create_table ( self , df_raw , columns = None , ** kwargs_datatable ): \"\"\"Create the dash_table.DataTable. Args: df_raw: data to pass to datatable columns: list of column names to display. Default is None to use all columns from df_raw kwargs_datatable: keyword arguments to pass to the datatable Returns: DataTable: returns dash_table.DataTable object \"\"\" if columns is None : columns = df_raw . columns return dash_table . DataTable ( ** self . _create_datatable ( df_raw , columns ), ** kwargs_datatable ) def format_datatable_columns ( self , df_raw , columns ): \"\"\"Return a list of column names formatted for a dash_table. Uses `self.self.column_name_kwarg_lookup`. Args: df_raw: data to pass to datatable columns: list of strings or None Returns: list: of dict with keys `(name, id, deleteable, selectable)` in order of df_raw columns \"\"\" return [ { 'name' : col , 'id' : col , ** self . column_kwarg_lookup . get ( col , self . column_kwarg_lookup [ 'default_kwargs' ])} for col in df_raw . columns if ( columns is None or col in columns ) ] def _create_datatable ( self , df_raw , columns , ** table_kwargs ): \"\"\"Return dictionary of keyword arguments for datatable. Args: df_raw: data to pass to datatable columns: will auto format list of string column names to display or use list of dicts table_kwargs: additional keyword arguments to pass to datatable, such as id Returns: dict: keys include `(columns, data)` and all data members \"\"\" return { 'columns' : self . format_datatable_columns ( df_raw , columns ) if isinstance ( columns [ 0 ], str ) else columns , 'data' : ( df_raw . loc [:, columns ] if columns is not None else df_raw ) . to_dict ( 'records' ), # Add all datamembers 'css' : self . css , 'style_table' : self . style_table , 'style_cell' : self . style_cell , 'style_cell_conditional' : self . style_cell_conditional , 'style_data' : self . style_data , 'style_data_conditional' : self . style_data_conditional , 'style_header' : self . style_header , 'style_header_conditional' : self . style_header_conditional , 'style_filter' : self . style_filter , 'style_filter_conditional' : self . style_filter_conditional , 'column_selectable' : self . column_selectable , 'export_format' : self . export_format , 'export_headers' : self . export_headers , 'filter_action' : self . filter_action , 'page_size' : self . page_size , 'row_selectable' : self . row_selectable , 'style_as_list_view' : self . style_as_list_view , 'sort_action' : self . sort_action , 'sort_mode' : self . sort_mode , }","title":"BaseDataTable"},{"location":"modules/dash_charts/datatable/#class-variables","text":"background_color Default background color. column_kwarg_lookup Lookup for keyword arguments for each column allowing deletable, selectable, etc. to be set per column. column_selectable DataTable.column_selectable. Default is None . css DataTable.css list. Use the style_* properties first. Set in initialize_mutables . Default sets row margin to zero to fix a negative margin issue when using dash_table and Bootstrap See: https://github.com/facultyai/dash-bootstrap-components/issues/334 Also sets other various style tweaks to highlight the filter icons on hover, etc. export_format DataTable.export_format. Default is 'none' . Could be one of (csv, xlsx) . export_headers DataTable.export_headers. Default is 'names' . See documentation. filter_action DataTable.filter_action. Default is 'native' . filter_summary Markdown text explaining dash_table.DataTable filtering rules with link to full documentation. page_size DataTable.page_size. Default is '25' . row_selectable DataTable.row_selectable. Default is None . selected_cell_color Default color for selected cells. sort_action DataTable.sort_action. Default is 'native' . sort_mode DataTable.sort_mode. Default is 'single' . style_as_list_view DataTable.style_as_list_view. Default is False. style_cell DataTable.style_cell dictionary. Default is empty dictionary. Set in initialize_mutables . style_cell_conditional DataTable.style_cell_conditional list. Default is empty list. Set in initialize_mutables . style_data DataTable.style_data dictionary. Default is empty dictionary. Set in initialize_mutables . style_data_conditional DataTable.style_data_conditional list. Default is for odd rows to have an off-white background (zebra stripe). Set in initialize_mutables style_filter DataTable.style_filter dictionary. Default is empty dictionary. Set in initialize_mutables . style_filter_conditional DataTable.style_filter_conditional list. Default is empty list. Set in initialize_mutables . style_header DataTable.style_header dictionary. Default is bold and off-white background. Set in initialize_mutables . style_header_conditional DataTable.style_header_conditional list. Default is empty list. Set in initialize_mutables . style_table DataTable.style_table dictionary. Default enables overflowX scroll. Set in initialize_mutables . text_color Default text color. zebra_color Default background color for odd rows (zebra-stripe).","title":"Class variables"},{"location":"modules/dash_charts/datatable/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/datatable/#create_table","text":"def create_table ( self , df_raw , columns = None , ** kwargs_datatable ) Create the dash_table.DataTable. Parameters: Name Description df_raw data to pass to datatable columns list of column names to display. Default is None to use all columns from df_raw kwargs_datatable keyword arguments to pass to the datatable Returns: Type Description DataTable returns dash_table.DataTable object View Source def create_table ( self , df_raw , columns = None , ** kwargs_datatable ): \"\"\"Create the dash_table.DataTable. Args: df_raw: data to pass to datatable columns: list of column names to display. Default is None to use all columns from df_raw kwargs_datatable: keyword arguments to pass to the datatable Returns: DataTable: returns dash_table.DataTable object \"\"\" if columns is None : columns = df_raw . columns return dash_table . DataTable ( ** self . _create_datatable ( df_raw , columns ), ** kwargs_datatable )","title":"create_table"},{"location":"modules/dash_charts/datatable/#format_datatable_columns","text":"def format_datatable_columns ( self , df_raw , columns ) Return a list of column names formatted for a dash_table. Uses self.self.column_name_kwarg_lookup . Parameters: Name Description df_raw data to pass to datatable columns list of strings or None Returns: Type Description list of dict with keys (name, id, deleteable, selectable) in order of df_raw columns View Source def format_datatable_columns ( self , df_raw , columns ): \"\"\"Return a list of column names formatted for a dash_table. Uses `self.self.column_name_kwarg_lookup`. Args: df_raw: data to pass to datatable columns: list of strings or None Returns: list: of dict with keys `(name, id, deleteable, selectable)` in order of df_raw columns \"\"\" return [ { 'name' : col , 'id' : col , ** self . column_kwarg_lookup . get ( col , self . column_kwarg_lookup [ 'default_kwargs' ])} for col in df_raw . columns if ( columns is None or col in columns ) ]","title":"format_datatable_columns"},{"location":"modules/dash_charts/datatable/#initialize_column_kwarg_lookup","text":"def initialize_column_kwarg_lookup ( self ) Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type View Source def initialize_column_kwarg_lookup ( self ): \"\"\"Initialize the column lookup based on the other mutables. Documentation: https://dash.plot.ly/datatable/reference Additional kwargs not set in default lookup: - clearable, deletable, editable, hideable, renamable, format, presentation, on_change, sort_as_null, validation, type \"\"\" self . column_kwarg_lookup = { 'default_kwargs' : { 'selectable' : True , }, }","title":"initialize_column_kwarg_lookup"},{"location":"modules/dash_charts/datatable/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" self . style_table = { 'overflowX' : 'scroll' } self . css = [ # Fix width when overflow is True and using dash_bootstrap_components { 'selector' : '.row' , 'rule' : 'margin: 0' }, # Based on: https://community.plot.ly/t/dash-table-datatable-styling-examples/15594/ # Align the select icon to the left and the sort icon to the right { 'selector' : 'th.dash-header div' , 'rule' : 'display: flex; align-items: center;' , }, { 'selector' : 'th.dash-header div span.column-header--select' , 'rule' : 'order: 1; flex-shrink: 5; text-align: left;' , }, { 'selector' : 'th.dash-header div span.column-header-name' , 'rule' : 'order: 2; flex-grow: 5; text-align: center;' , }, { 'selector' : 'th.dash-header div span.column-header--sort' , 'rule' : 'order: 3; flex-shrink: 5; text-align: right;' , }, # Remove excess borders to better match JQuery DataTables styling # (Some border styles don't appear to work from `self.style_header`) { 'selector' : 'th.dash-filter' , 'rule' : 'border-bottom-color: rgb(17, 17, 17) !important;' }, ] self . style_cell = { 'backgroundColor' : self . background_color , 'borderStyle' : f '1px solid { self . zebra_color } ' , 'color' : self . text_color , } self . style_cell_conditional = [] self . style_data = {} self . style_data_conditional = [ { 'if' : { 'row_index' : 'even' }, 'backgroundColor' : self . zebra_color }, ] self . style_header = { 'borderLeft' : 'none' , 'borderRight' : 'none' , 'borderTop' : 'none' , 'fontWeight' : 'bold' , } self . style_header_conditional = [] self . style_filter = { 'borderBottomColor' : 'rgb(17, 17, 17)' , } self . style_filter_conditional = [] self . initialize_column_kwarg_lookup () # Must be called last","title":"initialize_mutables"},{"location":"modules/dash_charts/equations/","text":"dash_charts.equations \u2693\ufe0e Equations used in scipy fit calculations. View Source \"\"\"Equations used in scipy fit calculations.\"\"\" import numpy as np def linear ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of linear equation with factors of a and b. `y = a * x + b` Args: x_values: single number of list of numbers factor_a: number, slope factor_b: number, intercept Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , x_values ), factor_b , ) def quadratic ( x_values , factor_a , factor_b , factor_c ): \"\"\"Return result(s) of quadratic equation with factors of a, b, and c. `y = a * x^2 + b * x + c` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , np . power ( x_values , 2 ), ), np . add ( np . multiply ( factor_b , x_values ), factor_c , ), ) def power ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of quadratic equation with factors of a and b. `y = a * x^b` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . power ( np . array ( x_values ) . astype ( float ), factor_b , ), ) def exponential ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of exponential equation with factors of a and b. `y = a * e^(b * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ) def double_exponential ( x_values , factor_a , factor_b , factor_c , factor_d ): \"\"\"Return result(s) of a double exponential equation with factors of a, b, c, and d. `y = a * e^(b * x) - c * e^(d * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number factor_d: number Returns: y_values: as list or single digit \"\"\" return np . subtract ( np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ), np . multiply ( factor_c , np . exp ( np . multiply ( factor_d , x_values ), ), ), ) Functions \u2693\ufe0e double_exponential \u2693\ufe0e def double_exponential ( x_values , factor_a , factor_b , factor_c , factor_d ) Return result(s) of a double exponential equation with factors of a, b, c, and d. y = a * e^(b * x) - c * e^(d * x) Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number factor_c number factor_d number Returns: Type Description y_values as list or single digit View Source def double_exponential ( x_values , factor_a , factor_b , factor_c , factor_d ): \"\"\"Return result(s) of a double exponential equation with factors of a, b, c, and d. `y = a * e^(b * x) - c * e^(d * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number factor_d: number Returns: y_values: as list or single digit \"\"\" return np . subtract ( np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ), np . multiply ( factor_c , np . exp ( np . multiply ( factor_d , x_values ), ), ), ) exponential \u2693\ufe0e def exponential ( x_values , factor_a , factor_b ) Return result(s) of exponential equation with factors of a and b. y = a * e^(b * x) Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number Returns: Type Description y_values as list or single digit View Source def exponential ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of exponential equation with factors of a and b. `y = a * e^(b * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ) linear \u2693\ufe0e def linear ( x_values , factor_a , factor_b ) Return result(s) of linear equation with factors of a and b. y = a * x + b Parameters: Name Description x_values single number of list of numbers factor_a number, slope factor_b number, intercept Returns: Type Description y_values as list or single digit View Source def linear ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of linear equation with factors of a and b. `y = a * x + b` Args: x_values: single number of list of numbers factor_a: number, slope factor_b: number, intercept Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , x_values ), factor_b , ) power \u2693\ufe0e def power ( x_values , factor_a , factor_b ) Return result(s) of quadratic equation with factors of a and b. y = a * x^b Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number Returns: Type Description y_values as list or single digit View Source def power ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of quadratic equation with factors of a and b. `y = a * x^b` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . power ( np . array ( x_values ) . astype ( float ), factor_b , ), ) quadratic \u2693\ufe0e def quadratic ( x_values , factor_a , factor_b , factor_c ) Return result(s) of quadratic equation with factors of a, b, and c. y = a * x^2 + b * x + c Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number factor_c number Returns: Type Description y_values as list or single digit View Source def quadratic ( x_values , factor_a , factor_b , factor_c ): \"\"\"Return result(s) of quadratic equation with factors of a, b, and c. `y = a * x^2 + b * x + c` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , np . power ( x_values , 2 ), ), np . add ( np . multiply ( factor_b , x_values ), factor_c , ), )","title":"dash_charts.equations"},{"location":"modules/dash_charts/equations/#dash_chartsequations","text":"Equations used in scipy fit calculations. View Source \"\"\"Equations used in scipy fit calculations.\"\"\" import numpy as np def linear ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of linear equation with factors of a and b. `y = a * x + b` Args: x_values: single number of list of numbers factor_a: number, slope factor_b: number, intercept Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , x_values ), factor_b , ) def quadratic ( x_values , factor_a , factor_b , factor_c ): \"\"\"Return result(s) of quadratic equation with factors of a, b, and c. `y = a * x^2 + b * x + c` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , np . power ( x_values , 2 ), ), np . add ( np . multiply ( factor_b , x_values ), factor_c , ), ) def power ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of quadratic equation with factors of a and b. `y = a * x^b` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . power ( np . array ( x_values ) . astype ( float ), factor_b , ), ) def exponential ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of exponential equation with factors of a and b. `y = a * e^(b * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ) def double_exponential ( x_values , factor_a , factor_b , factor_c , factor_d ): \"\"\"Return result(s) of a double exponential equation with factors of a, b, c, and d. `y = a * e^(b * x) - c * e^(d * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number factor_d: number Returns: y_values: as list or single digit \"\"\" return np . subtract ( np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ), np . multiply ( factor_c , np . exp ( np . multiply ( factor_d , x_values ), ), ), )","title":"dash_charts.equations"},{"location":"modules/dash_charts/equations/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/equations/#double_exponential","text":"def double_exponential ( x_values , factor_a , factor_b , factor_c , factor_d ) Return result(s) of a double exponential equation with factors of a, b, c, and d. y = a * e^(b * x) - c * e^(d * x) Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number factor_c number factor_d number Returns: Type Description y_values as list or single digit View Source def double_exponential ( x_values , factor_a , factor_b , factor_c , factor_d ): \"\"\"Return result(s) of a double exponential equation with factors of a, b, c, and d. `y = a * e^(b * x) - c * e^(d * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number factor_d: number Returns: y_values: as list or single digit \"\"\" return np . subtract ( np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), ), np . multiply ( factor_c , np . exp ( np . multiply ( factor_d , x_values ), ), ), )","title":"double_exponential"},{"location":"modules/dash_charts/equations/#exponential","text":"def exponential ( x_values , factor_a , factor_b ) Return result(s) of exponential equation with factors of a and b. y = a * e^(b * x) Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number Returns: Type Description y_values as list or single digit View Source def exponential ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of exponential equation with factors of a and b. `y = a * e^(b * x)` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . exp ( np . multiply ( factor_b , x_values ), ), )","title":"exponential"},{"location":"modules/dash_charts/equations/#linear","text":"def linear ( x_values , factor_a , factor_b ) Return result(s) of linear equation with factors of a and b. y = a * x + b Parameters: Name Description x_values single number of list of numbers factor_a number, slope factor_b number, intercept Returns: Type Description y_values as list or single digit View Source def linear ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of linear equation with factors of a and b. `y = a * x + b` Args: x_values: single number of list of numbers factor_a: number, slope factor_b: number, intercept Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , x_values ), factor_b , )","title":"linear"},{"location":"modules/dash_charts/equations/#power","text":"def power ( x_values , factor_a , factor_b ) Return result(s) of quadratic equation with factors of a and b. y = a * x^b Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number Returns: Type Description y_values as list or single digit View Source def power ( x_values , factor_a , factor_b ): \"\"\"Return result(s) of quadratic equation with factors of a and b. `y = a * x^b` Args: x_values: single number of list of numbers factor_a: number factor_b: number Returns: y_values: as list or single digit \"\"\" return np . multiply ( factor_a , np . power ( np . array ( x_values ) . astype ( float ), factor_b , ), )","title":"power"},{"location":"modules/dash_charts/equations/#quadratic","text":"def quadratic ( x_values , factor_a , factor_b , factor_c ) Return result(s) of quadratic equation with factors of a, b, and c. y = a * x^2 + b * x + c Parameters: Name Description x_values single number of list of numbers factor_a number factor_b number factor_c number Returns: Type Description y_values as list or single digit View Source def quadratic ( x_values , factor_a , factor_b , factor_c ): \"\"\"Return result(s) of quadratic equation with factors of a, b, and c. `y = a * x^2 + b * x + c` Args: x_values: single number of list of numbers factor_a: number factor_b: number factor_c: number Returns: y_values: as list or single digit \"\"\" return np . add ( np . multiply ( factor_a , np . power ( x_values , 2 ), ), np . add ( np . multiply ( factor_b , x_values ), factor_c , ), )","title":"quadratic"},{"location":"modules/dash_charts/gantt_chart/","text":"dash_charts.gantt_chart \u2693\ufe0e Gantt Chart. Note: does not support resources nor task dependencies; however those could be added by extending this base class. Removed Code \u2693\ufe0e # Just snippets of Python code that may be useful in the future dates = sorted ( set ( filter ( None , df_raw [ 'start' ] . to_list () + df_raw [ 'end' ] . to_list ()))) self . axis_range = { 'x' : [ dates [ 0 ], dates [ - 1 ]]} View Source \"\"\"Gantt Chart. Note: does not support resources nor task dependencies; however those could be added by extending this base class. # Removed Code ```py # Just snippets of Python code that may be useful in the future dates = sorted(set(filter(None, df_raw['start'].to_list() + df_raw['end'].to_list()))) self.axis_range = {'x': [dates[0], dates[-1]]} \u201d\u201c\u201d import plotly.graph_objects as go from palettable.tableau import TableauMedium_10 from .utils_data import format_unix, get_unix from .utils_fig import CustomChart class GanttChart(CustomChart): # noqa: H601 \u201c\u201d\u201cGantt Chart: task and milestone timeline.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 date_format = '%Y-%m-%d' \"\"\"Date format for bar chart.\"\"\" pallette = TableauMedium_10 . hex_colors \"\"\"Default color pallette for project colors.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular task.\"\"\" def create_traces ( self , df_raw ) : \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end, progress)` Returns: list: Dash chart traces \"\"\" # If start is None , assign end to start so that the sort is correct start_index = df_raw . columns . get_loc ( 'start' ) end_index = df_raw . columns . get_loc ( 'end' ) for index in [ idx for idx, is_na in enumerate(df_raw['start' ] . isna ()) if is_na ]: df_raw . iloc [ index, start_index ] = df_raw . iloc [ index, end_index ] df_raw [ 'progress' ] = df_raw [ 'progress' ] . fillna ( 0 ) # Fill possibly missing progress values for milestones df_raw = ( df_raw . sort_values ( by =[ 'category', 'start' ] , ascending = False ) . sort_values ( by =[ 'end' ] , ascending = False ) . reset_index ( drop = True ) ) # Create color lookup using categories in sorted order categories = set ( df_raw [ 'category' ] ) self . color_lookup = { cat : self . pallette [ idx ] for idx , cat in enumerate ( categories ) } # Track which categories have been plotted plotted_categories = [] # Create the Gantt traces traces = [] for task in df_raw . itertuples () : y_pos = task . Index is_first = task . category not in plotted_categories plotted_categories . append ( task . category ) traces . append ( self . _create_task_shape ( task , y_pos , is_first )) if task . progress > 0 : traces . append ( self . _create_progress_shape ( task , y_pos )) traces . append ( self . _create_annotation ( task , y_pos )) return traces def _create_hover_text ( self , task ) : \"\"\"Return hover text for given trace. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` Returns: string: HTML-formatted hover text \"\"\" dates = [ format_unix(get_unix(str_ts, self.date_format), '%a, %d%b%Y') for str_ts in [task.start, task.end ] ] if task . start != task . end : date_range = f '<br><b>Start</b>: {dates[0]}<br><b>End</b>: {dates[1]}' else : date_range = f '<br><b>Milestone</b>: {dates[1]}' return f '<b>{task.category}</b><br>{task.label} ({int(task.progress * 100)}%)<br>{date_range}' def _create_task_shape ( self , task , y_pos , is_first ) : \"\"\"Create colored task scatter rectangle. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task is_first: if True, this is the first time a task of this category will be plotted Returns: trace: single Dash chart Scatter trace \"\"\" color = self . color_lookup [ task.category ] scatter_kwargs = { 'fill' : 'toself' , 'fillcolor' : color , 'hoverlabel' : self . hover_label_settings , 'legendgroup' : color , 'line' : { 'width' : 1 } , 'marker' : { 'color' : color } , 'mode' : 'lines' , 'showlegend' : is_first , 'text' : self . _create_hover_text ( task ), 'x' : [ task.start, task.end, task.end, task.start, task.start ] , 'y' : [ y_pos, y_pos, y_pos - self.rh, y_pos - self.rh, y_pos ] , } if is_first : scatter_kwargs [ 'name' ] = task . category return go . Scatter ( ** scatter_kwargs ) def _create_progress_shape ( self , task , y_pos ) : \"\"\"Create semi-transparent white overlay `self.shapes` to indicate task progress. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" unix_start = get_unix ( task . start , self . date_format ) unix_progress = ( get_unix ( task . end , self . date_format ) - unix_start ) * task . progress + unix_start end = format_unix ( unix_progress , self . date_format ) return go . Scatter ( fill = 'toself' , fillcolor = 'white' , hoverinfo = 'skip' , legendgroup = self . color_lookup [ task.category ] , line = { 'width' : 1 } , marker = { 'color' : 'white' } , mode = 'lines' , opacity = 0.5 , showlegend = False , x =[ task.start, end, end, task.start, task.start ] , y =[ y_pos, y_pos, y_pos - self.rh, y_pos - self.rh, y_pos ] , ) def _create_annotation ( self , task , y_pos ) : \"\"\"Add task label to chart as text overlay. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" # For milestones with narrow fill , hover can be tricky , so intended to make the whole length of the text # hoverable , but only the x / y point appears to be hoverable although it makes a larger hover zone at least return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( task ) + '<extra></extra>' , hovertext = self . _create_hover_text ( task ), legendgroup = self . color_lookup [ task.category ] , mode = 'text' , showlegend = False , text = task . label , textposition = 'middle left' , x =[ task.end ] , y =[ y_pos - self.rh / 2 ] , ) def create_layout ( self ) : \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super (). create_layout () # Suppress Y axis ticks / grid layout [ 'yaxis' ][ 'showgrid' ] = False layout [ 'yaxis' ][ 'showticklabels' ] = False layout [ 'yaxis' ][ 'zeroline' ] = False return layout ``` Classes \u2693\ufe0e GanttChart \u2693\ufe0e class GanttChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class GanttChart ( CustomChart ): # noqa: H601 \"\"\"Gantt Chart: task and milestone timeline.\"\"\" date_format = '%Y-%m- %d ' \"\"\"Date format for bar chart.\"\"\" pallette = TableauMedium_10 . hex_colors \"\"\"Default color pallette for project colors.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular task.\"\"\" def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end, progress)` Returns: list: Dash chart traces \"\"\" # If start is None, assign end to start so that the sort is correct start_index = df_raw . columns . get_loc ( 'start' ) end_index = df_raw . columns . get_loc ( 'end' ) for index in [ idx for idx , is_na in enumerate ( df_raw [ 'start' ] . isna ()) if is_na ]: df_raw . iloc [ index , start_index ] = df_raw . iloc [ index , end_index ] df_raw [ 'progress' ] = df_raw [ 'progress' ] . fillna ( 0 ) # Fill possibly missing progress values for milestones df_raw = ( df_raw . sort_values ( by = [ 'category' , 'start' ], ascending = False ) . sort_values ( by = [ 'end' ], ascending = False ) . reset_index ( drop = True ) ) # Create color lookup using categories in sorted order categories = set ( df_raw [ 'category' ]) self . color_lookup = { cat : self . pallette [ idx ] for idx , cat in enumerate ( categories )} # Track which categories have been plotted plotted_categories = [] # Create the Gantt traces traces = [] for task in df_raw . itertuples (): y_pos = task . Index is_first = task . category not in plotted_categories plotted_categories . append ( task . category ) traces . append ( self . _create_task_shape ( task , y_pos , is_first )) if task . progress > 0 : traces . append ( self . _create_progress_shape ( task , y_pos )) traces . append ( self . _create_annotation ( task , y_pos )) return traces def _create_hover_text ( self , task ): \"\"\"Return hover text for given trace. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` Returns: string: HTML-formatted hover text \"\"\" dates = [ format_unix ( get_unix ( str_ts , self . date_format ), ' %a , %d %b%Y' ) for str_ts in [ task . start , task . end ]] if task . start != task . end : date_range = f '<br><b>Start</b>: { dates [ 0 ] } <br><b>End</b>: { dates [ 1 ] } ' else : date_range = f '<br><b>Milestone</b>: { dates [ 1 ] } ' return f '<b> { task . category } </b><br> { task . label } ( { int ( task . progress * 100 ) } %)<br> { date_range } ' def _create_task_shape ( self , task , y_pos , is_first ): \"\"\"Create colored task scatter rectangle. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task is_first: if True, this is the first time a task of this category will be plotted Returns: trace: single Dash chart Scatter trace \"\"\" color = self . color_lookup [ task . category ] scatter_kwargs = { 'fill' : 'toself' , 'fillcolor' : color , 'hoverlabel' : self . hover_label_settings , 'legendgroup' : color , 'line' : { 'width' : 1 }, 'marker' : { 'color' : color }, 'mode' : 'lines' , 'showlegend' : is_first , 'text' : self . _create_hover_text ( task ), 'x' : [ task . start , task . end , task . end , task . start , task . start ], 'y' : [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], } if is_first : scatter_kwargs [ 'name' ] = task . category return go . Scatter ( ** scatter_kwargs ) def _create_progress_shape ( self , task , y_pos ): \"\"\"Create semi-transparent white overlay `self.shapes` to indicate task progress. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" unix_start = get_unix ( task . start , self . date_format ) unix_progress = ( get_unix ( task . end , self . date_format ) - unix_start ) * task . progress + unix_start end = format_unix ( unix_progress , self . date_format ) return go . Scatter ( fill = 'toself' , fillcolor = 'white' , hoverinfo = 'skip' , legendgroup = self . color_lookup [ task . category ], line = { 'width' : 1 }, marker = { 'color' : 'white' }, mode = 'lines' , opacity = 0.5 , showlegend = False , x = [ task . start , end , end , task . start , task . start ], y = [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], ) def _create_annotation ( self , task , y_pos ): \"\"\"Add task label to chart as text overlay. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" # For milestones with narrow fill, hover can be tricky, so intended to make the whole length of the text # hoverable, but only the x/y point appears to be hoverable although it makes a larger hover zone at least return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( task ) + '<extra></extra>' , hovertext = self . _create_hover_text ( task ), legendgroup = self . color_lookup [ task . category ], mode = 'text' , showlegend = False , text = task . label , textposition = 'middle left' , x = [ task . end ], y = [ y_pos - self . rh / 2 ], ) def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Suppress Y axis ticks/grid layout [ 'yaxis' ][ 'showgrid' ] = False layout [ 'yaxis' ][ 'showticklabels' ] = False layout [ 'yaxis' ][ 'zeroline' ] = False return layout Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations date_format Date format for bar chart. hover_label_settings Plotly hover label settings. pallette Default color pallette for project colors. rh Height of each rectangular task. Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Suppress Y axis ticks/grid layout [ 'yaxis' ][ 'showgrid' ] = False layout [ 'yaxis' ][ 'showticklabels' ] = False layout [ 'yaxis' ][ 'zeroline' ] = False return layout create_traces \u2693\ufe0e def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns: (category, label, start, end, progress) Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end, progress)` Returns: list: Dash chart traces \"\"\" # If start is None, assign end to start so that the sort is correct start_index = df_raw . columns . get_loc ( 'start' ) end_index = df_raw . columns . get_loc ( 'end' ) for index in [ idx for idx , is_na in enumerate ( df_raw [ 'start' ] . isna ()) if is_na ]: df_raw . iloc [ index , start_index ] = df_raw . iloc [ index , end_index ] df_raw [ 'progress' ] = df_raw [ 'progress' ] . fillna ( 0 ) # Fill possibly missing progress values for milestones df_raw = ( df_raw . sort_values ( by = [ 'category' , 'start' ], ascending = False ) . sort_values ( by = [ 'end' ], ascending = False ) . reset_index ( drop = True ) ) # Create color lookup using categories in sorted order categories = set ( df_raw [ 'category' ]) self . color_lookup = { cat : self . pallette [ idx ] for idx , cat in enumerate ( categories )} # Track which categories have been plotted plotted_categories = [] # Create the Gantt traces traces = [] for task in df_raw . itertuples (): y_pos = task . Index is_first = task . category not in plotted_categories plotted_categories . append ( task . category ) traces . append ( self . _create_task_shape ( task , y_pos , is_first )) if task . progress > 0 : traces . append ( self . _create_progress_shape ( task , y_pos )) traces . append ( self . _create_annotation ( task , y_pos )) return traces initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"dash_charts.gantt_chart"},{"location":"modules/dash_charts/gantt_chart/#dash_chartsgantt_chart","text":"Gantt Chart. Note: does not support resources nor task dependencies; however those could be added by extending this base class.","title":"dash_charts.gantt_chart"},{"location":"modules/dash_charts/gantt_chart/#removed-code","text":"# Just snippets of Python code that may be useful in the future dates = sorted ( set ( filter ( None , df_raw [ 'start' ] . to_list () + df_raw [ 'end' ] . to_list ()))) self . axis_range = { 'x' : [ dates [ 0 ], dates [ - 1 ]]} View Source \"\"\"Gantt Chart. Note: does not support resources nor task dependencies; however those could be added by extending this base class. # Removed Code ```py # Just snippets of Python code that may be useful in the future dates = sorted(set(filter(None, df_raw['start'].to_list() + df_raw['end'].to_list()))) self.axis_range = {'x': [dates[0], dates[-1]]} \u201d\u201c\u201d import plotly.graph_objects as go from palettable.tableau import TableauMedium_10 from .utils_data import format_unix, get_unix from .utils_fig import CustomChart class GanttChart(CustomChart): # noqa: H601 \u201c\u201d\u201cGantt Chart: task and milestone timeline.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 date_format = '%Y-%m-%d' \"\"\"Date format for bar chart.\"\"\" pallette = TableauMedium_10 . hex_colors \"\"\"Default color pallette for project colors.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular task.\"\"\" def create_traces ( self , df_raw ) : \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end, progress)` Returns: list: Dash chart traces \"\"\" # If start is None , assign end to start so that the sort is correct start_index = df_raw . columns . get_loc ( 'start' ) end_index = df_raw . columns . get_loc ( 'end' ) for index in [ idx for idx, is_na in enumerate(df_raw['start' ] . isna ()) if is_na ]: df_raw . iloc [ index, start_index ] = df_raw . iloc [ index, end_index ] df_raw [ 'progress' ] = df_raw [ 'progress' ] . fillna ( 0 ) # Fill possibly missing progress values for milestones df_raw = ( df_raw . sort_values ( by =[ 'category', 'start' ] , ascending = False ) . sort_values ( by =[ 'end' ] , ascending = False ) . reset_index ( drop = True ) ) # Create color lookup using categories in sorted order categories = set ( df_raw [ 'category' ] ) self . color_lookup = { cat : self . pallette [ idx ] for idx , cat in enumerate ( categories ) } # Track which categories have been plotted plotted_categories = [] # Create the Gantt traces traces = [] for task in df_raw . itertuples () : y_pos = task . Index is_first = task . category not in plotted_categories plotted_categories . append ( task . category ) traces . append ( self . _create_task_shape ( task , y_pos , is_first )) if task . progress > 0 : traces . append ( self . _create_progress_shape ( task , y_pos )) traces . append ( self . _create_annotation ( task , y_pos )) return traces def _create_hover_text ( self , task ) : \"\"\"Return hover text for given trace. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` Returns: string: HTML-formatted hover text \"\"\" dates = [ format_unix(get_unix(str_ts, self.date_format), '%a, %d%b%Y') for str_ts in [task.start, task.end ] ] if task . start != task . end : date_range = f '<br><b>Start</b>: {dates[0]}<br><b>End</b>: {dates[1]}' else : date_range = f '<br><b>Milestone</b>: {dates[1]}' return f '<b>{task.category}</b><br>{task.label} ({int(task.progress * 100)}%)<br>{date_range}' def _create_task_shape ( self , task , y_pos , is_first ) : \"\"\"Create colored task scatter rectangle. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task is_first: if True, this is the first time a task of this category will be plotted Returns: trace: single Dash chart Scatter trace \"\"\" color = self . color_lookup [ task.category ] scatter_kwargs = { 'fill' : 'toself' , 'fillcolor' : color , 'hoverlabel' : self . hover_label_settings , 'legendgroup' : color , 'line' : { 'width' : 1 } , 'marker' : { 'color' : color } , 'mode' : 'lines' , 'showlegend' : is_first , 'text' : self . _create_hover_text ( task ), 'x' : [ task.start, task.end, task.end, task.start, task.start ] , 'y' : [ y_pos, y_pos, y_pos - self.rh, y_pos - self.rh, y_pos ] , } if is_first : scatter_kwargs [ 'name' ] = task . category return go . Scatter ( ** scatter_kwargs ) def _create_progress_shape ( self , task , y_pos ) : \"\"\"Create semi-transparent white overlay `self.shapes` to indicate task progress. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" unix_start = get_unix ( task . start , self . date_format ) unix_progress = ( get_unix ( task . end , self . date_format ) - unix_start ) * task . progress + unix_start end = format_unix ( unix_progress , self . date_format ) return go . Scatter ( fill = 'toself' , fillcolor = 'white' , hoverinfo = 'skip' , legendgroup = self . color_lookup [ task.category ] , line = { 'width' : 1 } , marker = { 'color' : 'white' } , mode = 'lines' , opacity = 0.5 , showlegend = False , x =[ task.start, end, end, task.start, task.start ] , y =[ y_pos, y_pos, y_pos - self.rh, y_pos - self.rh, y_pos ] , ) def _create_annotation ( self , task , y_pos ) : \"\"\"Add task label to chart as text overlay. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" # For milestones with narrow fill , hover can be tricky , so intended to make the whole length of the text # hoverable , but only the x / y point appears to be hoverable although it makes a larger hover zone at least return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( task ) + '<extra></extra>' , hovertext = self . _create_hover_text ( task ), legendgroup = self . color_lookup [ task.category ] , mode = 'text' , showlegend = False , text = task . label , textposition = 'middle left' , x =[ task.end ] , y =[ y_pos - self.rh / 2 ] , ) def create_layout ( self ) : \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super (). create_layout () # Suppress Y axis ticks / grid layout [ 'yaxis' ][ 'showgrid' ] = False layout [ 'yaxis' ][ 'showticklabels' ] = False layout [ 'yaxis' ][ 'zeroline' ] = False return layout ```","title":"Removed Code"},{"location":"modules/dash_charts/gantt_chart/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/gantt_chart/#ganttchart","text":"class GanttChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class GanttChart ( CustomChart ): # noqa: H601 \"\"\"Gantt Chart: task and milestone timeline.\"\"\" date_format = '%Y-%m- %d ' \"\"\"Date format for bar chart.\"\"\" pallette = TableauMedium_10 . hex_colors \"\"\"Default color pallette for project colors.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular task.\"\"\" def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end, progress)` Returns: list: Dash chart traces \"\"\" # If start is None, assign end to start so that the sort is correct start_index = df_raw . columns . get_loc ( 'start' ) end_index = df_raw . columns . get_loc ( 'end' ) for index in [ idx for idx , is_na in enumerate ( df_raw [ 'start' ] . isna ()) if is_na ]: df_raw . iloc [ index , start_index ] = df_raw . iloc [ index , end_index ] df_raw [ 'progress' ] = df_raw [ 'progress' ] . fillna ( 0 ) # Fill possibly missing progress values for milestones df_raw = ( df_raw . sort_values ( by = [ 'category' , 'start' ], ascending = False ) . sort_values ( by = [ 'end' ], ascending = False ) . reset_index ( drop = True ) ) # Create color lookup using categories in sorted order categories = set ( df_raw [ 'category' ]) self . color_lookup = { cat : self . pallette [ idx ] for idx , cat in enumerate ( categories )} # Track which categories have been plotted plotted_categories = [] # Create the Gantt traces traces = [] for task in df_raw . itertuples (): y_pos = task . Index is_first = task . category not in plotted_categories plotted_categories . append ( task . category ) traces . append ( self . _create_task_shape ( task , y_pos , is_first )) if task . progress > 0 : traces . append ( self . _create_progress_shape ( task , y_pos )) traces . append ( self . _create_annotation ( task , y_pos )) return traces def _create_hover_text ( self , task ): \"\"\"Return hover text for given trace. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` Returns: string: HTML-formatted hover text \"\"\" dates = [ format_unix ( get_unix ( str_ts , self . date_format ), ' %a , %d %b%Y' ) for str_ts in [ task . start , task . end ]] if task . start != task . end : date_range = f '<br><b>Start</b>: { dates [ 0 ] } <br><b>End</b>: { dates [ 1 ] } ' else : date_range = f '<br><b>Milestone</b>: { dates [ 1 ] } ' return f '<b> { task . category } </b><br> { task . label } ( { int ( task . progress * 100 ) } %)<br> { date_range } ' def _create_task_shape ( self , task , y_pos , is_first ): \"\"\"Create colored task scatter rectangle. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task is_first: if True, this is the first time a task of this category will be plotted Returns: trace: single Dash chart Scatter trace \"\"\" color = self . color_lookup [ task . category ] scatter_kwargs = { 'fill' : 'toself' , 'fillcolor' : color , 'hoverlabel' : self . hover_label_settings , 'legendgroup' : color , 'line' : { 'width' : 1 }, 'marker' : { 'color' : color }, 'mode' : 'lines' , 'showlegend' : is_first , 'text' : self . _create_hover_text ( task ), 'x' : [ task . start , task . end , task . end , task . start , task . start ], 'y' : [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], } if is_first : scatter_kwargs [ 'name' ] = task . category return go . Scatter ( ** scatter_kwargs ) def _create_progress_shape ( self , task , y_pos ): \"\"\"Create semi-transparent white overlay `self.shapes` to indicate task progress. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" unix_start = get_unix ( task . start , self . date_format ) unix_progress = ( get_unix ( task . end , self . date_format ) - unix_start ) * task . progress + unix_start end = format_unix ( unix_progress , self . date_format ) return go . Scatter ( fill = 'toself' , fillcolor = 'white' , hoverinfo = 'skip' , legendgroup = self . color_lookup [ task . category ], line = { 'width' : 1 }, marker = { 'color' : 'white' }, mode = 'lines' , opacity = 0.5 , showlegend = False , x = [ task . start , end , end , task . start , task . start ], y = [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], ) def _create_annotation ( self , task , y_pos ): \"\"\"Add task label to chart as text overlay. Args: task: row tuple from df_raw with: `(category, label, start, end, progress)` y_pos: top y-coordinate of task Returns: trace: single Dash chart Scatter trace \"\"\" # For milestones with narrow fill, hover can be tricky, so intended to make the whole length of the text # hoverable, but only the x/y point appears to be hoverable although it makes a larger hover zone at least return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( task ) + '<extra></extra>' , hovertext = self . _create_hover_text ( task ), legendgroup = self . color_lookup [ task . category ], mode = 'text' , showlegend = False , text = task . label , textposition = 'middle left' , x = [ task . end ], y = [ y_pos - self . rh / 2 ], ) def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Suppress Y axis ticks/grid layout [ 'yaxis' ][ 'showgrid' ] = False layout [ 'yaxis' ][ 'showticklabels' ] = False layout [ 'yaxis' ][ 'zeroline' ] = False return layout","title":"GanttChart"},{"location":"modules/dash_charts/gantt_chart/#ancestors-in-mro","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/gantt_chart/#class-variables","text":"annotations date_format Date format for bar chart. hover_label_settings Plotly hover label settings. pallette Default color pallette for project colors. rh Height of each rectangular task.","title":"Class variables"},{"location":"modules/dash_charts/gantt_chart/#instance-variables","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/gantt_chart/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/gantt_chart/#apply_custom_layout","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/gantt_chart/#create_figure","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/gantt_chart/#create_layout","text":"def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Suppress Y axis ticks/grid layout [ 'yaxis' ][ 'showgrid' ] = False layout [ 'yaxis' ][ 'showticklabels' ] = False layout [ 'yaxis' ][ 'zeroline' ] = False return layout","title":"create_layout"},{"location":"modules/dash_charts/gantt_chart/#create_traces","text":"def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns: (category, label, start, end, progress) Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end, progress)` Returns: list: Dash chart traces \"\"\" # If start is None, assign end to start so that the sort is correct start_index = df_raw . columns . get_loc ( 'start' ) end_index = df_raw . columns . get_loc ( 'end' ) for index in [ idx for idx , is_na in enumerate ( df_raw [ 'start' ] . isna ()) if is_na ]: df_raw . iloc [ index , start_index ] = df_raw . iloc [ index , end_index ] df_raw [ 'progress' ] = df_raw [ 'progress' ] . fillna ( 0 ) # Fill possibly missing progress values for milestones df_raw = ( df_raw . sort_values ( by = [ 'category' , 'start' ], ascending = False ) . sort_values ( by = [ 'end' ], ascending = False ) . reset_index ( drop = True ) ) # Create color lookup using categories in sorted order categories = set ( df_raw [ 'category' ]) self . color_lookup = { cat : self . pallette [ idx ] for idx , cat in enumerate ( categories )} # Track which categories have been plotted plotted_categories = [] # Create the Gantt traces traces = [] for task in df_raw . itertuples (): y_pos = task . Index is_first = task . category not in plotted_categories plotted_categories . append ( task . category ) traces . append ( self . _create_task_shape ( task , y_pos , is_first )) if task . progress > 0 : traces . append ( self . _create_progress_shape ( task , y_pos )) traces . append ( self . _create_annotation ( task , y_pos )) return traces","title":"create_traces"},{"location":"modules/dash_charts/gantt_chart/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/modules_datatable/","text":"dash_charts.modules_datatable \u2693\ufe0e Dash Modules for Data Tables. View Source \"\"\"Dash Modules for Data Tables.\"\"\" import json import dash_bootstrap_components as dbc import pandas as pd from dash import dcc , html from dash.exceptions import PreventUpdate from .components import dropdown_group , opts_dd from .datatable import BaseDataTable from .utils_app_modules import ModuleBase from .utils_callbacks import map_args , map_outputs class ModuleDataTable ( ModuleBase ): \"\"\"Modular Dash data table.\"\"\" id_table_parent = 'datatable-module-parent' \"\"\"Table Parent ID.\"\"\" id_table = 'datatable-module' \"\"\"Table ID.\"\"\" table = None \"\"\"Dash Data Table.\"\"\" all_ids = [ id_table_parent , id_table ] \"\"\"List of ids to register for this module.\"\"\" def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable () def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object \"\"\" placeholder = pd . DataFrame . from_records ([[ 'body' ]], columns = [ 'header' ]) return html . Div ( [ self . table . create_table ( placeholder , None , id = ids [ self . get ( self . id_table )]), ], id = ids [ self . get ( self . id_table_parent )], ) def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )] def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" self . register_highlight_sort_column ( parent ) def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )]) class ModuleFilteredTable ( ModuleDataTable ): \"\"\"Modular Dash data table with column selection and filter.\"\"\" id_column_select = 'column-select' \"\"\"Column select ID.\"\"\" id_filter_button = 'filter-button' \"\"\"Apply filter button ID.\"\"\" id_filter_input = 'filter-query-input' \"\"\"Filter query input ID.\"\"\" id_filter_output = 'filter-query-output' \"\"\"Filter query output ID.\"\"\" id_filter_structure = 'filter-query-structure' \"\"\"Filter query structure ID.\"\"\" all_ids = ModuleDataTable . all_ids + [ id_column_select , id_filter_button , id_filter_input , id_filter_output , id_filter_structure , ] \"\"\"List of ids to register for this module.\"\"\" show_filter = True \"\"\"If True (default), will show an input for entering a global filter.\"\"\" mod_df = None \"\"\"Data frame shown in table. Passed to `return_layout` and used when creating the table.\"\"\" def return_layout ( self , ids , mod_df ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application mod_df: dataframe for Returns: dict: Dash HTML object \"\"\" self . mod_df = mod_df options = [ opts_dd ( column , column ) for column in self . mod_df . columns ] if self . show_filter : filter_elements = dbc . Row ([ dbc . Col ( [ dbc . Form ([ dcc . Input ( id = ids [ self . get ( self . id_filter_input )], placeholder = 'Enter filter query' , style = { 'width' : '100%' }, ), dbc . Button ( 'Apply' , color = 'secondary' , id = ids [ self . get ( self . id_filter_button )], style = { 'paddingTop' : '5px' }, ), ]), ], width = 4 , ), dbc . Col ( [ html . Div ([], id = ids [ self . get ( self . id_filter_output )]), ], width = 4 , ), dbc . Col ( [ html . Div ( id = ids [ self . get ( self . id_filter_structure )], style = { 'whitespace' : 'pre' }), ], width = 4 , ), ]) else : filter_elements = html . Div () return dbc . Col ([ dropdown_group ( 'Select DataFrame Columns' , ids [ self . get ( self . id_column_select )], options , multi = True , persistence = True , value = self . mod_df . columns , ), filter_elements , html . Br (), super () . return_layout ( ids ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_create_table ( parent ) if self . show_filter : self . register_filter_interface ( parent ) self . register_show_query ( parent ) def register_create_table ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table_parent ), 'children' )] inputs = [( self . get ( self . id_column_select ), 'value' )] states = [] @parent . callback ( outputs , inputs , states ) def create_table ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) columns = a_in [ self . get ( self . id_column_select )][ 'value' ] if not columns : raise PreventUpdate return map_outputs ( outputs , self . return_table_map ( parent . ids , self . mod_df , columns )) def register_filter_interface ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_table ), 'filter_query' )] inputs = [( self . get ( self . id_filter_button ), 'n_clicks' )] states = [( self . get ( self . id_filter_input ), 'value' )] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) query = a_states [ self . get ( self . id_filter_input )][ 'value' ] if query is None : query = '' return map_outputs ( outputs , [( self . get ( self . id_table ), 'filter_query' , query )]) def register_show_query ( self , parent ): # noqa: CCR001 \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_filter_output ), 'children' ), ( self . get ( self . id_filter_structure ), 'children' )] inputs = [ ( self . get ( self . id_table ), 'filter_query' ), ( self . get ( self . id_table ), 'derived_filter_query_structure' ), ] states = [] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) filter_query = a_in [ self . get ( self . id_table )][ 'filter_query' ] derived_query = a_in [ self . get ( self . id_table )][ 'derived_filter_query_structure' ] if filter_query is None or len ( filter_query . strip ()) == 0 : filter_element = [ 'No filter query' ] derived_element = [ '' ] else : filter_element = [ dcc . Markdown ( f '``` \\n\\n filter_query: \\n\\n { filter_query } \\n\\n ```' )] if derived_query is None : derived_element = [ 'Error in query. Check formatting' ] else : derived_element = [ html . Details ([ html . Summary ( 'Derived filter query structure' ), html . Div ( dcc . Markdown ( f '```json \\n\\n { json . dumps ( derived_query , indent = 4 ) } \\n\\n ```' )), ]), ] return map_outputs ( outputs , [ ( self . get ( self . id_filter_output ), 'children' , filter_element ), ( self . get ( self . id_filter_structure ), 'children' , derived_element ), ], ) Classes \u2693\ufe0e ModuleDataTable \u2693\ufe0e class ModuleDataTable ( name ) View Source class ModuleDataTable ( ModuleBase ): \"\"\"Modular Dash data table.\"\"\" id_table_parent = 'datatable-module-parent' \"\"\"Table Parent ID.\"\"\" id_table = 'datatable-module' \"\"\"Table ID.\"\"\" table = None \"\"\"Dash Data Table.\"\"\" all_ids = [ id_table_parent , id_table ] \"\"\"List of ids to register for this module.\"\"\" def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable () def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object \"\"\" placeholder = pd . DataFrame . from_records ([[ 'body' ]], columns = [ 'header' ]) return html . Div ( [ self . table . create_table ( placeholder , None , id = ids [ self . get ( self . id_table )]), ], id = ids [ self . get ( self . id_table_parent )], ) def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )] def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" self . register_highlight_sort_column ( parent ) def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )]) Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_modules.ModuleBase Descendants \u2693\ufe0e dash_charts.modules_datatable.ModuleFilteredTable Class variables \u2693\ufe0e all_ids List of ids to register for this module. id_table Table ID. id_table_parent Table Parent ID. table Dash Data Table. Methods \u2693\ufe0e create_callbacks \u2693\ufe0e def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" self . register_highlight_sort_column ( parent ) create_elements \u2693\ufe0e def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable () get \u2693\ufe0e def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... register_highlight_sort_column \u2693\ufe0e def register_highlight_sort_column ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) Raises: Type Description PreventUpdate if no columns found in the table View Source def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )]) return_layout \u2693\ufe0e def return_layout ( self , ids ) Return Dash application layout. Parameters: Name Description ids self._il from base application Returns: Type Description dict Dash HTML object View Source def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object \"\"\" placeholder = pd . DataFrame . from_records ([[ 'body' ]], columns = [ 'header' ]) return html . Div ( [ self . table . create_table ( placeholder , None , id = ids [ self . get ( self . id_table )]), ], id = ids [ self . get ( self . id_table_parent )], ) return_table_map \u2693\ufe0e def return_table_map ( self , ids , df_table , columns = None ) Return list of tuples for map_outputs that includes the new datatable. Parameters: Name Description ids self._il from base application df_table dataframe to show in table columns list of columns to show. Default is None, which will show all columns Returns: Type Description list list of tuples for map_outputs View Source def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )] ModuleFilteredTable \u2693\ufe0e class ModuleFilteredTable ( name ) View Source class ModuleFilteredTable ( ModuleDataTable ): \"\"\"Modular Dash data table with column selection and filter.\"\"\" id_column_select = 'column-select' \"\"\"Column select ID.\"\"\" id_filter_button = 'filter-button' \"\"\"Apply filter button ID.\"\"\" id_filter_input = 'filter-query-input' \"\"\"Filter query input ID.\"\"\" id_filter_output = 'filter-query-output' \"\"\"Filter query output ID.\"\"\" id_filter_structure = 'filter-query-structure' \"\"\"Filter query structure ID.\"\"\" all_ids = ModuleDataTable . all_ids + [ id_column_select , id_filter_button , id_filter_input , id_filter_output , id_filter_structure , ] \"\"\"List of ids to register for this module.\"\"\" show_filter = True \"\"\"If True (default), will show an input for entering a global filter.\"\"\" mod_df = None \"\"\"Data frame shown in table. Passed to `return_layout` and used when creating the table.\"\"\" def return_layout ( self , ids , mod_df ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application mod_df: dataframe for Returns: dict: Dash HTML object \"\"\" self . mod_df = mod_df options = [ opts_dd ( column , column ) for column in self . mod_df . columns ] if self . show_filter : filter_elements = dbc . Row ([ dbc . Col ( [ dbc . Form ([ dcc . Input ( id = ids [ self . get ( self . id_filter_input )], placeholder = 'Enter filter query' , style = { 'width' : '100%' }, ), dbc . Button ( 'Apply' , color = 'secondary' , id = ids [ self . get ( self . id_filter_button )], style = { 'paddingTop' : '5px' }, ), ]), ], width = 4 , ), dbc . Col ( [ html . Div ([], id = ids [ self . get ( self . id_filter_output )]), ], width = 4 , ), dbc . Col ( [ html . Div ( id = ids [ self . get ( self . id_filter_structure )], style = { 'whitespace' : 'pre' }), ], width = 4 , ), ]) else : filter_elements = html . Div () return dbc . Col ([ dropdown_group ( 'Select DataFrame Columns' , ids [ self . get ( self . id_column_select )], options , multi = True , persistence = True , value = self . mod_df . columns , ), filter_elements , html . Br (), super () . return_layout ( ids ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_create_table ( parent ) if self . show_filter : self . register_filter_interface ( parent ) self . register_show_query ( parent ) def register_create_table ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table_parent ), 'children' )] inputs = [( self . get ( self . id_column_select ), 'value' )] states = [] @parent . callback ( outputs , inputs , states ) def create_table ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) columns = a_in [ self . get ( self . id_column_select )][ 'value' ] if not columns : raise PreventUpdate return map_outputs ( outputs , self . return_table_map ( parent . ids , self . mod_df , columns )) def register_filter_interface ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_table ), 'filter_query' )] inputs = [( self . get ( self . id_filter_button ), 'n_clicks' )] states = [( self . get ( self . id_filter_input ), 'value' )] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) query = a_states [ self . get ( self . id_filter_input )][ 'value' ] if query is None : query = '' return map_outputs ( outputs , [( self . get ( self . id_table ), 'filter_query' , query )]) def register_show_query ( self , parent ): # noqa: CCR001 \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_filter_output ), 'children' ), ( self . get ( self . id_filter_structure ), 'children' )] inputs = [ ( self . get ( self . id_table ), 'filter_query' ), ( self . get ( self . id_table ), 'derived_filter_query_structure' ), ] states = [] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) filter_query = a_in [ self . get ( self . id_table )][ 'filter_query' ] derived_query = a_in [ self . get ( self . id_table )][ 'derived_filter_query_structure' ] if filter_query is None or len ( filter_query . strip ()) == 0 : filter_element = [ 'No filter query' ] derived_element = [ '' ] else : filter_element = [ dcc . Markdown ( f '``` \\n\\n filter_query: \\n\\n { filter_query } \\n\\n ```' )] if derived_query is None : derived_element = [ 'Error in query. Check formatting' ] else : derived_element = [ html . Details ([ html . Summary ( 'Derived filter query structure' ), html . Div ( dcc . Markdown ( f '```json \\n\\n { json . dumps ( derived_query , indent = 4 ) } \\n\\n ```' )), ]), ] return map_outputs ( outputs , [ ( self . get ( self . id_filter_output ), 'children' , filter_element ), ( self . get ( self . id_filter_structure ), 'children' , derived_element ), ], ) Ancestors (in MRO) \u2693\ufe0e dash_charts.modules_datatable.ModuleDataTable dash_charts.utils_app_modules.ModuleBase Class variables \u2693\ufe0e all_ids List of ids to register for this module. id_column_select Column select ID. id_filter_button Apply filter button ID. id_filter_input Filter query input ID. id_filter_output Filter query output ID. id_filter_structure Filter query structure ID. id_table id_table_parent mod_df Data frame shown in table. Passed to return_layout and used when creating the table. show_filter If True (default), will show an input for entering a global filter. table Methods \u2693\ufe0e create_callbacks \u2693\ufe0e def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_create_table ( parent ) if self . show_filter : self . register_filter_interface ( parent ) self . register_show_query ( parent ) create_elements \u2693\ufe0e def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable () get \u2693\ufe0e def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... register_create_table \u2693\ufe0e def register_create_table ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) Raises: Type Description PreventUpdate if no columns found in the table View Source def register_create_table ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table_parent ), 'children' )] inputs = [( self . get ( self . id_column_select ), 'value' )] states = [] @parent . callback ( outputs , inputs , states ) def create_table ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) columns = a_in [ self . get ( self . id_column_select )][ 'value' ] if not columns : raise PreventUpdate return map_outputs ( outputs , self . return_table_map ( parent . ids , self . mod_df , columns )) register_filter_interface \u2693\ufe0e def register_filter_interface ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def register_filter_interface ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_table ), 'filter_query' )] inputs = [( self . get ( self . id_filter_button ), 'n_clicks' )] states = [( self . get ( self . id_filter_input ), 'value' )] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) query = a_states [ self . get ( self . id_filter_input )][ 'value' ] if query is None : query = '' return map_outputs ( outputs , [( self . get ( self . id_table ), 'filter_query' , query )]) register_highlight_sort_column \u2693\ufe0e def register_highlight_sort_column ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) Raises: Type Description PreventUpdate if no columns found in the table View Source def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )]) register_show_query \u2693\ufe0e def register_show_query ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def register_show_query ( self , parent ): # noqa: CCR001 \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_filter_output ), 'children' ), ( self . get ( self . id_filter_structure ), 'children' )] inputs = [ ( self . get ( self . id_table ), 'filter_query' ), ( self . get ( self . id_table ), 'derived_filter_query_structure' ), ] states = [] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) filter_query = a_in [ self . get ( self . id_table )][ 'filter_query' ] derived_query = a_in [ self . get ( self . id_table )][ 'derived_filter_query_structure' ] if filter_query is None or len ( filter_query . strip ()) == 0 : filter_element = [ 'No filter query' ] derived_element = [ '' ] else : filter_element = [ dcc . Markdown ( f '``` \\n\\n filter_query: \\n\\n { filter_query } \\n\\n ```' )] if derived_query is None : derived_element = [ 'Error in query. Check formatting' ] else : derived_element = [ html . Details ([ html . Summary ( 'Derived filter query structure' ), html . Div ( dcc . Markdown ( f '```json \\n\\n { json . dumps ( derived_query , indent = 4 ) } \\n\\n ```' )), ]), ] return map_outputs ( outputs , [ ( self . get ( self . id_filter_output ), 'children' , filter_element ), ( self . get ( self . id_filter_structure ), 'children' , derived_element ), ], ) return_layout \u2693\ufe0e def return_layout ( self , ids , mod_df ) Return Dash application layout. Parameters: Name Description ids self._il from base application mod_df dataframe for Returns: Type Description dict Dash HTML object View Source def return_layout ( self , ids , mod_df ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application mod_df: dataframe for Returns: dict: Dash HTML object \"\"\" self . mod_df = mod_df options = [ opts_dd ( column , column ) for column in self . mod_df . columns ] if self . show_filter : filter_elements = dbc . Row ([ dbc . Col ( [ dbc . Form ([ dcc . Input ( id = ids [ self . get ( self . id_filter_input )], placeholder = 'Enter filter query' , style = { 'width' : '100%' }, ), dbc . Button ( 'Apply' , color = 'secondary' , id = ids [ self . get ( self . id_filter_button )], style = { 'paddingTop' : '5px' }, ), ]), ], width = 4 , ), dbc . Col ( [ html . Div ([], id = ids [ self . get ( self . id_filter_output )]), ], width = 4 , ), dbc . Col ( [ html . Div ( id = ids [ self . get ( self . id_filter_structure )], style = { 'whitespace' : 'pre' }), ], width = 4 , ), ]) else : filter_elements = html . Div () return dbc . Col ([ dropdown_group ( 'Select DataFrame Columns' , ids [ self . get ( self . id_column_select )], options , multi = True , persistence = True , value = self . mod_df . columns , ), filter_elements , html . Br (), super () . return_layout ( ids ), ]) return_table_map \u2693\ufe0e def return_table_map ( self , ids , df_table , columns = None ) Return list of tuples for map_outputs that includes the new datatable. Parameters: Name Description ids self._il from base application df_table dataframe to show in table columns list of columns to show. Default is None, which will show all columns Returns: Type Description list list of tuples for map_outputs View Source def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )]","title":"dash_charts.modules_datatable"},{"location":"modules/dash_charts/modules_datatable/#dash_chartsmodules_datatable","text":"Dash Modules for Data Tables. View Source \"\"\"Dash Modules for Data Tables.\"\"\" import json import dash_bootstrap_components as dbc import pandas as pd from dash import dcc , html from dash.exceptions import PreventUpdate from .components import dropdown_group , opts_dd from .datatable import BaseDataTable from .utils_app_modules import ModuleBase from .utils_callbacks import map_args , map_outputs class ModuleDataTable ( ModuleBase ): \"\"\"Modular Dash data table.\"\"\" id_table_parent = 'datatable-module-parent' \"\"\"Table Parent ID.\"\"\" id_table = 'datatable-module' \"\"\"Table ID.\"\"\" table = None \"\"\"Dash Data Table.\"\"\" all_ids = [ id_table_parent , id_table ] \"\"\"List of ids to register for this module.\"\"\" def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable () def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object \"\"\" placeholder = pd . DataFrame . from_records ([[ 'body' ]], columns = [ 'header' ]) return html . Div ( [ self . table . create_table ( placeholder , None , id = ids [ self . get ( self . id_table )]), ], id = ids [ self . get ( self . id_table_parent )], ) def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )] def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" self . register_highlight_sort_column ( parent ) def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )]) class ModuleFilteredTable ( ModuleDataTable ): \"\"\"Modular Dash data table with column selection and filter.\"\"\" id_column_select = 'column-select' \"\"\"Column select ID.\"\"\" id_filter_button = 'filter-button' \"\"\"Apply filter button ID.\"\"\" id_filter_input = 'filter-query-input' \"\"\"Filter query input ID.\"\"\" id_filter_output = 'filter-query-output' \"\"\"Filter query output ID.\"\"\" id_filter_structure = 'filter-query-structure' \"\"\"Filter query structure ID.\"\"\" all_ids = ModuleDataTable . all_ids + [ id_column_select , id_filter_button , id_filter_input , id_filter_output , id_filter_structure , ] \"\"\"List of ids to register for this module.\"\"\" show_filter = True \"\"\"If True (default), will show an input for entering a global filter.\"\"\" mod_df = None \"\"\"Data frame shown in table. Passed to `return_layout` and used when creating the table.\"\"\" def return_layout ( self , ids , mod_df ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application mod_df: dataframe for Returns: dict: Dash HTML object \"\"\" self . mod_df = mod_df options = [ opts_dd ( column , column ) for column in self . mod_df . columns ] if self . show_filter : filter_elements = dbc . Row ([ dbc . Col ( [ dbc . Form ([ dcc . Input ( id = ids [ self . get ( self . id_filter_input )], placeholder = 'Enter filter query' , style = { 'width' : '100%' }, ), dbc . Button ( 'Apply' , color = 'secondary' , id = ids [ self . get ( self . id_filter_button )], style = { 'paddingTop' : '5px' }, ), ]), ], width = 4 , ), dbc . Col ( [ html . Div ([], id = ids [ self . get ( self . id_filter_output )]), ], width = 4 , ), dbc . Col ( [ html . Div ( id = ids [ self . get ( self . id_filter_structure )], style = { 'whitespace' : 'pre' }), ], width = 4 , ), ]) else : filter_elements = html . Div () return dbc . Col ([ dropdown_group ( 'Select DataFrame Columns' , ids [ self . get ( self . id_column_select )], options , multi = True , persistence = True , value = self . mod_df . columns , ), filter_elements , html . Br (), super () . return_layout ( ids ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_create_table ( parent ) if self . show_filter : self . register_filter_interface ( parent ) self . register_show_query ( parent ) def register_create_table ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table_parent ), 'children' )] inputs = [( self . get ( self . id_column_select ), 'value' )] states = [] @parent . callback ( outputs , inputs , states ) def create_table ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) columns = a_in [ self . get ( self . id_column_select )][ 'value' ] if not columns : raise PreventUpdate return map_outputs ( outputs , self . return_table_map ( parent . ids , self . mod_df , columns )) def register_filter_interface ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_table ), 'filter_query' )] inputs = [( self . get ( self . id_filter_button ), 'n_clicks' )] states = [( self . get ( self . id_filter_input ), 'value' )] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) query = a_states [ self . get ( self . id_filter_input )][ 'value' ] if query is None : query = '' return map_outputs ( outputs , [( self . get ( self . id_table ), 'filter_query' , query )]) def register_show_query ( self , parent ): # noqa: CCR001 \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_filter_output ), 'children' ), ( self . get ( self . id_filter_structure ), 'children' )] inputs = [ ( self . get ( self . id_table ), 'filter_query' ), ( self . get ( self . id_table ), 'derived_filter_query_structure' ), ] states = [] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) filter_query = a_in [ self . get ( self . id_table )][ 'filter_query' ] derived_query = a_in [ self . get ( self . id_table )][ 'derived_filter_query_structure' ] if filter_query is None or len ( filter_query . strip ()) == 0 : filter_element = [ 'No filter query' ] derived_element = [ '' ] else : filter_element = [ dcc . Markdown ( f '``` \\n\\n filter_query: \\n\\n { filter_query } \\n\\n ```' )] if derived_query is None : derived_element = [ 'Error in query. Check formatting' ] else : derived_element = [ html . Details ([ html . Summary ( 'Derived filter query structure' ), html . Div ( dcc . Markdown ( f '```json \\n\\n { json . dumps ( derived_query , indent = 4 ) } \\n\\n ```' )), ]), ] return map_outputs ( outputs , [ ( self . get ( self . id_filter_output ), 'children' , filter_element ), ( self . get ( self . id_filter_structure ), 'children' , derived_element ), ], )","title":"dash_charts.modules_datatable"},{"location":"modules/dash_charts/modules_datatable/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/modules_datatable/#moduledatatable","text":"class ModuleDataTable ( name ) View Source class ModuleDataTable ( ModuleBase ): \"\"\"Modular Dash data table.\"\"\" id_table_parent = 'datatable-module-parent' \"\"\"Table Parent ID.\"\"\" id_table = 'datatable-module' \"\"\"Table ID.\"\"\" table = None \"\"\"Dash Data Table.\"\"\" all_ids = [ id_table_parent , id_table ] \"\"\"List of ids to register for this module.\"\"\" def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable () def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object \"\"\" placeholder = pd . DataFrame . from_records ([[ 'body' ]], columns = [ 'header' ]) return html . Div ( [ self . table . create_table ( placeholder , None , id = ids [ self . get ( self . id_table )]), ], id = ids [ self . get ( self . id_table_parent )], ) def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )] def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" self . register_highlight_sort_column ( parent ) def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )])","title":"ModuleDataTable"},{"location":"modules/dash_charts/modules_datatable/#ancestors-in-mro","text":"dash_charts.utils_app_modules.ModuleBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/modules_datatable/#descendants","text":"dash_charts.modules_datatable.ModuleFilteredTable","title":"Descendants"},{"location":"modules/dash_charts/modules_datatable/#class-variables","text":"all_ids List of ids to register for this module. id_table Table ID. id_table_parent Table Parent ID. table Dash Data Table.","title":"Class variables"},{"location":"modules/dash_charts/modules_datatable/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/modules_datatable/#create_callbacks","text":"def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" self . register_highlight_sort_column ( parent )","title":"create_callbacks"},{"location":"modules/dash_charts/modules_datatable/#create_elements","text":"def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable ()","title":"create_elements"},{"location":"modules/dash_charts/modules_datatable/#get","text":"def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ]","title":"get"},{"location":"modules/dash_charts/modules_datatable/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/modules_datatable/#register_highlight_sort_column","text":"def register_highlight_sort_column ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) Raises: Type Description PreventUpdate if no columns found in the table View Source def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )])","title":"register_highlight_sort_column"},{"location":"modules/dash_charts/modules_datatable/#return_layout","text":"def return_layout ( self , ids ) Return Dash application layout. Parameters: Name Description ids self._il from base application Returns: Type Description dict Dash HTML object View Source def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object \"\"\" placeholder = pd . DataFrame . from_records ([[ 'body' ]], columns = [ 'header' ]) return html . Div ( [ self . table . create_table ( placeholder , None , id = ids [ self . get ( self . id_table )]), ], id = ids [ self . get ( self . id_table_parent )], )","title":"return_layout"},{"location":"modules/dash_charts/modules_datatable/#return_table_map","text":"def return_table_map ( self , ids , df_table , columns = None ) Return list of tuples for map_outputs that includes the new datatable. Parameters: Name Description ids self._il from base application df_table dataframe to show in table columns list of columns to show. Default is None, which will show all columns Returns: Type Description list list of tuples for map_outputs View Source def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )]","title":"return_table_map"},{"location":"modules/dash_charts/modules_datatable/#modulefilteredtable","text":"class ModuleFilteredTable ( name ) View Source class ModuleFilteredTable ( ModuleDataTable ): \"\"\"Modular Dash data table with column selection and filter.\"\"\" id_column_select = 'column-select' \"\"\"Column select ID.\"\"\" id_filter_button = 'filter-button' \"\"\"Apply filter button ID.\"\"\" id_filter_input = 'filter-query-input' \"\"\"Filter query input ID.\"\"\" id_filter_output = 'filter-query-output' \"\"\"Filter query output ID.\"\"\" id_filter_structure = 'filter-query-structure' \"\"\"Filter query structure ID.\"\"\" all_ids = ModuleDataTable . all_ids + [ id_column_select , id_filter_button , id_filter_input , id_filter_output , id_filter_structure , ] \"\"\"List of ids to register for this module.\"\"\" show_filter = True \"\"\"If True (default), will show an input for entering a global filter.\"\"\" mod_df = None \"\"\"Data frame shown in table. Passed to `return_layout` and used when creating the table.\"\"\" def return_layout ( self , ids , mod_df ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application mod_df: dataframe for Returns: dict: Dash HTML object \"\"\" self . mod_df = mod_df options = [ opts_dd ( column , column ) for column in self . mod_df . columns ] if self . show_filter : filter_elements = dbc . Row ([ dbc . Col ( [ dbc . Form ([ dcc . Input ( id = ids [ self . get ( self . id_filter_input )], placeholder = 'Enter filter query' , style = { 'width' : '100%' }, ), dbc . Button ( 'Apply' , color = 'secondary' , id = ids [ self . get ( self . id_filter_button )], style = { 'paddingTop' : '5px' }, ), ]), ], width = 4 , ), dbc . Col ( [ html . Div ([], id = ids [ self . get ( self . id_filter_output )]), ], width = 4 , ), dbc . Col ( [ html . Div ( id = ids [ self . get ( self . id_filter_structure )], style = { 'whitespace' : 'pre' }), ], width = 4 , ), ]) else : filter_elements = html . Div () return dbc . Col ([ dropdown_group ( 'Select DataFrame Columns' , ids [ self . get ( self . id_column_select )], options , multi = True , persistence = True , value = self . mod_df . columns , ), filter_elements , html . Br (), super () . return_layout ( ids ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_create_table ( parent ) if self . show_filter : self . register_filter_interface ( parent ) self . register_show_query ( parent ) def register_create_table ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table_parent ), 'children' )] inputs = [( self . get ( self . id_column_select ), 'value' )] states = [] @parent . callback ( outputs , inputs , states ) def create_table ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) columns = a_in [ self . get ( self . id_column_select )][ 'value' ] if not columns : raise PreventUpdate return map_outputs ( outputs , self . return_table_map ( parent . ids , self . mod_df , columns )) def register_filter_interface ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_table ), 'filter_query' )] inputs = [( self . get ( self . id_filter_button ), 'n_clicks' )] states = [( self . get ( self . id_filter_input ), 'value' )] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) query = a_states [ self . get ( self . id_filter_input )][ 'value' ] if query is None : query = '' return map_outputs ( outputs , [( self . get ( self . id_table ), 'filter_query' , query )]) def register_show_query ( self , parent ): # noqa: CCR001 \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_filter_output ), 'children' ), ( self . get ( self . id_filter_structure ), 'children' )] inputs = [ ( self . get ( self . id_table ), 'filter_query' ), ( self . get ( self . id_table ), 'derived_filter_query_structure' ), ] states = [] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) filter_query = a_in [ self . get ( self . id_table )][ 'filter_query' ] derived_query = a_in [ self . get ( self . id_table )][ 'derived_filter_query_structure' ] if filter_query is None or len ( filter_query . strip ()) == 0 : filter_element = [ 'No filter query' ] derived_element = [ '' ] else : filter_element = [ dcc . Markdown ( f '``` \\n\\n filter_query: \\n\\n { filter_query } \\n\\n ```' )] if derived_query is None : derived_element = [ 'Error in query. Check formatting' ] else : derived_element = [ html . Details ([ html . Summary ( 'Derived filter query structure' ), html . Div ( dcc . Markdown ( f '```json \\n\\n { json . dumps ( derived_query , indent = 4 ) } \\n\\n ```' )), ]), ] return map_outputs ( outputs , [ ( self . get ( self . id_filter_output ), 'children' , filter_element ), ( self . get ( self . id_filter_structure ), 'children' , derived_element ), ], )","title":"ModuleFilteredTable"},{"location":"modules/dash_charts/modules_datatable/#ancestors-in-mro_1","text":"dash_charts.modules_datatable.ModuleDataTable dash_charts.utils_app_modules.ModuleBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/modules_datatable/#class-variables_1","text":"all_ids List of ids to register for this module. id_column_select Column select ID. id_filter_button Apply filter button ID. id_filter_input Filter query input ID. id_filter_output Filter query output ID. id_filter_structure Filter query structure ID. id_table id_table_parent mod_df Data frame shown in table. Passed to return_layout and used when creating the table. show_filter If True (default), will show an input for entering a global filter. table","title":"Class variables"},{"location":"modules/dash_charts/modules_datatable/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/modules_datatable/#create_callbacks_1","text":"def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_create_table ( parent ) if self . show_filter : self . register_filter_interface ( parent ) self . register_show_query ( parent )","title":"create_callbacks"},{"location":"modules/dash_charts/modules_datatable/#create_elements_1","text":"def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" self . table = BaseDataTable ()","title":"create_elements"},{"location":"modules/dash_charts/modules_datatable/#get_1","text":"def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ]","title":"get"},{"location":"modules/dash_charts/modules_datatable/#initialize_mutables_1","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/modules_datatable/#register_create_table","text":"def register_create_table ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) Raises: Type Description PreventUpdate if no columns found in the table View Source def register_create_table ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table_parent ), 'children' )] inputs = [( self . get ( self . id_column_select ), 'value' )] states = [] @parent . callback ( outputs , inputs , states ) def create_table ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) columns = a_in [ self . get ( self . id_column_select )][ 'value' ] if not columns : raise PreventUpdate return map_outputs ( outputs , self . return_table_map ( parent . ids , self . mod_df , columns ))","title":"register_create_table"},{"location":"modules/dash_charts/modules_datatable/#register_filter_interface","text":"def register_filter_interface ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def register_filter_interface ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_table ), 'filter_query' )] inputs = [( self . get ( self . id_filter_button ), 'n_clicks' )] states = [( self . get ( self . id_filter_input ), 'value' )] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) query = a_states [ self . get ( self . id_filter_input )][ 'value' ] if query is None : query = '' return map_outputs ( outputs , [( self . get ( self . id_table ), 'filter_query' , query )])","title":"register_filter_interface"},{"location":"modules/dash_charts/modules_datatable/#register_highlight_sort_column_1","text":"def register_highlight_sort_column ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) Raises: Type Description PreventUpdate if no columns found in the table View Source def register_highlight_sort_column ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) Raises: PreventUpdate: if no columns found in the table \"\"\" outputs = [( self . get ( self . id_table ), 'style_data_conditional' )] inputs = [( self . get ( self . id_table ), 'sort_by' )] states = [] @parent . callback ( outputs , inputs , states ) def highlight_sort_column ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) sort_by = a_in [ self . get ( self . id_table )][ 'sort_by' ] if sort_by is None : raise PreventUpdate sorted_columns_style = [] for sort in sort_by : sorted_columns_style . extend ([ { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'odd' }, 'color' : self . table . text_color , 'background-color' : self . table . zebra_color , }, { 'if' : { 'column_id' : sort [ 'column_id' ], 'row_index' : 'even' }, 'color' : self . table . text_color , 'background-color' : self . table . selected_cell_color , }, ]) style_data_conditional = [ * self . table . style_data_conditional , * sorted_columns_style ] return map_outputs ( outputs , [( self . get ( self . id_table ), 'style_data_conditional' , style_data_conditional )])","title":"register_highlight_sort_column"},{"location":"modules/dash_charts/modules_datatable/#register_show_query","text":"def register_show_query ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def register_show_query ( self , parent ): # noqa: CCR001 \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_filter_output ), 'children' ), ( self . get ( self . id_filter_structure ), 'children' )] inputs = [ ( self . get ( self . id_table ), 'filter_query' ), ( self . get ( self . id_table ), 'derived_filter_query_structure' ), ] states = [] @parent . callback ( outputs , inputs , states ) def show_query ( * raw_args ): a_in , a_states = map_args ( raw_args , inputs , states ) filter_query = a_in [ self . get ( self . id_table )][ 'filter_query' ] derived_query = a_in [ self . get ( self . id_table )][ 'derived_filter_query_structure' ] if filter_query is None or len ( filter_query . strip ()) == 0 : filter_element = [ 'No filter query' ] derived_element = [ '' ] else : filter_element = [ dcc . Markdown ( f '``` \\n\\n filter_query: \\n\\n { filter_query } \\n\\n ```' )] if derived_query is None : derived_element = [ 'Error in query. Check formatting' ] else : derived_element = [ html . Details ([ html . Summary ( 'Derived filter query structure' ), html . Div ( dcc . Markdown ( f '```json \\n\\n { json . dumps ( derived_query , indent = 4 ) } \\n\\n ```' )), ]), ] return map_outputs ( outputs , [ ( self . get ( self . id_filter_output ), 'children' , filter_element ), ( self . get ( self . id_filter_structure ), 'children' , derived_element ), ], )","title":"register_show_query"},{"location":"modules/dash_charts/modules_datatable/#return_layout_1","text":"def return_layout ( self , ids , mod_df ) Return Dash application layout. Parameters: Name Description ids self._il from base application mod_df dataframe for Returns: Type Description dict Dash HTML object View Source def return_layout ( self , ids , mod_df ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application mod_df: dataframe for Returns: dict: Dash HTML object \"\"\" self . mod_df = mod_df options = [ opts_dd ( column , column ) for column in self . mod_df . columns ] if self . show_filter : filter_elements = dbc . Row ([ dbc . Col ( [ dbc . Form ([ dcc . Input ( id = ids [ self . get ( self . id_filter_input )], placeholder = 'Enter filter query' , style = { 'width' : '100%' }, ), dbc . Button ( 'Apply' , color = 'secondary' , id = ids [ self . get ( self . id_filter_button )], style = { 'paddingTop' : '5px' }, ), ]), ], width = 4 , ), dbc . Col ( [ html . Div ([], id = ids [ self . get ( self . id_filter_output )]), ], width = 4 , ), dbc . Col ( [ html . Div ( id = ids [ self . get ( self . id_filter_structure )], style = { 'whitespace' : 'pre' }), ], width = 4 , ), ]) else : filter_elements = html . Div () return dbc . Col ([ dropdown_group ( 'Select DataFrame Columns' , ids [ self . get ( self . id_column_select )], options , multi = True , persistence = True , value = self . mod_df . columns , ), filter_elements , html . Br (), super () . return_layout ( ids ), ])","title":"return_layout"},{"location":"modules/dash_charts/modules_datatable/#return_table_map_1","text":"def return_table_map ( self , ids , df_table , columns = None ) Return list of tuples for map_outputs that includes the new datatable. Parameters: Name Description ids self._il from base application df_table dataframe to show in table columns list of columns to show. Default is None, which will show all columns Returns: Type Description list list of tuples for map_outputs View Source def return_table_map ( self , ids , df_table , columns = None ): \"\"\"Return list of tuples for `map_outputs` that includes the new datatable. Args: ids: `self._il` from base application df_table: dataframe to show in table columns: list of columns to show. Default is None, which will show all columns Returns: list: list of tuples for `map_outputs` \"\"\" datatable = self . table . create_table ( df_table , columns , id = ids [ self . get ( self . id_table )]) return [( self . get ( self . id_table_parent ), 'children' , datatable )]","title":"return_table_map"},{"location":"modules/dash_charts/modules_upload/","text":"dash_charts.modules_upload \u2693\ufe0e Upload module and helpers for managing file upload and download. Some functions based on code from: https://docs.faculty.ai/user-guide/apps/examples/dash_file_upload_download.html View Source \"\"\"Upload module and helpers for managing file upload and download. Some functions based on code from: https://docs.faculty.ai/user-guide/apps/examples/dash_file_upload_download.html \"\"\" import base64 import io import json import time from datetime import datetime from pathlib import Path from urllib.parse import quote as urlquote import dash_bootstrap_components as dbc import pandas as pd from dash import dash_table , dcc , html from .utils_app_modules import ModuleBase from .utils_callbacks import map_args , map_outputs from .utils_dataset import DBConnect from .utils_json_cache import CACHE_DIR def split_b64_file ( b64_file ): \"\"\"Separate the data type and data content from a b64-encoded string. Args: b64_file: file encoded in base64 Returns: tuple: of strings `(content_type, data)` \"\"\" return b64_file . encode ( 'utf8' ) . split ( b ';base64,' ) def save_file ( dest_path , b64_file ): \"\"\"Decode and store a file uploaded with Plotly Dash. Args: dest_path: Path on server filesystem to save the file b64_file: file encoded in base64 \"\"\" data = split_b64_file ( b64_file )[ 1 ] dest_path . write_text ( base64 . decodebytes ( data ) . decode ()) def uploaded_files ( upload_dir ): \"\"\"List the files in the upload directory. Args: upload_dir: directory where files are uploadedfolder Returns: list: Paths of uploaded files \"\"\" return [ * upload_dir . glob ( '*.*' )] def file_download_link ( filename ): \"\"\"Create a Plotly Dash 'A' element that when clicked triggers a file downloaded. Args: filename: Path to local file to be available for user download Returns: html.A: clickable Dash link to trigger download \"\"\" # PLANNED: Revisit. Should filename be a name or the full path? return html . A ( filename , href = f '/download/ { urlquote ( filename ) } ' ) def parse_uploaded_image ( b64_file , filename , timestamp ): \"\"\"Create an HTML element to show an uploaded image. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: html.Img: if image data type Raises: RuntimeError: if filetype is not a supported image type \"\"\" content_type , data = split_b64_file ( b64_file ) if 'image' not in content_type : raise RuntimeError ( f 'Not image type. Found: { content_type } ' ) return html . Img ( src = b64_file ) def parse_json ( raw_json ): \"\"\"Return dataframe from JSON formatted in the 'records' orientation. Args: raw_json: json string Returns: dataframe: uploaded dataframe parsed from JSON Raises: RuntimeError: if the JSON file can't be parsed \"\"\" dict_json = json . loads ( raw_json ) keys = [ * dict_json . keys ()] if len ( keys ) != 1 : raise RuntimeError ( 'Expected JSON with format `{data: [...]}` where `data` could be any key.' f 'However, more than one key was found: { keys } ' , ) return pd . DataFrame . from_records ( dict_json [ keys [ 0 ]]) def load_df ( decoded , filename ): \"\"\"Identify file type and parse the uploaded content into a dataframe. Args: decoded: string contents/data of the file decoded from the full base64 file filename: filename of upload file. Name only Returns: dataframe: uploaded dataframe parsed from source file Raises: RuntimeError: if file suffix suffix is unsupported \"\"\" suffix = Path ( filename ) . suffix . lower () if suffix == '.csv' : df_upload = pd . read_csv ( io . StringIO ( decoded . decode ( 'utf-8' ))) elif suffix . startswith ( '.xl' ): # xlsx will have 'spreadsheet' in `content_type` but xls will not have anything df_upload = pd . read_excel ( io . BytesIO ( decoded )) elif suffix == '.json' : df_upload = parse_json ( decoded . decode ( 'utf-8' )) else : raise RuntimeError ( f 'File type ( { suffix } ) is unsupported. Expected .csv, .xl*, or .json' ) return df_upload # noqa: R504 def parse_uploaded_df ( b64_file , filename , timestamp ): \"\"\"Decode base64 data and parse based on file type. Attempts to return the parsed data as a Pandas dataframe. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: dataframe: pandas dataframe parsed from source file Raises: RuntimeError: if raw data could not be parsed \"\"\" content_type , data = split_b64_file ( b64_file ) decoded = base64 . b64decode ( data ) try : df_upload = load_df ( decoded , filename ) except Exception as error : raise RuntimeError ( f 'Could not parse { filename } ( { content_type } ) \\n Error: { error } ' ) return df_upload # noqa: R504 def show_toast ( message , header , icon = 'warning' , style = None , ** toast_kwargs ): \"\"\"Create toast notification. Args: message: string body text header: string notification header icon: string name in `(primary,secondary,success,warning,danger,info,light,dark)`. Default is warning style: style dictionary. Default is the top right toast_kwargs: additional toast keyword arguments (such as `duration=5000`) Returns: dbc.Toast: toast notification from Dash Bootstrap Components library \"\"\" if style is None : # Position in the top right (note: will occlude the tabs when open, could be moved elsewhere) style = { 'position' : 'fixed' , 'top' : 10 , 'right' : 10 , 'width' : 350 , 'zIndex' : 1900 } return dbc . Toast ( message , header = header , icon = icon , style = style , dismissable = True , ** toast_kwargs ) def drop_to_upload ( ** upload_kwargs ): \"\"\"Create drop to upload element. Dashed box of the active area or a clickable link to use the file dialog. Based on dash documentation from: https://dash.plotly.com/dash-core-components/upload Args: upload_kwargs: keyword arguments for th dcc.Upload element. Children and style are reserved Returns: dcc.Upload: Dash upload element \"\"\" return dcc . Upload ( children = html . Div ([ 'Drag and Drop or ' , html . A ( 'Select a File' )]), style = { 'width' : '100%' , 'height' : '60px' , 'lineHeight' : '60px' , 'borderWidth' : '1px' , 'borderStyle' : 'dashed' , 'borderRadius' : '5px' , 'textAlign' : 'center' , 'margin' : '10px' , }, ** upload_kwargs , ) class UploadModule ( ModuleBase ): # noqa: H601 \"\"\"Module for user data upload. Note: this is not intended to be secure \"\"\" id_upload = 'upload-drop-area' \"\"\"Unique name for the upload component.\"\"\" id_upload_output = 'upload-output' \"\"\"Unique name for the div to contain output of the parse-upload.\"\"\" id_username_cache = 'username-cache' \"\"\"Unique name for the dcc.Store element to store the current username.\"\"\" all_ids = [ id_upload , id_upload_output , id_username_cache ] \"\"\"List of ids to register for this module.\"\"\" cache_dir = CACHE_DIR \"\"\"Path to the directory to use for caching files.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize module.\"\"\" # noqa: DAR101 super () . __init__ ( * args , ** kwargs ) self . _initialize_database () def _initialize_database ( self ): \"\"\"Create data members `(self.database, self.user_table, self.inventory_table)`.\"\"\" self . database = DBConnect ( self . cache_dir / f '_placeholder_app- { self . name } .db' ) self . user_table = self . database . db . create_table ( 'users' , primary_id = 'username' , primary_type = self . database . db . types . text , ) self . inventory_table = self . database . db . create_table ( 'inventory' , primary_id = 'table_name' , primary_type = self . database . db . types . text , ) def find_user ( self , username ): \"\"\"Return the database row for the specified user. Args: username: string username Returns: dict: for row from table or None if no match \"\"\" return self . user_table . find_one ( username = username ) def add_user ( self , username ): \"\"\"Add the user to the table or update the user's information if already registered. Args: username: string username \"\"\" now = time . time () if self . find_user ( username ): self . user_table . upsert ({ 'username' : username , 'last_loaded' : now }, [ 'username' ]) else : self . user_table . insert ({ 'username' : username , 'creation' : now , 'last_loaded' : now }) def upload_data ( self , username , df_name , df_upload ): \"\"\"Store dataframe in database for specified user. Args: username: string username df_name: name of the stored dataframe df_upload: pandas dataframe to store Raises: Exception: If upload fails, deletes the created table \"\"\" now = time . time () table_name = f ' { username } - { df_name } - { int ( now ) } ' table = self . database . db . create_table ( table_name ) try : table . insert_many ( df_upload . to_dict ( orient = 'records' )) except Exception : table . drop () # Delete the table if upload fails raise self . inventory_table . insert ({ 'table_name' : table_name , 'df_name' : df_name , 'username' : username , 'creation' : now , }) def get_data ( self , table_name ): \"\"\"Retrieve stored data for specified dataframe name. Args: table_name: unique name of the table to retrieve Returns: pd.DataFrame: pandas dataframe retrieved from the database \"\"\" table = self . database . db . load_table ( table_name ) return pd . DataFrame . from_records ( table . all ()) def delete_data ( self , table_name ): \"\"\"Remove specified data from the database. Args: table_name: unique name of the table to delete \"\"\" self . database . db . load_table ( table_name ) . drop () def return_layout ( self , ids ): \"\"\"Return the Upload module application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object. \"\"\" return html . Div ([ dcc . Store ( id = ids [ self . get ( self . id_username_cache )], storage_type = 'session' ), html . H2 ( 'File Upload' ), html . P ( 'Upload Tidy Data in CSV, Excel, or JSON format' ), drop_to_upload ( id = ids [ self . get ( self . id_upload )]), dcc . Loading ( html . Div ( '' , id = ids [ self . get ( self . id_upload_output )]), type = 'circle' ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_upload_handler ( parent ) def _show_data ( self , username ): \"\"\"Create Dash HTML to show the raw data loaded for the specified user. Args: username: string username Returns: dict: Dash HTML object \"\"\" # TODO: Add delete button for each table - need pattern matching callback: # https://dash.plotly.com/pattern-matching-callbacks def format_table ( df_name , username , creation , raw_df ): user_str = f 'by \" { username } \" ' if username else '' return [ html . H4 ( df_name ), html . P ( f 'Uploaded { user_str } on { datetime . fromtimestamp ( creation ) } (Note: only first 10 rows & 10 col)' ), dash_table . DataTable ( data = raw_df [: 10 ] . to_dict ( 'records' ), columns = [{ 'name' : i , 'id' : i } for i in raw_df . columns [: 10 ]], style_cell = { 'overflow' : 'hidden' , 'textOverflow' : 'ellipsis' , 'maxWidth' : 0 , }, ), html . Hr (), ] children = [ html . Hr ()] rows = self . inventory_table . find ( username = username ) for row in sorted ( rows , key = lambda _row : _row [ 'creation' ], reverse = True ): df_upload = self . get_data ( row [ 'table_name' ]) children . extend ( format_table ( row [ 'df_name' ], row [ 'username' ], row [ 'creation' ], df_upload )) return html . Div ( children ) def register_upload_handler ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_upload_output ), 'children' )] inputs = [( self . get ( self . id_upload ), 'contents' ), ( self . get ( self . id_username_cache ), 'data' )] states = [( self . get ( self . id_upload ), 'filename' ), ( self . get ( self . id_upload ), 'last_modified' )] @parent . callback ( outputs , inputs , states , pic = True ) def upload_handler ( * raw_args ): a_in , a_state = map_args ( raw_args , inputs , states ) b64_file = a_in [ self . get ( self . id_upload )][ 'contents' ] username = a_in [ self . get ( self . id_username_cache )][ 'data' ] filename = a_state [ self . get ( self . id_upload )][ 'filename' ] timestamp = a_state [ self . get ( self . id_upload )][ 'last_modified' ] child_output = [] try : if b64_file is not None : df_upload = parse_uploaded_df ( b64_file , filename , timestamp ) df_upload = df_upload . dropna ( axis = 'columns' ) # FIXME: Better handle NaN values... self . add_user ( username ) self . upload_data ( username , filename , df_upload ) except Exception as error : child_output . extend ([ show_toast ( f ' { error } ' , 'Upload Error' , icon = 'danger' ), dcc . Markdown ( f '### Upload Error \\n\\n { type ( error ) } \\n\\n ``` \\n { error } \\n ```' ), ]) child_output . append ( self . _show_data ( username )) return map_outputs ( outputs , [( self . get ( self . id_upload_output ), 'children' , html . Div ( child_output ))]) Functions \u2693\ufe0e drop_to_upload \u2693\ufe0e def drop_to_upload ( ** upload_kwargs ) Create drop to upload element. Dashed box of the active area or a clickable link to use the file dialog. Based on dash documentation from: https://dash.plotly.com/dash-core-components/upload Parameters: Name Description upload_kwargs keyword arguments for th dcc.Upload element. Children and style are reserved Returns: Type Description dcc.Upload Dash upload element View Source def drop_to_upload ( ** upload_kwargs ): \"\"\"Create drop to upload element. Dashed box of the active area or a clickable link to use the file dialog. Based on dash documentation from: https://dash.plotly.com/dash-core-components/upload Args: upload_kwargs: keyword arguments for th dcc.Upload element. Children and style are reserved Returns: dcc.Upload: Dash upload element \"\"\" return dcc . Upload ( children = html . Div ([ 'Drag and Drop or ' , html . A ( 'Select a File' )]), style = { 'width' : '100%' , 'height' : '60px' , 'lineHeight' : '60px' , 'borderWidth' : '1px' , 'borderStyle' : 'dashed' , 'borderRadius' : '5px' , 'textAlign' : 'center' , 'margin' : '10px' , }, ** upload_kwargs , ) file_download_link \u2693\ufe0e def file_download_link ( filename ) Create a Plotly Dash \u2018A\u2019 element that when clicked triggers a file downloaded. Parameters: Name Description filename Path to local file to be available for user download Returns: Type Description html.A clickable Dash link to trigger download View Source def file_download_link ( filename ): \"\"\"Create a Plotly Dash 'A' element that when clicked triggers a file downloaded. Args: filename: Path to local file to be available for user download Returns: html.A: clickable Dash link to trigger download \"\"\" # PLANNED: Revisit. Should filename be a name or the full path? return html . A ( filename , href = f '/download/ { urlquote ( filename ) } ' ) load_df \u2693\ufe0e def load_df ( decoded , filename ) Identify file type and parse the uploaded content into a dataframe. Parameters: Name Description decoded string contents/data of the file decoded from the full base64 file filename filename of upload file. Name only Returns: Type Description dataframe uploaded dataframe parsed from source file Raises: Type Description RuntimeError if file suffix suffix is unsupported View Source def load_df ( decoded , filename ): \"\"\"Identify file type and parse the uploaded content into a dataframe. Args: decoded: string contents/data of the file decoded from the full base64 file filename: filename of upload file. Name only Returns: dataframe: uploaded dataframe parsed from source file Raises: RuntimeError: if file suffix suffix is unsupported \"\"\" suffix = Path ( filename ) . suffix . lower () if suffix == '.csv' : df_upload = pd . read_csv ( io . StringIO ( decoded . decode ( 'utf-8' ))) elif suffix . startswith ( '.xl' ): # xlsx will have 'spreadsheet' in `content_type` but xls will not have anything df_upload = pd . read_excel ( io . BytesIO ( decoded )) elif suffix == '.json' : df_upload = parse_json ( decoded . decode ( 'utf-8' )) else : raise RuntimeError ( f 'File type ( { suffix } ) is unsupported. Expected .csv, .xl*, or .json' ) return df_upload # noqa: R504 parse_json \u2693\ufe0e def parse_json ( raw_json ) Return dataframe from JSON formatted in the \u2018records\u2019 orientation. Parameters: Name Description raw_json json string Returns: Type Description dataframe uploaded dataframe parsed from JSON Raises: Type Description RuntimeError if the JSON file can\u2019t be parsed View Source def parse_json ( raw_json ): \"\"\"Return dataframe from JSON formatted in the 'records' orientation. Args: raw_json: json string Returns: dataframe: uploaded dataframe parsed from JSON Raises: RuntimeError: if the JSON file can't be parsed \"\"\" dict_json = json . loads ( raw_json ) keys = [ * dict_json . keys ()] if len ( keys ) != 1 : raise RuntimeError ( 'Expected JSON with format `{data: [...]}` where `data` could be any key.' f 'However, more than one key was found: { keys } ' , ) return pd . DataFrame . from_records ( dict_json [ keys [ 0 ]]) parse_uploaded_df \u2693\ufe0e def parse_uploaded_df ( b64_file , filename , timestamp ) Decode base64 data and parse based on file type. Attempts to return the parsed data as a Pandas dataframe. Parameters: Name Description b64_file file encoded in base64 filename filename of upload file. Name only timestamp upload timestamp Returns: Type Description dataframe pandas dataframe parsed from source file Raises: Type Description RuntimeError if raw data could not be parsed View Source def parse_uploaded_df ( b64_file , filename , timestamp ): \"\"\"Decode base64 data and parse based on file type. Attempts to return the parsed data as a Pandas dataframe. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: dataframe: pandas dataframe parsed from source file Raises: RuntimeError: if raw data could not be parsed \"\"\" content_type , data = split_b64_file ( b64_file ) decoded = base64 . b64decode ( data ) try : df_upload = load_df ( decoded , filename ) except Exception as error : raise RuntimeError ( f 'Could not parse { filename } ( { content_type } ) \\n Error: { error } ' ) return df_upload # noqa: R504 parse_uploaded_image \u2693\ufe0e def parse_uploaded_image ( b64_file , filename , timestamp ) Create an HTML element to show an uploaded image. Parameters: Name Description b64_file file encoded in base64 filename filename of upload file. Name only timestamp upload timestamp Returns: Type Description html.Img if image data type Raises: Type Description RuntimeError if filetype is not a supported image type View Source def parse_uploaded_image ( b64_file , filename , timestamp ): \"\"\"Create an HTML element to show an uploaded image. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: html.Img: if image data type Raises: RuntimeError: if filetype is not a supported image type \"\"\" content_type , data = split_b64_file ( b64_file ) if 'image' not in content_type : raise RuntimeError ( f 'Not image type. Found: { content_type } ' ) return html . Img ( src = b64_file ) save_file \u2693\ufe0e def save_file ( dest_path , b64_file ) Decode and store a file uploaded with Plotly Dash. Parameters: Name Description dest_path Path on server filesystem to save the file b64_file file encoded in base64 View Source def save_file ( dest_path , b64_file ): \"\"\"Decode and store a file uploaded with Plotly Dash. Args: dest_path: Path on server filesystem to save the file b64_file: file encoded in base64 \"\"\" data = split_b64_file ( b64_file )[ 1 ] dest_path . write_text ( base64 . decodebytes ( data ) . decode ()) show_toast \u2693\ufe0e def show_toast ( message , header , icon = 'warning' , style = None , ** toast_kwargs ) Create toast notification. Parameters: Name Description message string body text header string notification header icon string name in (primary,secondary,success,warning,danger,info,light,dark) . Default is warning style style dictionary. Default is the top right toast_kwargs additional toast keyword arguments (such as duration=5000 ) Returns: Type Description dbc.Toast toast notification from Dash Bootstrap Components library View Source def show_toast ( message , header , icon = 'warning' , style = None , ** toast_kwargs ): \"\"\"Create toast notification. Args: message: string body text header: string notification header icon: string name in `(primary,secondary,success,warning,danger,info,light,dark)`. Default is warning style: style dictionary. Default is the top right toast_kwargs: additional toast keyword arguments (such as `duration=5000`) Returns: dbc.Toast: toast notification from Dash Bootstrap Components library \"\"\" if style is None : # Position in the top right (note: will occlude the tabs when open, could be moved elsewhere) style = { 'position' : 'fixed' , 'top' : 10 , 'right' : 10 , 'width' : 350 , 'zIndex' : 1900 } return dbc . Toast ( message , header = header , icon = icon , style = style , dismissable = True , ** toast_kwargs ) split_b64_file \u2693\ufe0e def split_b64_file ( b64_file ) Separate the data type and data content from a b64-encoded string. Parameters: Name Description b64_file file encoded in base64 Returns: Type Description tuple of strings (content_type, data) View Source def split_b64_file ( b64_file ): \"\"\"Separate the data type and data content from a b64-encoded string. Args: b64_file: file encoded in base64 Returns: tuple: of strings `(content_type, data)` \"\"\" return b64_file . encode ( 'utf8' ) . split ( b ';base64,' ) uploaded_files \u2693\ufe0e def uploaded_files ( upload_dir ) List the files in the upload directory. Parameters: Name Description upload_dir directory where files are uploadedfolder Returns: Type Description list Paths of uploaded files View Source def uploaded_files ( upload_dir ): \"\"\"List the files in the upload directory. Args: upload_dir: directory where files are uploadedfolder Returns: list: Paths of uploaded files \"\"\" return [ * upload_dir . glob ( '*.*' )] Classes \u2693\ufe0e UploadModule \u2693\ufe0e class UploadModule ( * args , ** kwargs ) View Source class UploadModule ( ModuleBase ): # noqa: H601 \"\"\"Module for user data upload. Note: this is not intended to be secure \"\"\" id_upload = 'upload-drop-area' \"\"\"Unique name for the upload component.\"\"\" id_upload_output = 'upload-output' \"\"\"Unique name for the div to contain output of the parse-upload.\"\"\" id_username_cache = 'username-cache' \"\"\"Unique name for the dcc.Store element to store the current username.\"\"\" all_ids = [ id_upload , id_upload_output , id_username_cache ] \"\"\"List of ids to register for this module.\"\"\" cache_dir = CACHE_DIR \"\"\"Path to the directory to use for caching files.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize module.\"\"\" # noqa: DAR101 super () . __init__ ( * args , ** kwargs ) self . _initialize_database () def _initialize_database ( self ): \"\"\"Create data members `(self.database, self.user_table, self.inventory_table)`.\"\"\" self . database = DBConnect ( self . cache_dir / f '_placeholder_app- { self . name } .db' ) self . user_table = self . database . db . create_table ( 'users' , primary_id = 'username' , primary_type = self . database . db . types . text , ) self . inventory_table = self . database . db . create_table ( 'inventory' , primary_id = 'table_name' , primary_type = self . database . db . types . text , ) def find_user ( self , username ): \"\"\"Return the database row for the specified user. Args: username: string username Returns: dict: for row from table or None if no match \"\"\" return self . user_table . find_one ( username = username ) def add_user ( self , username ): \"\"\"Add the user to the table or update the user's information if already registered. Args: username: string username \"\"\" now = time . time () if self . find_user ( username ): self . user_table . upsert ({ 'username' : username , 'last_loaded' : now }, [ 'username' ]) else : self . user_table . insert ({ 'username' : username , 'creation' : now , 'last_loaded' : now }) def upload_data ( self , username , df_name , df_upload ): \"\"\"Store dataframe in database for specified user. Args: username: string username df_name: name of the stored dataframe df_upload: pandas dataframe to store Raises: Exception: If upload fails, deletes the created table \"\"\" now = time . time () table_name = f ' { username } - { df_name } - { int ( now ) } ' table = self . database . db . create_table ( table_name ) try : table . insert_many ( df_upload . to_dict ( orient = 'records' )) except Exception : table . drop () # Delete the table if upload fails raise self . inventory_table . insert ({ 'table_name' : table_name , 'df_name' : df_name , 'username' : username , 'creation' : now , }) def get_data ( self , table_name ): \"\"\"Retrieve stored data for specified dataframe name. Args: table_name: unique name of the table to retrieve Returns: pd.DataFrame: pandas dataframe retrieved from the database \"\"\" table = self . database . db . load_table ( table_name ) return pd . DataFrame . from_records ( table . all ()) def delete_data ( self , table_name ): \"\"\"Remove specified data from the database. Args: table_name: unique name of the table to delete \"\"\" self . database . db . load_table ( table_name ) . drop () def return_layout ( self , ids ): \"\"\"Return the Upload module application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object. \"\"\" return html . Div ([ dcc . Store ( id = ids [ self . get ( self . id_username_cache )], storage_type = 'session' ), html . H2 ( 'File Upload' ), html . P ( 'Upload Tidy Data in CSV, Excel, or JSON format' ), drop_to_upload ( id = ids [ self . get ( self . id_upload )]), dcc . Loading ( html . Div ( '' , id = ids [ self . get ( self . id_upload_output )]), type = 'circle' ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_upload_handler ( parent ) def _show_data ( self , username ): \"\"\"Create Dash HTML to show the raw data loaded for the specified user. Args: username: string username Returns: dict: Dash HTML object \"\"\" # TODO: Add delete button for each table - need pattern matching callback: # https://dash.plotly.com/pattern-matching-callbacks def format_table ( df_name , username , creation , raw_df ): user_str = f 'by \" { username } \" ' if username else '' return [ html . H4 ( df_name ), html . P ( f 'Uploaded { user_str } on { datetime . fromtimestamp ( creation ) } (Note: only first 10 rows & 10 col)' ), dash_table . DataTable ( data = raw_df [: 10 ] . to_dict ( 'records' ), columns = [{ 'name' : i , 'id' : i } for i in raw_df . columns [: 10 ]], style_cell = { 'overflow' : 'hidden' , 'textOverflow' : 'ellipsis' , 'maxWidth' : 0 , }, ), html . Hr (), ] children = [ html . Hr ()] rows = self . inventory_table . find ( username = username ) for row in sorted ( rows , key = lambda _row : _row [ 'creation' ], reverse = True ): df_upload = self . get_data ( row [ 'table_name' ]) children . extend ( format_table ( row [ 'df_name' ], row [ 'username' ], row [ 'creation' ], df_upload )) return html . Div ( children ) def register_upload_handler ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_upload_output ), 'children' )] inputs = [( self . get ( self . id_upload ), 'contents' ), ( self . get ( self . id_username_cache ), 'data' )] states = [( self . get ( self . id_upload ), 'filename' ), ( self . get ( self . id_upload ), 'last_modified' )] @parent . callback ( outputs , inputs , states , pic = True ) def upload_handler ( * raw_args ): a_in , a_state = map_args ( raw_args , inputs , states ) b64_file = a_in [ self . get ( self . id_upload )][ 'contents' ] username = a_in [ self . get ( self . id_username_cache )][ 'data' ] filename = a_state [ self . get ( self . id_upload )][ 'filename' ] timestamp = a_state [ self . get ( self . id_upload )][ 'last_modified' ] child_output = [] try : if b64_file is not None : df_upload = parse_uploaded_df ( b64_file , filename , timestamp ) df_upload = df_upload . dropna ( axis = 'columns' ) # FIXME: Better handle NaN values... self . add_user ( username ) self . upload_data ( username , filename , df_upload ) except Exception as error : child_output . extend ([ show_toast ( f ' { error } ' , 'Upload Error' , icon = 'danger' ), dcc . Markdown ( f '### Upload Error \\n\\n { type ( error ) } \\n\\n ``` \\n { error } \\n ```' ), ]) child_output . append ( self . _show_data ( username )) return map_outputs ( outputs , [( self . get ( self . id_upload_output ), 'children' , html . Div ( child_output ))]) Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_modules.ModuleBase Class variables \u2693\ufe0e all_ids List of ids to register for this module. cache_dir Path to the directory to use for caching files. id_upload Unique name for the upload component. id_upload_output Unique name for the div to contain output of the parse-upload. id_username_cache Unique name for the dcc.Store element to store the current username. Methods \u2693\ufe0e add_user \u2693\ufe0e def add_user ( self , username ) Add the user to the table or update the user\u2019s information if already registered. Parameters: Name Description username string username View Source def add_user ( self , username ): \"\"\"Add the user to the table or update the user's information if already registered. Args: username: string username \"\"\" now = time . time () if self . find_user ( username ): self . user_table . upsert ({ 'username' : username , 'last_loaded' : now }, [ 'username' ]) else : self . user_table . insert ({ 'username' : username , 'creation' : now , 'last_loaded' : now }) create_callbacks \u2693\ufe0e def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_upload_handler ( parent ) create_elements \u2693\ufe0e def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover delete_data \u2693\ufe0e def delete_data ( self , table_name ) Remove specified data from the database. Parameters: Name Description table_name unique name of the table to delete View Source def delete_data ( self , table_name ): \"\"\"Remove specified data from the database. Args: table_name: unique name of the table to delete \"\"\" self . database . db . load_table ( table_name ) . drop () find_user \u2693\ufe0e def find_user ( self , username ) Return the database row for the specified user. Parameters: Name Description username string username Returns: Type Description dict for row from table or None if no match View Source def find_user ( self , username ): \"\"\"Return the database row for the specified user. Args: username: string username Returns: dict: for row from table or None if no match \"\"\" return self . user_table . find_one ( username = username ) get \u2693\ufe0e def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] get_data \u2693\ufe0e def get_data ( self , table_name ) Retrieve stored data for specified dataframe name. Parameters: Name Description table_name unique name of the table to retrieve Returns: Type Description pd.DataFrame pandas dataframe retrieved from the database View Source def get_data ( self , table_name ): \"\"\"Retrieve stored data for specified dataframe name. Args: table_name: unique name of the table to retrieve Returns: pd.DataFrame: pandas dataframe retrieved from the database \"\"\" table = self . database . db . load_table ( table_name ) return pd . DataFrame . from_records ( table . all ()) initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... register_upload_handler \u2693\ufe0e def register_upload_handler ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def register_upload_handler ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_upload_output ), 'children' )] inputs = [( self . get ( self . id_upload ), 'contents' ), ( self . get ( self . id_username_cache ), 'data' )] states = [( self . get ( self . id_upload ), 'filename' ), ( self . get ( self . id_upload ), 'last_modified' )] @parent . callback ( outputs , inputs , states , pic = True ) def upload_handler ( * raw_args ): a_in , a_state = map_args ( raw_args , inputs , states ) b64_file = a_in [ self . get ( self . id_upload )][ 'contents' ] username = a_in [ self . get ( self . id_username_cache )][ 'data' ] filename = a_state [ self . get ( self . id_upload )][ 'filename' ] timestamp = a_state [ self . get ( self . id_upload )][ 'last_modified' ] child_output = [] try : if b64_file is not None : df_upload = parse_uploaded_df ( b64_file , filename , timestamp ) df_upload = df_upload . dropna ( axis = 'columns' ) # FIXME: Better handle NaN values... self . add_user ( username ) self . upload_data ( username , filename , df_upload ) except Exception as error : child_output . extend ([ show_toast ( f ' { error } ' , 'Upload Error' , icon = 'danger' ), dcc . Markdown ( f '### Upload Error \\n\\n { type ( error ) } \\n\\n ``` \\n { error } \\n ```' ), ]) child_output . append ( self . _show_data ( username )) return map_outputs ( outputs , [( self . get ( self . id_upload_output ), 'children' , html . Div ( child_output ))]) return_layout \u2693\ufe0e def return_layout ( self , ids ) Return the Upload module application layout. Parameters: Name Description ids self._il from base application Returns: Type Description dict Dash HTML object. View Source def return_layout ( self , ids ): \"\"\"Return the Upload module application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object. \"\"\" return html . Div ([ dcc . Store ( id = ids [ self . get ( self . id_username_cache )], storage_type = 'session' ), html . H2 ( 'File Upload' ), html . P ( 'Upload Tidy Data in CSV, Excel, or JSON format' ), drop_to_upload ( id = ids [ self . get ( self . id_upload )]), dcc . Loading ( html . Div ( '' , id = ids [ self . get ( self . id_upload_output )]), type = 'circle' ), ]) upload_data \u2693\ufe0e def upload_data ( self , username , df_name , df_upload ) Store dataframe in database for specified user. Parameters: Name Description username string username df_name name of the stored dataframe df_upload pandas dataframe to store Raises: Type Description Exception If upload fails, deletes the created table View Source def upload_data ( self , username , df_name , df_upload ): \"\"\"Store dataframe in database for specified user. Args: username: string username df_name: name of the stored dataframe df_upload: pandas dataframe to store Raises: Exception: If upload fails, deletes the created table \"\"\" now = time . time () table_name = f ' { username } - { df_name } - { int ( now ) } ' table = self . database . db . create_table ( table_name ) try : table . insert_many ( df_upload . to_dict ( orient = 'records' )) except Exception : table . drop () # Delete the table if upload fails raise self . inventory_table . insert ({ 'table_name' : table_name , 'df_name' : df_name , 'username' : username , 'creation' : now , })","title":"dash_charts.modules_upload"},{"location":"modules/dash_charts/modules_upload/#dash_chartsmodules_upload","text":"Upload module and helpers for managing file upload and download. Some functions based on code from: https://docs.faculty.ai/user-guide/apps/examples/dash_file_upload_download.html View Source \"\"\"Upload module and helpers for managing file upload and download. Some functions based on code from: https://docs.faculty.ai/user-guide/apps/examples/dash_file_upload_download.html \"\"\" import base64 import io import json import time from datetime import datetime from pathlib import Path from urllib.parse import quote as urlquote import dash_bootstrap_components as dbc import pandas as pd from dash import dash_table , dcc , html from .utils_app_modules import ModuleBase from .utils_callbacks import map_args , map_outputs from .utils_dataset import DBConnect from .utils_json_cache import CACHE_DIR def split_b64_file ( b64_file ): \"\"\"Separate the data type and data content from a b64-encoded string. Args: b64_file: file encoded in base64 Returns: tuple: of strings `(content_type, data)` \"\"\" return b64_file . encode ( 'utf8' ) . split ( b ';base64,' ) def save_file ( dest_path , b64_file ): \"\"\"Decode and store a file uploaded with Plotly Dash. Args: dest_path: Path on server filesystem to save the file b64_file: file encoded in base64 \"\"\" data = split_b64_file ( b64_file )[ 1 ] dest_path . write_text ( base64 . decodebytes ( data ) . decode ()) def uploaded_files ( upload_dir ): \"\"\"List the files in the upload directory. Args: upload_dir: directory where files are uploadedfolder Returns: list: Paths of uploaded files \"\"\" return [ * upload_dir . glob ( '*.*' )] def file_download_link ( filename ): \"\"\"Create a Plotly Dash 'A' element that when clicked triggers a file downloaded. Args: filename: Path to local file to be available for user download Returns: html.A: clickable Dash link to trigger download \"\"\" # PLANNED: Revisit. Should filename be a name or the full path? return html . A ( filename , href = f '/download/ { urlquote ( filename ) } ' ) def parse_uploaded_image ( b64_file , filename , timestamp ): \"\"\"Create an HTML element to show an uploaded image. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: html.Img: if image data type Raises: RuntimeError: if filetype is not a supported image type \"\"\" content_type , data = split_b64_file ( b64_file ) if 'image' not in content_type : raise RuntimeError ( f 'Not image type. Found: { content_type } ' ) return html . Img ( src = b64_file ) def parse_json ( raw_json ): \"\"\"Return dataframe from JSON formatted in the 'records' orientation. Args: raw_json: json string Returns: dataframe: uploaded dataframe parsed from JSON Raises: RuntimeError: if the JSON file can't be parsed \"\"\" dict_json = json . loads ( raw_json ) keys = [ * dict_json . keys ()] if len ( keys ) != 1 : raise RuntimeError ( 'Expected JSON with format `{data: [...]}` where `data` could be any key.' f 'However, more than one key was found: { keys } ' , ) return pd . DataFrame . from_records ( dict_json [ keys [ 0 ]]) def load_df ( decoded , filename ): \"\"\"Identify file type and parse the uploaded content into a dataframe. Args: decoded: string contents/data of the file decoded from the full base64 file filename: filename of upload file. Name only Returns: dataframe: uploaded dataframe parsed from source file Raises: RuntimeError: if file suffix suffix is unsupported \"\"\" suffix = Path ( filename ) . suffix . lower () if suffix == '.csv' : df_upload = pd . read_csv ( io . StringIO ( decoded . decode ( 'utf-8' ))) elif suffix . startswith ( '.xl' ): # xlsx will have 'spreadsheet' in `content_type` but xls will not have anything df_upload = pd . read_excel ( io . BytesIO ( decoded )) elif suffix == '.json' : df_upload = parse_json ( decoded . decode ( 'utf-8' )) else : raise RuntimeError ( f 'File type ( { suffix } ) is unsupported. Expected .csv, .xl*, or .json' ) return df_upload # noqa: R504 def parse_uploaded_df ( b64_file , filename , timestamp ): \"\"\"Decode base64 data and parse based on file type. Attempts to return the parsed data as a Pandas dataframe. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: dataframe: pandas dataframe parsed from source file Raises: RuntimeError: if raw data could not be parsed \"\"\" content_type , data = split_b64_file ( b64_file ) decoded = base64 . b64decode ( data ) try : df_upload = load_df ( decoded , filename ) except Exception as error : raise RuntimeError ( f 'Could not parse { filename } ( { content_type } ) \\n Error: { error } ' ) return df_upload # noqa: R504 def show_toast ( message , header , icon = 'warning' , style = None , ** toast_kwargs ): \"\"\"Create toast notification. Args: message: string body text header: string notification header icon: string name in `(primary,secondary,success,warning,danger,info,light,dark)`. Default is warning style: style dictionary. Default is the top right toast_kwargs: additional toast keyword arguments (such as `duration=5000`) Returns: dbc.Toast: toast notification from Dash Bootstrap Components library \"\"\" if style is None : # Position in the top right (note: will occlude the tabs when open, could be moved elsewhere) style = { 'position' : 'fixed' , 'top' : 10 , 'right' : 10 , 'width' : 350 , 'zIndex' : 1900 } return dbc . Toast ( message , header = header , icon = icon , style = style , dismissable = True , ** toast_kwargs ) def drop_to_upload ( ** upload_kwargs ): \"\"\"Create drop to upload element. Dashed box of the active area or a clickable link to use the file dialog. Based on dash documentation from: https://dash.plotly.com/dash-core-components/upload Args: upload_kwargs: keyword arguments for th dcc.Upload element. Children and style are reserved Returns: dcc.Upload: Dash upload element \"\"\" return dcc . Upload ( children = html . Div ([ 'Drag and Drop or ' , html . A ( 'Select a File' )]), style = { 'width' : '100%' , 'height' : '60px' , 'lineHeight' : '60px' , 'borderWidth' : '1px' , 'borderStyle' : 'dashed' , 'borderRadius' : '5px' , 'textAlign' : 'center' , 'margin' : '10px' , }, ** upload_kwargs , ) class UploadModule ( ModuleBase ): # noqa: H601 \"\"\"Module for user data upload. Note: this is not intended to be secure \"\"\" id_upload = 'upload-drop-area' \"\"\"Unique name for the upload component.\"\"\" id_upload_output = 'upload-output' \"\"\"Unique name for the div to contain output of the parse-upload.\"\"\" id_username_cache = 'username-cache' \"\"\"Unique name for the dcc.Store element to store the current username.\"\"\" all_ids = [ id_upload , id_upload_output , id_username_cache ] \"\"\"List of ids to register for this module.\"\"\" cache_dir = CACHE_DIR \"\"\"Path to the directory to use for caching files.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize module.\"\"\" # noqa: DAR101 super () . __init__ ( * args , ** kwargs ) self . _initialize_database () def _initialize_database ( self ): \"\"\"Create data members `(self.database, self.user_table, self.inventory_table)`.\"\"\" self . database = DBConnect ( self . cache_dir / f '_placeholder_app- { self . name } .db' ) self . user_table = self . database . db . create_table ( 'users' , primary_id = 'username' , primary_type = self . database . db . types . text , ) self . inventory_table = self . database . db . create_table ( 'inventory' , primary_id = 'table_name' , primary_type = self . database . db . types . text , ) def find_user ( self , username ): \"\"\"Return the database row for the specified user. Args: username: string username Returns: dict: for row from table or None if no match \"\"\" return self . user_table . find_one ( username = username ) def add_user ( self , username ): \"\"\"Add the user to the table or update the user's information if already registered. Args: username: string username \"\"\" now = time . time () if self . find_user ( username ): self . user_table . upsert ({ 'username' : username , 'last_loaded' : now }, [ 'username' ]) else : self . user_table . insert ({ 'username' : username , 'creation' : now , 'last_loaded' : now }) def upload_data ( self , username , df_name , df_upload ): \"\"\"Store dataframe in database for specified user. Args: username: string username df_name: name of the stored dataframe df_upload: pandas dataframe to store Raises: Exception: If upload fails, deletes the created table \"\"\" now = time . time () table_name = f ' { username } - { df_name } - { int ( now ) } ' table = self . database . db . create_table ( table_name ) try : table . insert_many ( df_upload . to_dict ( orient = 'records' )) except Exception : table . drop () # Delete the table if upload fails raise self . inventory_table . insert ({ 'table_name' : table_name , 'df_name' : df_name , 'username' : username , 'creation' : now , }) def get_data ( self , table_name ): \"\"\"Retrieve stored data for specified dataframe name. Args: table_name: unique name of the table to retrieve Returns: pd.DataFrame: pandas dataframe retrieved from the database \"\"\" table = self . database . db . load_table ( table_name ) return pd . DataFrame . from_records ( table . all ()) def delete_data ( self , table_name ): \"\"\"Remove specified data from the database. Args: table_name: unique name of the table to delete \"\"\" self . database . db . load_table ( table_name ) . drop () def return_layout ( self , ids ): \"\"\"Return the Upload module application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object. \"\"\" return html . Div ([ dcc . Store ( id = ids [ self . get ( self . id_username_cache )], storage_type = 'session' ), html . H2 ( 'File Upload' ), html . P ( 'Upload Tidy Data in CSV, Excel, or JSON format' ), drop_to_upload ( id = ids [ self . get ( self . id_upload )]), dcc . Loading ( html . Div ( '' , id = ids [ self . get ( self . id_upload_output )]), type = 'circle' ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_upload_handler ( parent ) def _show_data ( self , username ): \"\"\"Create Dash HTML to show the raw data loaded for the specified user. Args: username: string username Returns: dict: Dash HTML object \"\"\" # TODO: Add delete button for each table - need pattern matching callback: # https://dash.plotly.com/pattern-matching-callbacks def format_table ( df_name , username , creation , raw_df ): user_str = f 'by \" { username } \" ' if username else '' return [ html . H4 ( df_name ), html . P ( f 'Uploaded { user_str } on { datetime . fromtimestamp ( creation ) } (Note: only first 10 rows & 10 col)' ), dash_table . DataTable ( data = raw_df [: 10 ] . to_dict ( 'records' ), columns = [{ 'name' : i , 'id' : i } for i in raw_df . columns [: 10 ]], style_cell = { 'overflow' : 'hidden' , 'textOverflow' : 'ellipsis' , 'maxWidth' : 0 , }, ), html . Hr (), ] children = [ html . Hr ()] rows = self . inventory_table . find ( username = username ) for row in sorted ( rows , key = lambda _row : _row [ 'creation' ], reverse = True ): df_upload = self . get_data ( row [ 'table_name' ]) children . extend ( format_table ( row [ 'df_name' ], row [ 'username' ], row [ 'creation' ], df_upload )) return html . Div ( children ) def register_upload_handler ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_upload_output ), 'children' )] inputs = [( self . get ( self . id_upload ), 'contents' ), ( self . get ( self . id_username_cache ), 'data' )] states = [( self . get ( self . id_upload ), 'filename' ), ( self . get ( self . id_upload ), 'last_modified' )] @parent . callback ( outputs , inputs , states , pic = True ) def upload_handler ( * raw_args ): a_in , a_state = map_args ( raw_args , inputs , states ) b64_file = a_in [ self . get ( self . id_upload )][ 'contents' ] username = a_in [ self . get ( self . id_username_cache )][ 'data' ] filename = a_state [ self . get ( self . id_upload )][ 'filename' ] timestamp = a_state [ self . get ( self . id_upload )][ 'last_modified' ] child_output = [] try : if b64_file is not None : df_upload = parse_uploaded_df ( b64_file , filename , timestamp ) df_upload = df_upload . dropna ( axis = 'columns' ) # FIXME: Better handle NaN values... self . add_user ( username ) self . upload_data ( username , filename , df_upload ) except Exception as error : child_output . extend ([ show_toast ( f ' { error } ' , 'Upload Error' , icon = 'danger' ), dcc . Markdown ( f '### Upload Error \\n\\n { type ( error ) } \\n\\n ``` \\n { error } \\n ```' ), ]) child_output . append ( self . _show_data ( username )) return map_outputs ( outputs , [( self . get ( self . id_upload_output ), 'children' , html . Div ( child_output ))])","title":"dash_charts.modules_upload"},{"location":"modules/dash_charts/modules_upload/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/modules_upload/#drop_to_upload","text":"def drop_to_upload ( ** upload_kwargs ) Create drop to upload element. Dashed box of the active area or a clickable link to use the file dialog. Based on dash documentation from: https://dash.plotly.com/dash-core-components/upload Parameters: Name Description upload_kwargs keyword arguments for th dcc.Upload element. Children and style are reserved Returns: Type Description dcc.Upload Dash upload element View Source def drop_to_upload ( ** upload_kwargs ): \"\"\"Create drop to upload element. Dashed box of the active area or a clickable link to use the file dialog. Based on dash documentation from: https://dash.plotly.com/dash-core-components/upload Args: upload_kwargs: keyword arguments for th dcc.Upload element. Children and style are reserved Returns: dcc.Upload: Dash upload element \"\"\" return dcc . Upload ( children = html . Div ([ 'Drag and Drop or ' , html . A ( 'Select a File' )]), style = { 'width' : '100%' , 'height' : '60px' , 'lineHeight' : '60px' , 'borderWidth' : '1px' , 'borderStyle' : 'dashed' , 'borderRadius' : '5px' , 'textAlign' : 'center' , 'margin' : '10px' , }, ** upload_kwargs , )","title":"drop_to_upload"},{"location":"modules/dash_charts/modules_upload/#file_download_link","text":"def file_download_link ( filename ) Create a Plotly Dash \u2018A\u2019 element that when clicked triggers a file downloaded. Parameters: Name Description filename Path to local file to be available for user download Returns: Type Description html.A clickable Dash link to trigger download View Source def file_download_link ( filename ): \"\"\"Create a Plotly Dash 'A' element that when clicked triggers a file downloaded. Args: filename: Path to local file to be available for user download Returns: html.A: clickable Dash link to trigger download \"\"\" # PLANNED: Revisit. Should filename be a name or the full path? return html . A ( filename , href = f '/download/ { urlquote ( filename ) } ' )","title":"file_download_link"},{"location":"modules/dash_charts/modules_upload/#load_df","text":"def load_df ( decoded , filename ) Identify file type and parse the uploaded content into a dataframe. Parameters: Name Description decoded string contents/data of the file decoded from the full base64 file filename filename of upload file. Name only Returns: Type Description dataframe uploaded dataframe parsed from source file Raises: Type Description RuntimeError if file suffix suffix is unsupported View Source def load_df ( decoded , filename ): \"\"\"Identify file type and parse the uploaded content into a dataframe. Args: decoded: string contents/data of the file decoded from the full base64 file filename: filename of upload file. Name only Returns: dataframe: uploaded dataframe parsed from source file Raises: RuntimeError: if file suffix suffix is unsupported \"\"\" suffix = Path ( filename ) . suffix . lower () if suffix == '.csv' : df_upload = pd . read_csv ( io . StringIO ( decoded . decode ( 'utf-8' ))) elif suffix . startswith ( '.xl' ): # xlsx will have 'spreadsheet' in `content_type` but xls will not have anything df_upload = pd . read_excel ( io . BytesIO ( decoded )) elif suffix == '.json' : df_upload = parse_json ( decoded . decode ( 'utf-8' )) else : raise RuntimeError ( f 'File type ( { suffix } ) is unsupported. Expected .csv, .xl*, or .json' ) return df_upload # noqa: R504","title":"load_df"},{"location":"modules/dash_charts/modules_upload/#parse_json","text":"def parse_json ( raw_json ) Return dataframe from JSON formatted in the \u2018records\u2019 orientation. Parameters: Name Description raw_json json string Returns: Type Description dataframe uploaded dataframe parsed from JSON Raises: Type Description RuntimeError if the JSON file can\u2019t be parsed View Source def parse_json ( raw_json ): \"\"\"Return dataframe from JSON formatted in the 'records' orientation. Args: raw_json: json string Returns: dataframe: uploaded dataframe parsed from JSON Raises: RuntimeError: if the JSON file can't be parsed \"\"\" dict_json = json . loads ( raw_json ) keys = [ * dict_json . keys ()] if len ( keys ) != 1 : raise RuntimeError ( 'Expected JSON with format `{data: [...]}` where `data` could be any key.' f 'However, more than one key was found: { keys } ' , ) return pd . DataFrame . from_records ( dict_json [ keys [ 0 ]])","title":"parse_json"},{"location":"modules/dash_charts/modules_upload/#parse_uploaded_df","text":"def parse_uploaded_df ( b64_file , filename , timestamp ) Decode base64 data and parse based on file type. Attempts to return the parsed data as a Pandas dataframe. Parameters: Name Description b64_file file encoded in base64 filename filename of upload file. Name only timestamp upload timestamp Returns: Type Description dataframe pandas dataframe parsed from source file Raises: Type Description RuntimeError if raw data could not be parsed View Source def parse_uploaded_df ( b64_file , filename , timestamp ): \"\"\"Decode base64 data and parse based on file type. Attempts to return the parsed data as a Pandas dataframe. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: dataframe: pandas dataframe parsed from source file Raises: RuntimeError: if raw data could not be parsed \"\"\" content_type , data = split_b64_file ( b64_file ) decoded = base64 . b64decode ( data ) try : df_upload = load_df ( decoded , filename ) except Exception as error : raise RuntimeError ( f 'Could not parse { filename } ( { content_type } ) \\n Error: { error } ' ) return df_upload # noqa: R504","title":"parse_uploaded_df"},{"location":"modules/dash_charts/modules_upload/#parse_uploaded_image","text":"def parse_uploaded_image ( b64_file , filename , timestamp ) Create an HTML element to show an uploaded image. Parameters: Name Description b64_file file encoded in base64 filename filename of upload file. Name only timestamp upload timestamp Returns: Type Description html.Img if image data type Raises: Type Description RuntimeError if filetype is not a supported image type View Source def parse_uploaded_image ( b64_file , filename , timestamp ): \"\"\"Create an HTML element to show an uploaded image. Args: b64_file: file encoded in base64 filename: filename of upload file. Name only timestamp: upload timestamp Returns: html.Img: if image data type Raises: RuntimeError: if filetype is not a supported image type \"\"\" content_type , data = split_b64_file ( b64_file ) if 'image' not in content_type : raise RuntimeError ( f 'Not image type. Found: { content_type } ' ) return html . Img ( src = b64_file )","title":"parse_uploaded_image"},{"location":"modules/dash_charts/modules_upload/#save_file","text":"def save_file ( dest_path , b64_file ) Decode and store a file uploaded with Plotly Dash. Parameters: Name Description dest_path Path on server filesystem to save the file b64_file file encoded in base64 View Source def save_file ( dest_path , b64_file ): \"\"\"Decode and store a file uploaded with Plotly Dash. Args: dest_path: Path on server filesystem to save the file b64_file: file encoded in base64 \"\"\" data = split_b64_file ( b64_file )[ 1 ] dest_path . write_text ( base64 . decodebytes ( data ) . decode ())","title":"save_file"},{"location":"modules/dash_charts/modules_upload/#show_toast","text":"def show_toast ( message , header , icon = 'warning' , style = None , ** toast_kwargs ) Create toast notification. Parameters: Name Description message string body text header string notification header icon string name in (primary,secondary,success,warning,danger,info,light,dark) . Default is warning style style dictionary. Default is the top right toast_kwargs additional toast keyword arguments (such as duration=5000 ) Returns: Type Description dbc.Toast toast notification from Dash Bootstrap Components library View Source def show_toast ( message , header , icon = 'warning' , style = None , ** toast_kwargs ): \"\"\"Create toast notification. Args: message: string body text header: string notification header icon: string name in `(primary,secondary,success,warning,danger,info,light,dark)`. Default is warning style: style dictionary. Default is the top right toast_kwargs: additional toast keyword arguments (such as `duration=5000`) Returns: dbc.Toast: toast notification from Dash Bootstrap Components library \"\"\" if style is None : # Position in the top right (note: will occlude the tabs when open, could be moved elsewhere) style = { 'position' : 'fixed' , 'top' : 10 , 'right' : 10 , 'width' : 350 , 'zIndex' : 1900 } return dbc . Toast ( message , header = header , icon = icon , style = style , dismissable = True , ** toast_kwargs )","title":"show_toast"},{"location":"modules/dash_charts/modules_upload/#split_b64_file","text":"def split_b64_file ( b64_file ) Separate the data type and data content from a b64-encoded string. Parameters: Name Description b64_file file encoded in base64 Returns: Type Description tuple of strings (content_type, data) View Source def split_b64_file ( b64_file ): \"\"\"Separate the data type and data content from a b64-encoded string. Args: b64_file: file encoded in base64 Returns: tuple: of strings `(content_type, data)` \"\"\" return b64_file . encode ( 'utf8' ) . split ( b ';base64,' )","title":"split_b64_file"},{"location":"modules/dash_charts/modules_upload/#uploaded_files","text":"def uploaded_files ( upload_dir ) List the files in the upload directory. Parameters: Name Description upload_dir directory where files are uploadedfolder Returns: Type Description list Paths of uploaded files View Source def uploaded_files ( upload_dir ): \"\"\"List the files in the upload directory. Args: upload_dir: directory where files are uploadedfolder Returns: list: Paths of uploaded files \"\"\" return [ * upload_dir . glob ( '*.*' )]","title":"uploaded_files"},{"location":"modules/dash_charts/modules_upload/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/modules_upload/#uploadmodule","text":"class UploadModule ( * args , ** kwargs ) View Source class UploadModule ( ModuleBase ): # noqa: H601 \"\"\"Module for user data upload. Note: this is not intended to be secure \"\"\" id_upload = 'upload-drop-area' \"\"\"Unique name for the upload component.\"\"\" id_upload_output = 'upload-output' \"\"\"Unique name for the div to contain output of the parse-upload.\"\"\" id_username_cache = 'username-cache' \"\"\"Unique name for the dcc.Store element to store the current username.\"\"\" all_ids = [ id_upload , id_upload_output , id_username_cache ] \"\"\"List of ids to register for this module.\"\"\" cache_dir = CACHE_DIR \"\"\"Path to the directory to use for caching files.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize module.\"\"\" # noqa: DAR101 super () . __init__ ( * args , ** kwargs ) self . _initialize_database () def _initialize_database ( self ): \"\"\"Create data members `(self.database, self.user_table, self.inventory_table)`.\"\"\" self . database = DBConnect ( self . cache_dir / f '_placeholder_app- { self . name } .db' ) self . user_table = self . database . db . create_table ( 'users' , primary_id = 'username' , primary_type = self . database . db . types . text , ) self . inventory_table = self . database . db . create_table ( 'inventory' , primary_id = 'table_name' , primary_type = self . database . db . types . text , ) def find_user ( self , username ): \"\"\"Return the database row for the specified user. Args: username: string username Returns: dict: for row from table or None if no match \"\"\" return self . user_table . find_one ( username = username ) def add_user ( self , username ): \"\"\"Add the user to the table or update the user's information if already registered. Args: username: string username \"\"\" now = time . time () if self . find_user ( username ): self . user_table . upsert ({ 'username' : username , 'last_loaded' : now }, [ 'username' ]) else : self . user_table . insert ({ 'username' : username , 'creation' : now , 'last_loaded' : now }) def upload_data ( self , username , df_name , df_upload ): \"\"\"Store dataframe in database for specified user. Args: username: string username df_name: name of the stored dataframe df_upload: pandas dataframe to store Raises: Exception: If upload fails, deletes the created table \"\"\" now = time . time () table_name = f ' { username } - { df_name } - { int ( now ) } ' table = self . database . db . create_table ( table_name ) try : table . insert_many ( df_upload . to_dict ( orient = 'records' )) except Exception : table . drop () # Delete the table if upload fails raise self . inventory_table . insert ({ 'table_name' : table_name , 'df_name' : df_name , 'username' : username , 'creation' : now , }) def get_data ( self , table_name ): \"\"\"Retrieve stored data for specified dataframe name. Args: table_name: unique name of the table to retrieve Returns: pd.DataFrame: pandas dataframe retrieved from the database \"\"\" table = self . database . db . load_table ( table_name ) return pd . DataFrame . from_records ( table . all ()) def delete_data ( self , table_name ): \"\"\"Remove specified data from the database. Args: table_name: unique name of the table to delete \"\"\" self . database . db . load_table ( table_name ) . drop () def return_layout ( self , ids ): \"\"\"Return the Upload module application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object. \"\"\" return html . Div ([ dcc . Store ( id = ids [ self . get ( self . id_username_cache )], storage_type = 'session' ), html . H2 ( 'File Upload' ), html . P ( 'Upload Tidy Data in CSV, Excel, or JSON format' ), drop_to_upload ( id = ids [ self . get ( self . id_upload )]), dcc . Loading ( html . Div ( '' , id = ids [ self . get ( self . id_upload_output )]), type = 'circle' ), ]) def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_upload_handler ( parent ) def _show_data ( self , username ): \"\"\"Create Dash HTML to show the raw data loaded for the specified user. Args: username: string username Returns: dict: Dash HTML object \"\"\" # TODO: Add delete button for each table - need pattern matching callback: # https://dash.plotly.com/pattern-matching-callbacks def format_table ( df_name , username , creation , raw_df ): user_str = f 'by \" { username } \" ' if username else '' return [ html . H4 ( df_name ), html . P ( f 'Uploaded { user_str } on { datetime . fromtimestamp ( creation ) } (Note: only first 10 rows & 10 col)' ), dash_table . DataTable ( data = raw_df [: 10 ] . to_dict ( 'records' ), columns = [{ 'name' : i , 'id' : i } for i in raw_df . columns [: 10 ]], style_cell = { 'overflow' : 'hidden' , 'textOverflow' : 'ellipsis' , 'maxWidth' : 0 , }, ), html . Hr (), ] children = [ html . Hr ()] rows = self . inventory_table . find ( username = username ) for row in sorted ( rows , key = lambda _row : _row [ 'creation' ], reverse = True ): df_upload = self . get_data ( row [ 'table_name' ]) children . extend ( format_table ( row [ 'df_name' ], row [ 'username' ], row [ 'creation' ], df_upload )) return html . Div ( children ) def register_upload_handler ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_upload_output ), 'children' )] inputs = [( self . get ( self . id_upload ), 'contents' ), ( self . get ( self . id_username_cache ), 'data' )] states = [( self . get ( self . id_upload ), 'filename' ), ( self . get ( self . id_upload ), 'last_modified' )] @parent . callback ( outputs , inputs , states , pic = True ) def upload_handler ( * raw_args ): a_in , a_state = map_args ( raw_args , inputs , states ) b64_file = a_in [ self . get ( self . id_upload )][ 'contents' ] username = a_in [ self . get ( self . id_username_cache )][ 'data' ] filename = a_state [ self . get ( self . id_upload )][ 'filename' ] timestamp = a_state [ self . get ( self . id_upload )][ 'last_modified' ] child_output = [] try : if b64_file is not None : df_upload = parse_uploaded_df ( b64_file , filename , timestamp ) df_upload = df_upload . dropna ( axis = 'columns' ) # FIXME: Better handle NaN values... self . add_user ( username ) self . upload_data ( username , filename , df_upload ) except Exception as error : child_output . extend ([ show_toast ( f ' { error } ' , 'Upload Error' , icon = 'danger' ), dcc . Markdown ( f '### Upload Error \\n\\n { type ( error ) } \\n\\n ``` \\n { error } \\n ```' ), ]) child_output . append ( self . _show_data ( username )) return map_outputs ( outputs , [( self . get ( self . id_upload_output ), 'children' , html . Div ( child_output ))])","title":"UploadModule"},{"location":"modules/dash_charts/modules_upload/#ancestors-in-mro","text":"dash_charts.utils_app_modules.ModuleBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/modules_upload/#class-variables","text":"all_ids List of ids to register for this module. cache_dir Path to the directory to use for caching files. id_upload Unique name for the upload component. id_upload_output Unique name for the div to contain output of the parse-upload. id_username_cache Unique name for the dcc.Store element to store the current username.","title":"Class variables"},{"location":"modules/dash_charts/modules_upload/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/modules_upload/#add_user","text":"def add_user ( self , username ) Add the user to the table or update the user\u2019s information if already registered. Parameters: Name Description username string username View Source def add_user ( self , username ): \"\"\"Add the user to the table or update the user's information if already registered. Args: username: string username \"\"\" now = time . time () if self . find_user ( username ): self . user_table . upsert ({ 'username' : username , 'last_loaded' : now }, [ 'username' ]) else : self . user_table . insert ({ 'username' : username , 'creation' : now , 'last_loaded' : now })","title":"add_user"},{"location":"modules/dash_charts/modules_upload/#create_callbacks","text":"def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" super () . create_callbacks ( parent ) self . register_upload_handler ( parent )","title":"create_callbacks"},{"location":"modules/dash_charts/modules_upload/#create_elements","text":"def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/modules_upload/#delete_data","text":"def delete_data ( self , table_name ) Remove specified data from the database. Parameters: Name Description table_name unique name of the table to delete View Source def delete_data ( self , table_name ): \"\"\"Remove specified data from the database. Args: table_name: unique name of the table to delete \"\"\" self . database . db . load_table ( table_name ) . drop ()","title":"delete_data"},{"location":"modules/dash_charts/modules_upload/#find_user","text":"def find_user ( self , username ) Return the database row for the specified user. Parameters: Name Description username string username Returns: Type Description dict for row from table or None if no match View Source def find_user ( self , username ): \"\"\"Return the database row for the specified user. Args: username: string username Returns: dict: for row from table or None if no match \"\"\" return self . user_table . find_one ( username = username )","title":"find_user"},{"location":"modules/dash_charts/modules_upload/#get","text":"def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ]","title":"get"},{"location":"modules/dash_charts/modules_upload/#get_data","text":"def get_data ( self , table_name ) Retrieve stored data for specified dataframe name. Parameters: Name Description table_name unique name of the table to retrieve Returns: Type Description pd.DataFrame pandas dataframe retrieved from the database View Source def get_data ( self , table_name ): \"\"\"Retrieve stored data for specified dataframe name. Args: table_name: unique name of the table to retrieve Returns: pd.DataFrame: pandas dataframe retrieved from the database \"\"\" table = self . database . db . load_table ( table_name ) return pd . DataFrame . from_records ( table . all ())","title":"get_data"},{"location":"modules/dash_charts/modules_upload/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/modules_upload/#register_upload_handler","text":"def register_upload_handler ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def register_upload_handler ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" outputs = [( self . get ( self . id_upload_output ), 'children' )] inputs = [( self . get ( self . id_upload ), 'contents' ), ( self . get ( self . id_username_cache ), 'data' )] states = [( self . get ( self . id_upload ), 'filename' ), ( self . get ( self . id_upload ), 'last_modified' )] @parent . callback ( outputs , inputs , states , pic = True ) def upload_handler ( * raw_args ): a_in , a_state = map_args ( raw_args , inputs , states ) b64_file = a_in [ self . get ( self . id_upload )][ 'contents' ] username = a_in [ self . get ( self . id_username_cache )][ 'data' ] filename = a_state [ self . get ( self . id_upload )][ 'filename' ] timestamp = a_state [ self . get ( self . id_upload )][ 'last_modified' ] child_output = [] try : if b64_file is not None : df_upload = parse_uploaded_df ( b64_file , filename , timestamp ) df_upload = df_upload . dropna ( axis = 'columns' ) # FIXME: Better handle NaN values... self . add_user ( username ) self . upload_data ( username , filename , df_upload ) except Exception as error : child_output . extend ([ show_toast ( f ' { error } ' , 'Upload Error' , icon = 'danger' ), dcc . Markdown ( f '### Upload Error \\n\\n { type ( error ) } \\n\\n ``` \\n { error } \\n ```' ), ]) child_output . append ( self . _show_data ( username )) return map_outputs ( outputs , [( self . get ( self . id_upload_output ), 'children' , html . Div ( child_output ))])","title":"register_upload_handler"},{"location":"modules/dash_charts/modules_upload/#return_layout","text":"def return_layout ( self , ids ) Return the Upload module application layout. Parameters: Name Description ids self._il from base application Returns: Type Description dict Dash HTML object. View Source def return_layout ( self , ids ): \"\"\"Return the Upload module application layout. Args: ids: `self._il` from base application Returns: dict: Dash HTML object. \"\"\" return html . Div ([ dcc . Store ( id = ids [ self . get ( self . id_username_cache )], storage_type = 'session' ), html . H2 ( 'File Upload' ), html . P ( 'Upload Tidy Data in CSV, Excel, or JSON format' ), drop_to_upload ( id = ids [ self . get ( self . id_upload )]), dcc . Loading ( html . Div ( '' , id = ids [ self . get ( self . id_upload_output )]), type = 'circle' ), ])","title":"return_layout"},{"location":"modules/dash_charts/modules_upload/#upload_data","text":"def upload_data ( self , username , df_name , df_upload ) Store dataframe in database for specified user. Parameters: Name Description username string username df_name name of the stored dataframe df_upload pandas dataframe to store Raises: Type Description Exception If upload fails, deletes the created table View Source def upload_data ( self , username , df_name , df_upload ): \"\"\"Store dataframe in database for specified user. Args: username: string username df_name: name of the stored dataframe df_upload: pandas dataframe to store Raises: Exception: If upload fails, deletes the created table \"\"\" now = time . time () table_name = f ' { username } - { df_name } - { int ( now ) } ' table = self . database . db . create_table ( table_name ) try : table . insert_many ( df_upload . to_dict ( orient = 'records' )) except Exception : table . drop () # Delete the table if upload fails raise self . inventory_table . insert ({ 'table_name' : table_name , 'df_name' : df_name , 'username' : username , 'creation' : now , })","title":"upload_data"},{"location":"modules/dash_charts/pareto_chart/","text":"dash_charts.pareto_chart \u2693\ufe0e Pareto Chart. View Source \"\"\"Pareto Chart.\"\"\" import pandas as pd import plotly.graph_objects as go from .utils_data import append_df , validate from .utils_fig import CustomChart , check_raw_data def tidy_pareto_data ( df_raw , cap_categories ): \"\"\"Return compressed Pareto dataframe of only the unique values. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` cap_categories: Maximum number of categories (bars) Returns: dataframe: pandas dataframe with columns `(value, label, counts, cum_per)` \"\"\" df_p = None for cat in df_raw [ 'category' ] . unique (): df_row = pd . DataFrame ( data = { 'label' : [ cat ], 'value' : [ df_raw . loc [ df_raw [ 'category' ] == cat ][ 'value' ] . sum ()], 'counts' : df_raw [ 'category' ] . value_counts ()[ cat ], }, ) df_p = append_df ( df_p , df_row ) # Sort and calculate percentage df_p = ( df_p [ df_p [ 'value' ] != 0 ] . sort_values ( by = [ 'value' ], ascending = False ) . head ( cap_categories ) ) df_p [ 'cum_per' ] = df_p [ 'value' ] . divide ( df_p [ 'value' ] . sum ()) . cumsum () return df_p class ParetoChart ( CustomChart ): \"\"\"Pareto Chart: both bar and line graph chart for strategic decision making.\"\"\" cap_categories : int = 20 \"\"\"Maximum number of categories (bars). Default is 20.\"\"\" show_count : bool = True \"\"\"If True, will show numeric count on each bar. Default is True.\"\"\" yaxis_2_label : str = 'Cumulative Percentage' \"\"\"Label for yaxis 2 that shows the cumulative percentage.\"\"\" _pareto_colors : dict = { 'bar' : '#4682b4' , 'line' : '#b44646' } _pareto_colors_schema = { 'bar' : { 'required' : True , 'type' : 'string' }, 'line' : { 'required' : True , 'type' : 'string' }, } @property def pareto_colors ( self ): \"\"\"Colors for bar and line traces in Pareto chart. Returns: dict: dictionary with keys `(bar, line)` \"\"\" return self . _pareto_colors @pareto_colors . setter def pareto_colors ( self , pareto_colors ): errors = validate ( pareto_colors , self . _pareto_colors_schema ) if errors : raise RuntimeError ( f 'Validation of self.pareto_colors failed: { errors } ' ) # Assign new pareto_colors self . _pareto_colors = pareto_colors def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` Returns: list: Dash chart traces Raises: RuntimeError: if the `df_raw` is missing any necessary columns \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'category' , 'value' ]) if not pd . api . types . is_string_dtype ( df_raw [ 'category' ]): # pragma: no cover raise RuntimeError ( f \"category column must be string, but found { df_raw [ 'category' ] . dtype } \" ) # Create and return the traces and optionally add the count to the bar chart df_p = tidy_pareto_data ( df_raw , self . cap_categories ) count_kwargs = { 'text' : df_p [ 'counts' ], 'textposition' : 'auto' } if self . show_count else {} return [ go . Bar ( hoverinfo = 'y' , yaxis = 'y1' , name = 'raw_value' , marker = { 'color' : self . pareto_colors [ 'bar' ]}, x = df_p [ 'label' ], y = df_p [ 'value' ], ** count_kwargs , ), ] + [ go . Scatter ( hoverinfo = 'y' , yaxis = 'y2' , name = 'cumulative_percentage' , marker = { 'color' : self . pareto_colors [ 'line' ]}, mode = 'lines' , x = df_p [ 'label' ], y = df_p [ 'cum_per' ], ), ] def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'legend' ] = {} layout [ 'showlegend' ] = False layout [ 'margin' ] = { 'l' : 75 , 'b' : 100 , 't' : 50 , 'r' : 125 } # Update YAxis configuration layout [ 'yaxis' ][ 'mirror' ] = 'ticks' layout [ 'yaxis' ][ 'showline' ] = True layout [ 'yaxis' ][ 'tickformat' ] = '.0f' # See multiple axis: https://plot.ly/python/multiple-axes/ layout [ 'yaxis2' ] = { 'dtick' : 0.1 , 'overlaying' : 'y' , 'range' : [ 0 , 1.01 ], 'showgrid' : False , 'side' : 'right' , 'tickformat' : '.0%' , 'tickmode' : 'linear' , 'title' : self . yaxis_2_label , } return layout Functions \u2693\ufe0e tidy_pareto_data \u2693\ufe0e def tidy_pareto_data ( df_raw , cap_categories ) Return compressed Pareto dataframe of only the unique values. Parameters: Name Description df_raw pandas dataframe with at minimum the two columns category: str and value: float cap_categories Maximum number of categories (bars) Returns: Type Description dataframe pandas dataframe with columns (value, label, counts, cum_per) View Source def tidy_pareto_data ( df_raw , cap_categories ): \"\"\"Return compressed Pareto dataframe of only the unique values. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` cap_categories: Maximum number of categories (bars) Returns: dataframe: pandas dataframe with columns `(value, label, counts, cum_per)` \"\"\" df_p = None for cat in df_raw [ 'category' ] . unique (): df_row = pd . DataFrame ( data = { 'label' : [ cat ], 'value' : [ df_raw . loc [ df_raw [ 'category' ] == cat ][ 'value' ] . sum ()], 'counts' : df_raw [ 'category' ] . value_counts ()[ cat ], }, ) df_p = append_df ( df_p , df_row ) # Sort and calculate percentage df_p = ( df_p [ df_p [ 'value' ] != 0 ] . sort_values ( by = [ 'value' ], ascending = False ) . head ( cap_categories ) ) df_p [ 'cum_per' ] = df_p [ 'value' ] . divide ( df_p [ 'value' ] . sum ()) . cumsum () return df_p Classes \u2693\ufe0e ParetoChart \u2693\ufe0e class ParetoChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class ParetoChart ( CustomChart ): \"\"\"Pareto Chart: both bar and line graph chart for strategic decision making.\"\"\" cap_categories : int = 20 \"\"\"Maximum number of categories (bars). Default is 20.\"\"\" show_count : bool = True \"\"\"If True, will show numeric count on each bar. Default is True.\"\"\" yaxis_2_label : str = 'Cumulative Percentage' \"\"\"Label for yaxis 2 that shows the cumulative percentage.\"\"\" _pareto_colors : dict = { 'bar' : '#4682b4' , 'line' : '#b44646' } _pareto_colors_schema = { 'bar' : { 'required' : True , 'type' : 'string' }, 'line' : { 'required' : True , 'type' : 'string' }, } @property def pareto_colors ( self ): \"\"\"Colors for bar and line traces in Pareto chart. Returns: dict: dictionary with keys `(bar, line)` \"\"\" return self . _pareto_colors @pareto_colors . setter def pareto_colors ( self , pareto_colors ): errors = validate ( pareto_colors , self . _pareto_colors_schema ) if errors : raise RuntimeError ( f 'Validation of self.pareto_colors failed: { errors } ' ) # Assign new pareto_colors self . _pareto_colors = pareto_colors def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` Returns: list: Dash chart traces Raises: RuntimeError: if the `df_raw` is missing any necessary columns \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'category' , 'value' ]) if not pd . api . types . is_string_dtype ( df_raw [ 'category' ]): # pragma: no cover raise RuntimeError ( f \"category column must be string, but found { df_raw [ 'category' ] . dtype } \" ) # Create and return the traces and optionally add the count to the bar chart df_p = tidy_pareto_data ( df_raw , self . cap_categories ) count_kwargs = { 'text' : df_p [ 'counts' ], 'textposition' : 'auto' } if self . show_count else {} return [ go . Bar ( hoverinfo = 'y' , yaxis = 'y1' , name = 'raw_value' , marker = { 'color' : self . pareto_colors [ 'bar' ]}, x = df_p [ 'label' ], y = df_p [ 'value' ], ** count_kwargs , ), ] + [ go . Scatter ( hoverinfo = 'y' , yaxis = 'y2' , name = 'cumulative_percentage' , marker = { 'color' : self . pareto_colors [ 'line' ]}, mode = 'lines' , x = df_p [ 'label' ], y = df_p [ 'cum_per' ], ), ] def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'legend' ] = {} layout [ 'showlegend' ] = False layout [ 'margin' ] = { 'l' : 75 , 'b' : 100 , 't' : 50 , 'r' : 125 } # Update YAxis configuration layout [ 'yaxis' ][ 'mirror' ] = 'ticks' layout [ 'yaxis' ][ 'showline' ] = True layout [ 'yaxis' ][ 'tickformat' ] = '.0f' # See multiple axis: https://plot.ly/python/multiple-axes/ layout [ 'yaxis2' ] = { 'dtick' : 0.1 , 'overlaying' : 'y' , 'range' : [ 0 , 1.01 ], 'showgrid' : False , 'side' : 'right' , 'tickformat' : '.0%' , 'tickmode' : 'linear' , 'title' : self . yaxis_2_label , } return layout Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations cap_categories show_count yaxis_2_label Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. pareto_colors Colors for bar and line traces in Pareto chart. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'legend' ] = {} layout [ 'showlegend' ] = False layout [ 'margin' ] = { 'l' : 75 , 'b' : 100 , 't' : 50 , 'r' : 125 } # Update YAxis configuration layout [ 'yaxis' ][ 'mirror' ] = 'ticks' layout [ 'yaxis' ][ 'showline' ] = True layout [ 'yaxis' ][ 'tickformat' ] = '.0f' # See multiple axis: https://plot.ly/python/multiple-axes/ layout [ 'yaxis2' ] = { 'dtick' : 0.1 , 'overlaying' : 'y' , 'range' : [ 0 , 1.01 ], 'showgrid' : False , 'side' : 'right' , 'tickformat' : '.0%' , 'tickmode' : 'linear' , 'title' : self . yaxis_2_label , } return layout create_traces \u2693\ufe0e def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with at minimum the two columns category: str and value: float Returns: Type Description list Dash chart traces Raises: Type Description RuntimeError if the df_raw is missing any necessary columns View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` Returns: list: Dash chart traces Raises: RuntimeError: if the `df_raw` is missing any necessary columns \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'category' , 'value' ]) if not pd . api . types . is_string_dtype ( df_raw [ 'category' ]): # pragma: no cover raise RuntimeError ( f \"category column must be string, but found { df_raw [ 'category' ] . dtype } \" ) # Create and return the traces and optionally add the count to the bar chart df_p = tidy_pareto_data ( df_raw , self . cap_categories ) count_kwargs = { 'text' : df_p [ 'counts' ], 'textposition' : 'auto' } if self . show_count else {} return [ go . Bar ( hoverinfo = 'y' , yaxis = 'y1' , name = 'raw_value' , marker = { 'color' : self . pareto_colors [ 'bar' ]}, x = df_p [ 'label' ], y = df_p [ 'value' ], ** count_kwargs , ), ] + [ go . Scatter ( hoverinfo = 'y' , yaxis = 'y2' , name = 'cumulative_percentage' , marker = { 'color' : self . pareto_colors [ 'line' ]}, mode = 'lines' , x = df_p [ 'label' ], y = df_p [ 'cum_per' ], ), ] initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"dash_charts.pareto_chart"},{"location":"modules/dash_charts/pareto_chart/#dash_chartspareto_chart","text":"Pareto Chart. View Source \"\"\"Pareto Chart.\"\"\" import pandas as pd import plotly.graph_objects as go from .utils_data import append_df , validate from .utils_fig import CustomChart , check_raw_data def tidy_pareto_data ( df_raw , cap_categories ): \"\"\"Return compressed Pareto dataframe of only the unique values. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` cap_categories: Maximum number of categories (bars) Returns: dataframe: pandas dataframe with columns `(value, label, counts, cum_per)` \"\"\" df_p = None for cat in df_raw [ 'category' ] . unique (): df_row = pd . DataFrame ( data = { 'label' : [ cat ], 'value' : [ df_raw . loc [ df_raw [ 'category' ] == cat ][ 'value' ] . sum ()], 'counts' : df_raw [ 'category' ] . value_counts ()[ cat ], }, ) df_p = append_df ( df_p , df_row ) # Sort and calculate percentage df_p = ( df_p [ df_p [ 'value' ] != 0 ] . sort_values ( by = [ 'value' ], ascending = False ) . head ( cap_categories ) ) df_p [ 'cum_per' ] = df_p [ 'value' ] . divide ( df_p [ 'value' ] . sum ()) . cumsum () return df_p class ParetoChart ( CustomChart ): \"\"\"Pareto Chart: both bar and line graph chart for strategic decision making.\"\"\" cap_categories : int = 20 \"\"\"Maximum number of categories (bars). Default is 20.\"\"\" show_count : bool = True \"\"\"If True, will show numeric count on each bar. Default is True.\"\"\" yaxis_2_label : str = 'Cumulative Percentage' \"\"\"Label for yaxis 2 that shows the cumulative percentage.\"\"\" _pareto_colors : dict = { 'bar' : '#4682b4' , 'line' : '#b44646' } _pareto_colors_schema = { 'bar' : { 'required' : True , 'type' : 'string' }, 'line' : { 'required' : True , 'type' : 'string' }, } @property def pareto_colors ( self ): \"\"\"Colors for bar and line traces in Pareto chart. Returns: dict: dictionary with keys `(bar, line)` \"\"\" return self . _pareto_colors @pareto_colors . setter def pareto_colors ( self , pareto_colors ): errors = validate ( pareto_colors , self . _pareto_colors_schema ) if errors : raise RuntimeError ( f 'Validation of self.pareto_colors failed: { errors } ' ) # Assign new pareto_colors self . _pareto_colors = pareto_colors def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` Returns: list: Dash chart traces Raises: RuntimeError: if the `df_raw` is missing any necessary columns \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'category' , 'value' ]) if not pd . api . types . is_string_dtype ( df_raw [ 'category' ]): # pragma: no cover raise RuntimeError ( f \"category column must be string, but found { df_raw [ 'category' ] . dtype } \" ) # Create and return the traces and optionally add the count to the bar chart df_p = tidy_pareto_data ( df_raw , self . cap_categories ) count_kwargs = { 'text' : df_p [ 'counts' ], 'textposition' : 'auto' } if self . show_count else {} return [ go . Bar ( hoverinfo = 'y' , yaxis = 'y1' , name = 'raw_value' , marker = { 'color' : self . pareto_colors [ 'bar' ]}, x = df_p [ 'label' ], y = df_p [ 'value' ], ** count_kwargs , ), ] + [ go . Scatter ( hoverinfo = 'y' , yaxis = 'y2' , name = 'cumulative_percentage' , marker = { 'color' : self . pareto_colors [ 'line' ]}, mode = 'lines' , x = df_p [ 'label' ], y = df_p [ 'cum_per' ], ), ] def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'legend' ] = {} layout [ 'showlegend' ] = False layout [ 'margin' ] = { 'l' : 75 , 'b' : 100 , 't' : 50 , 'r' : 125 } # Update YAxis configuration layout [ 'yaxis' ][ 'mirror' ] = 'ticks' layout [ 'yaxis' ][ 'showline' ] = True layout [ 'yaxis' ][ 'tickformat' ] = '.0f' # See multiple axis: https://plot.ly/python/multiple-axes/ layout [ 'yaxis2' ] = { 'dtick' : 0.1 , 'overlaying' : 'y' , 'range' : [ 0 , 1.01 ], 'showgrid' : False , 'side' : 'right' , 'tickformat' : '.0%' , 'tickmode' : 'linear' , 'title' : self . yaxis_2_label , } return layout","title":"dash_charts.pareto_chart"},{"location":"modules/dash_charts/pareto_chart/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/pareto_chart/#tidy_pareto_data","text":"def tidy_pareto_data ( df_raw , cap_categories ) Return compressed Pareto dataframe of only the unique values. Parameters: Name Description df_raw pandas dataframe with at minimum the two columns category: str and value: float cap_categories Maximum number of categories (bars) Returns: Type Description dataframe pandas dataframe with columns (value, label, counts, cum_per) View Source def tidy_pareto_data ( df_raw , cap_categories ): \"\"\"Return compressed Pareto dataframe of only the unique values. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` cap_categories: Maximum number of categories (bars) Returns: dataframe: pandas dataframe with columns `(value, label, counts, cum_per)` \"\"\" df_p = None for cat in df_raw [ 'category' ] . unique (): df_row = pd . DataFrame ( data = { 'label' : [ cat ], 'value' : [ df_raw . loc [ df_raw [ 'category' ] == cat ][ 'value' ] . sum ()], 'counts' : df_raw [ 'category' ] . value_counts ()[ cat ], }, ) df_p = append_df ( df_p , df_row ) # Sort and calculate percentage df_p = ( df_p [ df_p [ 'value' ] != 0 ] . sort_values ( by = [ 'value' ], ascending = False ) . head ( cap_categories ) ) df_p [ 'cum_per' ] = df_p [ 'value' ] . divide ( df_p [ 'value' ] . sum ()) . cumsum () return df_p","title":"tidy_pareto_data"},{"location":"modules/dash_charts/pareto_chart/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/pareto_chart/#paretochart","text":"class ParetoChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class ParetoChart ( CustomChart ): \"\"\"Pareto Chart: both bar and line graph chart for strategic decision making.\"\"\" cap_categories : int = 20 \"\"\"Maximum number of categories (bars). Default is 20.\"\"\" show_count : bool = True \"\"\"If True, will show numeric count on each bar. Default is True.\"\"\" yaxis_2_label : str = 'Cumulative Percentage' \"\"\"Label for yaxis 2 that shows the cumulative percentage.\"\"\" _pareto_colors : dict = { 'bar' : '#4682b4' , 'line' : '#b44646' } _pareto_colors_schema = { 'bar' : { 'required' : True , 'type' : 'string' }, 'line' : { 'required' : True , 'type' : 'string' }, } @property def pareto_colors ( self ): \"\"\"Colors for bar and line traces in Pareto chart. Returns: dict: dictionary with keys `(bar, line)` \"\"\" return self . _pareto_colors @pareto_colors . setter def pareto_colors ( self , pareto_colors ): errors = validate ( pareto_colors , self . _pareto_colors_schema ) if errors : raise RuntimeError ( f 'Validation of self.pareto_colors failed: { errors } ' ) # Assign new pareto_colors self . _pareto_colors = pareto_colors def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` Returns: list: Dash chart traces Raises: RuntimeError: if the `df_raw` is missing any necessary columns \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'category' , 'value' ]) if not pd . api . types . is_string_dtype ( df_raw [ 'category' ]): # pragma: no cover raise RuntimeError ( f \"category column must be string, but found { df_raw [ 'category' ] . dtype } \" ) # Create and return the traces and optionally add the count to the bar chart df_p = tidy_pareto_data ( df_raw , self . cap_categories ) count_kwargs = { 'text' : df_p [ 'counts' ], 'textposition' : 'auto' } if self . show_count else {} return [ go . Bar ( hoverinfo = 'y' , yaxis = 'y1' , name = 'raw_value' , marker = { 'color' : self . pareto_colors [ 'bar' ]}, x = df_p [ 'label' ], y = df_p [ 'value' ], ** count_kwargs , ), ] + [ go . Scatter ( hoverinfo = 'y' , yaxis = 'y2' , name = 'cumulative_percentage' , marker = { 'color' : self . pareto_colors [ 'line' ]}, mode = 'lines' , x = df_p [ 'label' ], y = df_p [ 'cum_per' ], ), ] def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'legend' ] = {} layout [ 'showlegend' ] = False layout [ 'margin' ] = { 'l' : 75 , 'b' : 100 , 't' : 50 , 'r' : 125 } # Update YAxis configuration layout [ 'yaxis' ][ 'mirror' ] = 'ticks' layout [ 'yaxis' ][ 'showline' ] = True layout [ 'yaxis' ][ 'tickformat' ] = '.0f' # See multiple axis: https://plot.ly/python/multiple-axes/ layout [ 'yaxis2' ] = { 'dtick' : 0.1 , 'overlaying' : 'y' , 'range' : [ 0 , 1.01 ], 'showgrid' : False , 'side' : 'right' , 'tickformat' : '.0%' , 'tickmode' : 'linear' , 'title' : self . yaxis_2_label , } return layout","title":"ParetoChart"},{"location":"modules/dash_charts/pareto_chart/#ancestors-in-mro","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/pareto_chart/#class-variables","text":"annotations cap_categories show_count yaxis_2_label","title":"Class variables"},{"location":"modules/dash_charts/pareto_chart/#instance-variables","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange. pareto_colors Colors for bar and line traces in Pareto chart.","title":"Instance variables"},{"location":"modules/dash_charts/pareto_chart/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/pareto_chart/#apply_custom_layout","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/pareto_chart/#create_figure","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/pareto_chart/#create_layout","text":"def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'legend' ] = {} layout [ 'showlegend' ] = False layout [ 'margin' ] = { 'l' : 75 , 'b' : 100 , 't' : 50 , 'r' : 125 } # Update YAxis configuration layout [ 'yaxis' ][ 'mirror' ] = 'ticks' layout [ 'yaxis' ][ 'showline' ] = True layout [ 'yaxis' ][ 'tickformat' ] = '.0f' # See multiple axis: https://plot.ly/python/multiple-axes/ layout [ 'yaxis2' ] = { 'dtick' : 0.1 , 'overlaying' : 'y' , 'range' : [ 0 , 1.01 ], 'showgrid' : False , 'side' : 'right' , 'tickformat' : '.0%' , 'tickmode' : 'linear' , 'title' : self . yaxis_2_label , } return layout","title":"create_layout"},{"location":"modules/dash_charts/pareto_chart/#create_traces","text":"def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with at minimum the two columns category: str and value: float Returns: Type Description list Dash chart traces Raises: Type Description RuntimeError if the df_raw is missing any necessary columns View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with at minimum the two columns `category: str` and `value: float` Returns: list: Dash chart traces Raises: RuntimeError: if the `df_raw` is missing any necessary columns \"\"\" # Check that the raw data frame is properly formatted check_raw_data ( df_raw , min_keys = [ 'category' , 'value' ]) if not pd . api . types . is_string_dtype ( df_raw [ 'category' ]): # pragma: no cover raise RuntimeError ( f \"category column must be string, but found { df_raw [ 'category' ] . dtype } \" ) # Create and return the traces and optionally add the count to the bar chart df_p = tidy_pareto_data ( df_raw , self . cap_categories ) count_kwargs = { 'text' : df_p [ 'counts' ], 'textposition' : 'auto' } if self . show_count else {} return [ go . Bar ( hoverinfo = 'y' , yaxis = 'y1' , name = 'raw_value' , marker = { 'color' : self . pareto_colors [ 'bar' ]}, x = df_p [ 'label' ], y = df_p [ 'value' ], ** count_kwargs , ), ] + [ go . Scatter ( hoverinfo = 'y' , yaxis = 'y2' , name = 'cumulative_percentage' , marker = { 'color' : self . pareto_colors [ 'line' ]}, mode = 'lines' , x = df_p [ 'label' ], y = df_p [ 'cum_per' ], ), ]","title":"create_traces"},{"location":"modules/dash_charts/pareto_chart/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/scatter_line_charts/","text":"dash_charts.scatter_line_charts \u2693\ufe0e Charts for plotting scatter or fitted data. View Source \"\"\"Charts for plotting scatter or fitted data.\"\"\" import numpy as np import plotly.graph_objects as go from scipy import optimize from .utils_fig import CustomChart , check_raw_data def create_rolling_traces ( df_raw , count_rolling , count_std ): \"\"\"Calculate traces for rolling average and standard deviation. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` count_rolling: number of points to use for the rolling calculation count_std: number of standard deviations to use for the standard deviation Returns: list: of Scatter traces for rolling mean and std \"\"\" rolling_mean = df_raw [ 'y' ] . rolling ( count_rolling ) . mean () . tolist () rolling_std = df_raw [ 'y' ] . rolling ( count_std ) . std () . tolist () return [ go . Scatter ( fill = 'toself' , hoverinfo = 'skip' , name = f ' { count_std } x STD Range' , opacity = 0.5 , x = ( df_raw [ 'x' ] . tolist () + df_raw [ 'x' ] . tolist ()[:: - 1 ]), y = ( np . add ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist () + np . subtract ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist ()[:: - 1 ] ), ), go . Scatter ( hoverinfo = 'skip' , mode = 'lines' , name = 'Rolling Mean' , opacity = 0.9 , x = df_raw [ 'x' ], y = rolling_mean , ), ] def create_fit_traces ( df_raw , name , fit_equation , suppress_fit_errors = False ): # noqa: CCR001 \"\"\"Create traces for specified equation. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` name: unique name for trace fit_equation: equation used suppress_fit_errors: If True, bury errors from scipy fit. Default is False. Returns: list: of Scatter traces for fitted equation \"\"\" fitted_data = [] try : popt , pcov = optimize . curve_fit ( fit_equation , xdata = df_raw [ 'x' ], ydata = df_raw [ 'y' ], method = 'lm' ) # Calculate representative x values for plotting fit x_min = np . min ( df_raw [ 'x' ]) x_max = np . max ( df_raw [ 'x' ]) x_range = x_max - x_min x_values = sorted ([ x_min - 0.05 * x_range , * np . divide ( range ( int ( x_min * 10 ), int ( x_max * 10 )), 10 ), x_max + 0.05 * x_range , ]) fitted_data = [ go . Scatter ( mode = 'lines+markers' , name = name , opacity = 0.9 , text = f 'popt: { [ round ( param , 3 ) for param in popt ] } ' , x = x_values , y = fit_equation ( x_values , * popt ), ), ] except ( RuntimeError , ValueError ) as err : # pragma: no cover if not suppress_fit_errors : raise return fitted_data # noqa: R504 class RollingChart ( CustomChart ): \"\"\"Rolling Mean and Filled Standard Deviation Chart for monitoring trends.\"\"\" count_std = 5 \"\"\"Count of STD deviations to display. Default 5.\"\"\" count_rolling = count_std \"\"\"Count of items to use for rolling calculations. Default `count_std`.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'x' , 'y' , 'label' ]) # Create and return the traces chart_data = [ go . Scatter ( mode = 'markers' , name = self . label_data , opacity = 0.5 , text = df_raw [ 'label' ], x = df_raw [ 'x' ], y = df_raw [ 'y' ], ), ] # Only add the rolling calculations if there are a sufficient number of points if len ( df_raw [ 'x' ]) >= self . count_rolling : chart_data . extend ( create_rolling_traces ( df_raw , self . count_rolling , self . count_std ), ) return chart_data class FittedChart ( CustomChart ): \"\"\"Scatter Chart with optional Fitted Lines.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" fit_eqs = [] \"\"\"List of fit equations.\"\"\" fallback_mode = 'lines+markers' \"\"\"If not fit_eqs are specified, will fallback to `lines+markers`. Can be set to `markers`.\"\"\" min_scatter_for_fit = 0 \"\"\"List of fit equations.\"\"\" suppress_fit_errors = False \"\"\"If True, bury errors from scipy fit and will print message to console. Default is True.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'name' , 'x' , 'y' , 'label' ]) # Separate raw tidy dataframe into separate scatter plots scatter_data = [] fit_traces = [] for name in set ( df_raw [ 'name' ]): df_name = df_raw [ df_raw [ 'name' ] == name ] scatter_data . append ( go . Scatter ( customdata = [ name ], mode = 'markers' if self . fit_eqs else self . fallback_mode , name = name , opacity = 0.5 , text = df_name [ 'label' ], x = df_name [ 'x' ], y = df_name [ 'y' ], ), ) if len ( df_name [ 'x' ]) > self . min_scatter_for_fit : for fit_name , fit_equation in self . fit_eqs : fit_traces . extend ( create_fit_traces ( df_name , f ' { name } - { fit_name } ' , fit_equation , self . suppress_fit_errors ), ) return scatter_data + fit_traces Functions \u2693\ufe0e create_fit_traces \u2693\ufe0e def create_fit_traces ( df_raw , name , fit_equation , suppress_fit_errors = False ) Create traces for specified equation. Parameters: Name Description df_raw pandas dataframe with columns name: str , x: float , y: float and label: str name unique name for trace fit_equation equation used suppress_fit_errors If True, bury errors from scipy fit. Default is False. Returns: Type Description list of Scatter traces for fitted equation View Source def create_fit_traces ( df_raw , name , fit_equation , suppress_fit_errors = False ): # noqa: CCR001 \"\"\"Create traces for specified equation. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` name: unique name for trace fit_equation: equation used suppress_fit_errors: If True, bury errors from scipy fit. Default is False. Returns: list: of Scatter traces for fitted equation \"\"\" fitted_data = [] try : popt , pcov = optimize . curve_fit ( fit_equation , xdata = df_raw [ 'x' ], ydata = df_raw [ 'y' ], method = 'lm' ) # Calculate representative x values for plotting fit x_min = np . min ( df_raw [ 'x' ]) x_max = np . max ( df_raw [ 'x' ]) x_range = x_max - x_min x_values = sorted ([ x_min - 0.05 * x_range , * np . divide ( range ( int ( x_min * 10 ), int ( x_max * 10 )), 10 ), x_max + 0.05 * x_range , ]) fitted_data = [ go . Scatter ( mode = 'lines+markers' , name = name , opacity = 0.9 , text = f 'popt: { [ round ( param , 3 ) for param in popt ] } ' , x = x_values , y = fit_equation ( x_values , * popt ), ), ] except ( RuntimeError , ValueError ) as err : # pragma: no cover if not suppress_fit_errors : raise return fitted_data # noqa: R504 create_rolling_traces \u2693\ufe0e def create_rolling_traces ( df_raw , count_rolling , count_std ) Calculate traces for rolling average and standard deviation. Parameters: Name Description df_raw pandas dataframe with columns x: float , y: float and label: str count_rolling number of points to use for the rolling calculation count_std number of standard deviations to use for the standard deviation Returns: Type Description list of Scatter traces for rolling mean and std View Source def create_rolling_traces ( df_raw , count_rolling , count_std ): \"\"\"Calculate traces for rolling average and standard deviation. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` count_rolling: number of points to use for the rolling calculation count_std: number of standard deviations to use for the standard deviation Returns: list: of Scatter traces for rolling mean and std \"\"\" rolling_mean = df_raw [ 'y' ] . rolling ( count_rolling ) . mean () . tolist () rolling_std = df_raw [ 'y' ] . rolling ( count_std ) . std () . tolist () return [ go . Scatter ( fill = 'toself' , hoverinfo = 'skip' , name = f ' { count_std } x STD Range' , opacity = 0.5 , x = ( df_raw [ 'x' ] . tolist () + df_raw [ 'x' ] . tolist ()[:: - 1 ]), y = ( np . add ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist () + np . subtract ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist ()[:: - 1 ] ), ), go . Scatter ( hoverinfo = 'skip' , mode = 'lines' , name = 'Rolling Mean' , opacity = 0.9 , x = df_raw [ 'x' ], y = rolling_mean , ), ] Classes \u2693\ufe0e FittedChart \u2693\ufe0e class FittedChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class FittedChart ( CustomChart ): \"\"\"Scatter Chart with optional Fitted Lines.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" fit_eqs = [] \"\"\"List of fit equations.\"\"\" fallback_mode = 'lines+markers' \"\"\"If not fit_eqs are specified, will fallback to `lines+markers`. Can be set to `markers`.\"\"\" min_scatter_for_fit = 0 \"\"\"List of fit equations.\"\"\" suppress_fit_errors = False \"\"\"If True, bury errors from scipy fit and will print message to console. Default is True.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'name' , 'x' , 'y' , 'label' ]) # Separate raw tidy dataframe into separate scatter plots scatter_data = [] fit_traces = [] for name in set ( df_raw [ 'name' ]): df_name = df_raw [ df_raw [ 'name' ] == name ] scatter_data . append ( go . Scatter ( customdata = [ name ], mode = 'markers' if self . fit_eqs else self . fallback_mode , name = name , opacity = 0.5 , text = df_name [ 'label' ], x = df_name [ 'x' ], y = df_name [ 'y' ], ), ) if len ( df_name [ 'x' ]) > self . min_scatter_for_fit : for fit_name , fit_equation in self . fit_eqs : fit_traces . extend ( create_fit_traces ( df_name , f ' { name } - { fit_name } ' , fit_equation , self . suppress_fit_errors ), ) return scatter_data + fit_traces Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations fallback_mode If not fit_eqs are specified, will fallback to lines+markers . Can be set to markers . fit_eqs List of fit equations. label_data Label for the scatter data. Default is \u2018Data\u2019. min_scatter_for_fit List of fit equations. suppress_fit_errors If True, bury errors from scipy fit and will print message to console. Default is True. Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Return the standard layout. Can be overridden and modified when inherited. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout create_traces \u2693\ufe0e def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns name: str , x: float , y: float and label: str Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'name' , 'x' , 'y' , 'label' ]) # Separate raw tidy dataframe into separate scatter plots scatter_data = [] fit_traces = [] for name in set ( df_raw [ 'name' ]): df_name = df_raw [ df_raw [ 'name' ] == name ] scatter_data . append ( go . Scatter ( customdata = [ name ], mode = 'markers' if self . fit_eqs else self . fallback_mode , name = name , opacity = 0.5 , text = df_name [ 'label' ], x = df_name [ 'x' ], y = df_name [ 'y' ], ), ) if len ( df_name [ 'x' ]) > self . min_scatter_for_fit : for fit_name , fit_equation in self . fit_eqs : fit_traces . extend ( create_fit_traces ( df_name , f ' { name } - { fit_name } ' , fit_equation , self . suppress_fit_errors ), ) return scatter_data + fit_traces initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... RollingChart \u2693\ufe0e class RollingChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class RollingChart ( CustomChart ): \"\"\"Rolling Mean and Filled Standard Deviation Chart for monitoring trends.\"\"\" count_std = 5 \"\"\"Count of STD deviations to display. Default 5.\"\"\" count_rolling = count_std \"\"\"Count of items to use for rolling calculations. Default `count_std`.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'x' , 'y' , 'label' ]) # Create and return the traces chart_data = [ go . Scatter ( mode = 'markers' , name = self . label_data , opacity = 0.5 , text = df_raw [ 'label' ], x = df_raw [ 'x' ], y = df_raw [ 'y' ], ), ] # Only add the rolling calculations if there are a sufficient number of points if len ( df_raw [ 'x' ]) >= self . count_rolling : chart_data . extend ( create_rolling_traces ( df_raw , self . count_rolling , self . count_std ), ) return chart_data Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations count_rolling Count of items to use for rolling calculations. Default count_std . count_std Count of STD deviations to display. Default 5. label_data Label for the scatter data. Default is \u2018Data\u2019. Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Return the standard layout. Can be overridden and modified when inherited. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout create_traces \u2693\ufe0e def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns x: float , y: float and label: str Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'x' , 'y' , 'label' ]) # Create and return the traces chart_data = [ go . Scatter ( mode = 'markers' , name = self . label_data , opacity = 0.5 , text = df_raw [ 'label' ], x = df_raw [ 'x' ], y = df_raw [ 'y' ], ), ] # Only add the rolling calculations if there are a sufficient number of points if len ( df_raw [ 'x' ]) >= self . count_rolling : chart_data . extend ( create_rolling_traces ( df_raw , self . count_rolling , self . count_std ), ) return chart_data initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"dash_charts.scatter_line_charts"},{"location":"modules/dash_charts/scatter_line_charts/#dash_chartsscatter_line_charts","text":"Charts for plotting scatter or fitted data. View Source \"\"\"Charts for plotting scatter or fitted data.\"\"\" import numpy as np import plotly.graph_objects as go from scipy import optimize from .utils_fig import CustomChart , check_raw_data def create_rolling_traces ( df_raw , count_rolling , count_std ): \"\"\"Calculate traces for rolling average and standard deviation. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` count_rolling: number of points to use for the rolling calculation count_std: number of standard deviations to use for the standard deviation Returns: list: of Scatter traces for rolling mean and std \"\"\" rolling_mean = df_raw [ 'y' ] . rolling ( count_rolling ) . mean () . tolist () rolling_std = df_raw [ 'y' ] . rolling ( count_std ) . std () . tolist () return [ go . Scatter ( fill = 'toself' , hoverinfo = 'skip' , name = f ' { count_std } x STD Range' , opacity = 0.5 , x = ( df_raw [ 'x' ] . tolist () + df_raw [ 'x' ] . tolist ()[:: - 1 ]), y = ( np . add ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist () + np . subtract ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist ()[:: - 1 ] ), ), go . Scatter ( hoverinfo = 'skip' , mode = 'lines' , name = 'Rolling Mean' , opacity = 0.9 , x = df_raw [ 'x' ], y = rolling_mean , ), ] def create_fit_traces ( df_raw , name , fit_equation , suppress_fit_errors = False ): # noqa: CCR001 \"\"\"Create traces for specified equation. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` name: unique name for trace fit_equation: equation used suppress_fit_errors: If True, bury errors from scipy fit. Default is False. Returns: list: of Scatter traces for fitted equation \"\"\" fitted_data = [] try : popt , pcov = optimize . curve_fit ( fit_equation , xdata = df_raw [ 'x' ], ydata = df_raw [ 'y' ], method = 'lm' ) # Calculate representative x values for plotting fit x_min = np . min ( df_raw [ 'x' ]) x_max = np . max ( df_raw [ 'x' ]) x_range = x_max - x_min x_values = sorted ([ x_min - 0.05 * x_range , * np . divide ( range ( int ( x_min * 10 ), int ( x_max * 10 )), 10 ), x_max + 0.05 * x_range , ]) fitted_data = [ go . Scatter ( mode = 'lines+markers' , name = name , opacity = 0.9 , text = f 'popt: { [ round ( param , 3 ) for param in popt ] } ' , x = x_values , y = fit_equation ( x_values , * popt ), ), ] except ( RuntimeError , ValueError ) as err : # pragma: no cover if not suppress_fit_errors : raise return fitted_data # noqa: R504 class RollingChart ( CustomChart ): \"\"\"Rolling Mean and Filled Standard Deviation Chart for monitoring trends.\"\"\" count_std = 5 \"\"\"Count of STD deviations to display. Default 5.\"\"\" count_rolling = count_std \"\"\"Count of items to use for rolling calculations. Default `count_std`.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'x' , 'y' , 'label' ]) # Create and return the traces chart_data = [ go . Scatter ( mode = 'markers' , name = self . label_data , opacity = 0.5 , text = df_raw [ 'label' ], x = df_raw [ 'x' ], y = df_raw [ 'y' ], ), ] # Only add the rolling calculations if there are a sufficient number of points if len ( df_raw [ 'x' ]) >= self . count_rolling : chart_data . extend ( create_rolling_traces ( df_raw , self . count_rolling , self . count_std ), ) return chart_data class FittedChart ( CustomChart ): \"\"\"Scatter Chart with optional Fitted Lines.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" fit_eqs = [] \"\"\"List of fit equations.\"\"\" fallback_mode = 'lines+markers' \"\"\"If not fit_eqs are specified, will fallback to `lines+markers`. Can be set to `markers`.\"\"\" min_scatter_for_fit = 0 \"\"\"List of fit equations.\"\"\" suppress_fit_errors = False \"\"\"If True, bury errors from scipy fit and will print message to console. Default is True.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'name' , 'x' , 'y' , 'label' ]) # Separate raw tidy dataframe into separate scatter plots scatter_data = [] fit_traces = [] for name in set ( df_raw [ 'name' ]): df_name = df_raw [ df_raw [ 'name' ] == name ] scatter_data . append ( go . Scatter ( customdata = [ name ], mode = 'markers' if self . fit_eqs else self . fallback_mode , name = name , opacity = 0.5 , text = df_name [ 'label' ], x = df_name [ 'x' ], y = df_name [ 'y' ], ), ) if len ( df_name [ 'x' ]) > self . min_scatter_for_fit : for fit_name , fit_equation in self . fit_eqs : fit_traces . extend ( create_fit_traces ( df_name , f ' { name } - { fit_name } ' , fit_equation , self . suppress_fit_errors ), ) return scatter_data + fit_traces","title":"dash_charts.scatter_line_charts"},{"location":"modules/dash_charts/scatter_line_charts/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/scatter_line_charts/#create_fit_traces","text":"def create_fit_traces ( df_raw , name , fit_equation , suppress_fit_errors = False ) Create traces for specified equation. Parameters: Name Description df_raw pandas dataframe with columns name: str , x: float , y: float and label: str name unique name for trace fit_equation equation used suppress_fit_errors If True, bury errors from scipy fit. Default is False. Returns: Type Description list of Scatter traces for fitted equation View Source def create_fit_traces ( df_raw , name , fit_equation , suppress_fit_errors = False ): # noqa: CCR001 \"\"\"Create traces for specified equation. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` name: unique name for trace fit_equation: equation used suppress_fit_errors: If True, bury errors from scipy fit. Default is False. Returns: list: of Scatter traces for fitted equation \"\"\" fitted_data = [] try : popt , pcov = optimize . curve_fit ( fit_equation , xdata = df_raw [ 'x' ], ydata = df_raw [ 'y' ], method = 'lm' ) # Calculate representative x values for plotting fit x_min = np . min ( df_raw [ 'x' ]) x_max = np . max ( df_raw [ 'x' ]) x_range = x_max - x_min x_values = sorted ([ x_min - 0.05 * x_range , * np . divide ( range ( int ( x_min * 10 ), int ( x_max * 10 )), 10 ), x_max + 0.05 * x_range , ]) fitted_data = [ go . Scatter ( mode = 'lines+markers' , name = name , opacity = 0.9 , text = f 'popt: { [ round ( param , 3 ) for param in popt ] } ' , x = x_values , y = fit_equation ( x_values , * popt ), ), ] except ( RuntimeError , ValueError ) as err : # pragma: no cover if not suppress_fit_errors : raise return fitted_data # noqa: R504","title":"create_fit_traces"},{"location":"modules/dash_charts/scatter_line_charts/#create_rolling_traces","text":"def create_rolling_traces ( df_raw , count_rolling , count_std ) Calculate traces for rolling average and standard deviation. Parameters: Name Description df_raw pandas dataframe with columns x: float , y: float and label: str count_rolling number of points to use for the rolling calculation count_std number of standard deviations to use for the standard deviation Returns: Type Description list of Scatter traces for rolling mean and std View Source def create_rolling_traces ( df_raw , count_rolling , count_std ): \"\"\"Calculate traces for rolling average and standard deviation. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` count_rolling: number of points to use for the rolling calculation count_std: number of standard deviations to use for the standard deviation Returns: list: of Scatter traces for rolling mean and std \"\"\" rolling_mean = df_raw [ 'y' ] . rolling ( count_rolling ) . mean () . tolist () rolling_std = df_raw [ 'y' ] . rolling ( count_std ) . std () . tolist () return [ go . Scatter ( fill = 'toself' , hoverinfo = 'skip' , name = f ' { count_std } x STD Range' , opacity = 0.5 , x = ( df_raw [ 'x' ] . tolist () + df_raw [ 'x' ] . tolist ()[:: - 1 ]), y = ( np . add ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist () + np . subtract ( rolling_mean , np . multiply ( count_std , rolling_std )) . tolist ()[:: - 1 ] ), ), go . Scatter ( hoverinfo = 'skip' , mode = 'lines' , name = 'Rolling Mean' , opacity = 0.9 , x = df_raw [ 'x' ], y = rolling_mean , ), ]","title":"create_rolling_traces"},{"location":"modules/dash_charts/scatter_line_charts/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/scatter_line_charts/#fittedchart","text":"class FittedChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class FittedChart ( CustomChart ): \"\"\"Scatter Chart with optional Fitted Lines.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" fit_eqs = [] \"\"\"List of fit equations.\"\"\" fallback_mode = 'lines+markers' \"\"\"If not fit_eqs are specified, will fallback to `lines+markers`. Can be set to `markers`.\"\"\" min_scatter_for_fit = 0 \"\"\"List of fit equations.\"\"\" suppress_fit_errors = False \"\"\"If True, bury errors from scipy fit and will print message to console. Default is True.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'name' , 'x' , 'y' , 'label' ]) # Separate raw tidy dataframe into separate scatter plots scatter_data = [] fit_traces = [] for name in set ( df_raw [ 'name' ]): df_name = df_raw [ df_raw [ 'name' ] == name ] scatter_data . append ( go . Scatter ( customdata = [ name ], mode = 'markers' if self . fit_eqs else self . fallback_mode , name = name , opacity = 0.5 , text = df_name [ 'label' ], x = df_name [ 'x' ], y = df_name [ 'y' ], ), ) if len ( df_name [ 'x' ]) > self . min_scatter_for_fit : for fit_name , fit_equation in self . fit_eqs : fit_traces . extend ( create_fit_traces ( df_name , f ' { name } - { fit_name } ' , fit_equation , self . suppress_fit_errors ), ) return scatter_data + fit_traces","title":"FittedChart"},{"location":"modules/dash_charts/scatter_line_charts/#ancestors-in-mro","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/scatter_line_charts/#class-variables","text":"annotations fallback_mode If not fit_eqs are specified, will fallback to lines+markers . Can be set to markers . fit_eqs List of fit equations. label_data Label for the scatter data. Default is \u2018Data\u2019. min_scatter_for_fit List of fit equations. suppress_fit_errors If True, bury errors from scipy fit and will print message to console. Default is True.","title":"Class variables"},{"location":"modules/dash_charts/scatter_line_charts/#instance-variables","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/scatter_line_charts/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/scatter_line_charts/#apply_custom_layout","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/scatter_line_charts/#create_figure","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/scatter_line_charts/#create_layout","text":"def create_layout ( self ) Return the standard layout. Can be overridden and modified when inherited. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout","title":"create_layout"},{"location":"modules/dash_charts/scatter_line_charts/#create_traces","text":"def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns name: str , x: float , y: float and label: str Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `name: str`, `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'name' , 'x' , 'y' , 'label' ]) # Separate raw tidy dataframe into separate scatter plots scatter_data = [] fit_traces = [] for name in set ( df_raw [ 'name' ]): df_name = df_raw [ df_raw [ 'name' ] == name ] scatter_data . append ( go . Scatter ( customdata = [ name ], mode = 'markers' if self . fit_eqs else self . fallback_mode , name = name , opacity = 0.5 , text = df_name [ 'label' ], x = df_name [ 'x' ], y = df_name [ 'y' ], ), ) if len ( df_name [ 'x' ]) > self . min_scatter_for_fit : for fit_name , fit_equation in self . fit_eqs : fit_traces . extend ( create_fit_traces ( df_name , f ' { name } - { fit_name } ' , fit_equation , self . suppress_fit_errors ), ) return scatter_data + fit_traces","title":"create_traces"},{"location":"modules/dash_charts/scatter_line_charts/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/scatter_line_charts/#rollingchart","text":"class RollingChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class RollingChart ( CustomChart ): \"\"\"Rolling Mean and Filled Standard Deviation Chart for monitoring trends.\"\"\" count_std = 5 \"\"\"Count of STD deviations to display. Default 5.\"\"\" count_rolling = count_std \"\"\"Count of items to use for rolling calculations. Default `count_std`.\"\"\" label_data = 'Data' \"\"\"Label for the scatter data. Default is 'Data'.\"\"\" def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'x' , 'y' , 'label' ]) # Create and return the traces chart_data = [ go . Scatter ( mode = 'markers' , name = self . label_data , opacity = 0.5 , text = df_raw [ 'label' ], x = df_raw [ 'x' ], y = df_raw [ 'y' ], ), ] # Only add the rolling calculations if there are a sufficient number of points if len ( df_raw [ 'x' ]) >= self . count_rolling : chart_data . extend ( create_rolling_traces ( df_raw , self . count_rolling , self . count_std ), ) return chart_data","title":"RollingChart"},{"location":"modules/dash_charts/scatter_line_charts/#ancestors-in-mro_1","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/scatter_line_charts/#class-variables_1","text":"annotations count_rolling Count of items to use for rolling calculations. Default count_std . count_std Count of STD deviations to display. Default 5. label_data Label for the scatter data. Default is \u2018Data\u2019.","title":"Class variables"},{"location":"modules/dash_charts/scatter_line_charts/#instance-variables_1","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/scatter_line_charts/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/scatter_line_charts/#apply_custom_layout_1","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/scatter_line_charts/#create_figure_1","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/scatter_line_charts/#create_layout_1","text":"def create_layout ( self ) Return the standard layout. Can be overridden and modified when inherited. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout","title":"create_layout"},{"location":"modules/dash_charts/scatter_line_charts/#create_traces_1","text":"def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns x: float , y: float and label: str Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns `x: float`, `y: float` and `label: str` Returns: list: Dash chart traces \"\"\" # Verify data format check_raw_data ( df_raw , [ 'x' , 'y' , 'label' ]) # Create and return the traces chart_data = [ go . Scatter ( mode = 'markers' , name = self . label_data , opacity = 0.5 , text = df_raw [ 'label' ], x = df_raw [ 'x' ], y = df_raw [ 'y' ], ), ] # Only add the rolling calculations if there are a sufficient number of points if len ( df_raw [ 'x' ]) >= self . count_rolling : chart_data . extend ( create_rolling_traces ( df_raw , self . count_rolling , self . count_std ), ) return chart_data","title":"create_traces"},{"location":"modules/dash_charts/scatter_line_charts/#initialize_mutables_1","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/time_vis_chart/","text":"dash_charts.time_vis_chart \u2693\ufe0e R daattali/TimeVis-like charts for displaying chronological data. See daattali/TimeVis: https://github.com/daattali/timevis NOTE: Consider automated (non-overlapping) text/event placement \u2693\ufe0e MATLAB Adjust Text: https://github.com/Phlya/adjustText D3 Labeler: https://github.com/tinker10/D3-Labeler Plotly has implementation for contour? https://github.com/plotly/plotly.js/issues/4674#issuecomment-603571483 View Source \"\"\"R daattali/TimeVis-like charts for displaying chronological data. See daattali/TimeVis: https://github.com/daattali/timevis # NOTE: Consider automated (non-overlapping) text/event placement - MATLAB Adjust Text: https://github.com/Phlya/adjustText - D3 Labeler: https://github.com/tinker10/D3-Labeler - Plotly has implementation for contour? https://github.com/plotly/plotly.js/issues/4674#issuecomment-603571483 \"\"\" import numpy as np import plotly.graph_objects as go from .utils_data import DASHED_TIME_FORMAT_YEAR , GDP_TIME_FORMAT , format_unix , get_unix from .utils_fig import CustomChart class TimeVisChart ( CustomChart ): # noqa: H601 \"\"\"Time Vis Chart: resource use timeline.\"\"\" date_format = DASHED_TIME_FORMAT_YEAR \"\"\"Date format for bar chart. Default is `DASHED_TIME_FORMAT_YEAR`.\"\"\" fillcolor = '#D5DDF6' \"\"\"Default fillcolor for time vis events.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular time vis.\"\"\" y_space = - 1.5 * rh \"\"\"Vertical spacing between rectangles.\"\"\" categories = None \"\"\"List of string category names set in self.create_traces().\"\"\" _shapes = [] \"\"\"List of shapes for plotly layout.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end)` Returns: list: Dash chart traces \"\"\" # Get all unique category names and create lookup for y positions self . categories = sorted ( cat for cat in set ( df_raw [ 'category' ] . tolist ()) if cat ) y_pos_lookup = { cat : self . y_space * idx for idx , cat in enumerate ( self . categories )} # Create the Time Vis traces traces = [] self . _shapes = [] self . _annotations = [] for vis in df_raw . itertuples (): if vis . category in y_pos_lookup : y_pos = y_pos_lookup [ vis . category ] if vis . end : traces . append ( self . _create_time_vis_shape ( vis , y_pos )) if vis . label : traces . append ( self . _create_annotation ( vis , y_pos )) else : traces . append ( self . _create_event ( vis , y_pos )) else : y_pos = 0 traces . append ( self . _create_non_cat_shape ( vis , y_pos )) return traces def _create_hover_text ( self , vis ): \"\"\"Return hover text for given trace. Args: vis: row tuple from df_raw with: `(category, label, start, end)` Returns: string: HTML-formatted hover text \"\"\" new_format = f '%a, { GDP_TIME_FORMAT } ' start_date = format_unix ( get_unix ( vis . start , self . date_format ), new_format ) if vis . end : end_date = format_unix ( get_unix ( vis . end , self . date_format ), new_format ) date_range = f '<b>Start</b>: { start_date } <br><b>End</b>: { end_date } ' else : date_range = f '<b>Event</b>: { start_date } ' return f '<b> { vis . category } </b><br> { vis . label } <br> { date_range } ' def _create_non_cat_shape ( self , vis , y_pos ): \"\"\"Create non-category time visualization (vertical across all categories). Note: background shape is set below a transparent trace so that hover works Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" bot_y = self . y_space * len ( self . categories ) self . _shapes . append ( go . layout . Shape ( fillcolor = self . fillcolor , layer = 'below' , line = { 'width' : 0 }, opacity = 0.4 , type = 'rect' , x0 = vis . start , x1 = vis . end , xref = 'x' , y0 = bot_y , y1 = y_pos , yref = 'y' , ), ) return go . Scatter ( fill = 'toself' , opacity = 0 , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , bot_y , bot_y , y_pos ], ) def _create_time_vis_shape ( self , vis , y_pos ): \"\"\"Create filled rectangle for time visualization. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( fill = 'toself' , fillcolor = self . fillcolor , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], ) def _create_annotation ( self , vis , y_pos ): \"\"\"Add vis label to chart as text overlay. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), mode = 'text' , text = vis . label , textposition = 'middle right' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def _create_event ( self , vis , y_pos ): \"\"\"Create singular event with vertical line, marker, and text. If label is longer than 10 characters, then the annotation is shown offset with an arrow. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" if len ( vis . label ) > 10 : self . _annotations . append ({ 'align' : 'right' , 'arrowcolor' : self . fillcolor , 'showarrow' : True , 'arrowhead' : 2 , 'text' : vis . label , 'x' : vis . start , 'xanchor' : 'right' , 'y' : y_pos - self . rh / 2 , 'yanchor' : 'middle' , }) self . _shapes . append ( go . layout . Shape ( layer = 'below' , line = { 'color' : self . fillcolor , 'dash' : 'longdashdot' , 'width' : 2 , }, type = 'line' , x0 = vis . start , x1 = vis . start , xref = 'x' , y0 = self . y_space * len ( self . categories ), y1 = y_pos - self . rh / 2 , yref = 'y' , ), ) return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), marker = { 'color' : self . fillcolor }, mode = 'markers+text' , text = '' if len ( vis . label ) > 10 else vis . label , textposition = 'top center' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Set YAxis tick marks for category names (https://plotly.com/python/tick-formatting) layout [ 'yaxis' ][ 'tickmode' ] = 'array' layout [ 'yaxis' ][ 'tickvals' ] = np . subtract ( np . multiply ( np . array ( range ( len ( self . categories ))), self . y_space , ), self . rh / 2 , ) layout [ 'yaxis' ][ 'ticktext' ] = [ * self . categories ] layout [ 'yaxis' ][ 'zeroline' ] = False # Hide legend layout [ 'legend' ] = {} layout [ 'showlegend' ] = False # Add shapes and append new annotations layout [ 'shapes' ] = self . _shapes layout [ 'annotations' ] += self . _annotations return layout Variables \u2693\ufe0e DASHED_TIME_FORMAT_YEAR GDP_TIME_FORMAT Classes \u2693\ufe0e TimeVisChart \u2693\ufe0e class TimeVisChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class TimeVisChart ( CustomChart ): # noqa: H601 \"\"\"Time Vis Chart: resource use timeline.\"\"\" date_format = DASHED_TIME_FORMAT_YEAR \"\"\"Date format for bar chart. Default is `DASHED_TIME_FORMAT_YEAR`.\"\"\" fillcolor = '#D5DDF6' \"\"\"Default fillcolor for time vis events.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular time vis.\"\"\" y_space = - 1.5 * rh \"\"\"Vertical spacing between rectangles.\"\"\" categories = None \"\"\"List of string category names set in self.create_traces().\"\"\" _shapes = [] \"\"\"List of shapes for plotly layout.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end)` Returns: list: Dash chart traces \"\"\" # Get all unique category names and create lookup for y positions self . categories = sorted ( cat for cat in set ( df_raw [ 'category' ] . tolist ()) if cat ) y_pos_lookup = { cat : self . y_space * idx for idx , cat in enumerate ( self . categories )} # Create the Time Vis traces traces = [] self . _shapes = [] self . _annotations = [] for vis in df_raw . itertuples (): if vis . category in y_pos_lookup : y_pos = y_pos_lookup [ vis . category ] if vis . end : traces . append ( self . _create_time_vis_shape ( vis , y_pos )) if vis . label : traces . append ( self . _create_annotation ( vis , y_pos )) else : traces . append ( self . _create_event ( vis , y_pos )) else : y_pos = 0 traces . append ( self . _create_non_cat_shape ( vis , y_pos )) return traces def _create_hover_text ( self , vis ): \"\"\"Return hover text for given trace. Args: vis: row tuple from df_raw with: `(category, label, start, end)` Returns: string: HTML-formatted hover text \"\"\" new_format = f '%a, { GDP_TIME_FORMAT } ' start_date = format_unix ( get_unix ( vis . start , self . date_format ), new_format ) if vis . end : end_date = format_unix ( get_unix ( vis . end , self . date_format ), new_format ) date_range = f '<b>Start</b>: { start_date } <br><b>End</b>: { end_date } ' else : date_range = f '<b>Event</b>: { start_date } ' return f '<b> { vis . category } </b><br> { vis . label } <br> { date_range } ' def _create_non_cat_shape ( self , vis , y_pos ): \"\"\"Create non-category time visualization (vertical across all categories). Note: background shape is set below a transparent trace so that hover works Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" bot_y = self . y_space * len ( self . categories ) self . _shapes . append ( go . layout . Shape ( fillcolor = self . fillcolor , layer = 'below' , line = { 'width' : 0 }, opacity = 0.4 , type = 'rect' , x0 = vis . start , x1 = vis . end , xref = 'x' , y0 = bot_y , y1 = y_pos , yref = 'y' , ), ) return go . Scatter ( fill = 'toself' , opacity = 0 , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , bot_y , bot_y , y_pos ], ) def _create_time_vis_shape ( self , vis , y_pos ): \"\"\"Create filled rectangle for time visualization. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( fill = 'toself' , fillcolor = self . fillcolor , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], ) def _create_annotation ( self , vis , y_pos ): \"\"\"Add vis label to chart as text overlay. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), mode = 'text' , text = vis . label , textposition = 'middle right' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def _create_event ( self , vis , y_pos ): \"\"\"Create singular event with vertical line, marker, and text. If label is longer than 10 characters, then the annotation is shown offset with an arrow. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" if len ( vis . label ) > 10 : self . _annotations . append ({ 'align' : 'right' , 'arrowcolor' : self . fillcolor , 'showarrow' : True , 'arrowhead' : 2 , 'text' : vis . label , 'x' : vis . start , 'xanchor' : 'right' , 'y' : y_pos - self . rh / 2 , 'yanchor' : 'middle' , }) self . _shapes . append ( go . layout . Shape ( layer = 'below' , line = { 'color' : self . fillcolor , 'dash' : 'longdashdot' , 'width' : 2 , }, type = 'line' , x0 = vis . start , x1 = vis . start , xref = 'x' , y0 = self . y_space * len ( self . categories ), y1 = y_pos - self . rh / 2 , yref = 'y' , ), ) return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), marker = { 'color' : self . fillcolor }, mode = 'markers+text' , text = '' if len ( vis . label ) > 10 else vis . label , textposition = 'top center' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Set YAxis tick marks for category names (https://plotly.com/python/tick-formatting) layout [ 'yaxis' ][ 'tickmode' ] = 'array' layout [ 'yaxis' ][ 'tickvals' ] = np . subtract ( np . multiply ( np . array ( range ( len ( self . categories ))), self . y_space , ), self . rh / 2 , ) layout [ 'yaxis' ][ 'ticktext' ] = [ * self . categories ] layout [ 'yaxis' ][ 'zeroline' ] = False # Hide legend layout [ 'legend' ] = {} layout [ 'showlegend' ] = False # Add shapes and append new annotations layout [ 'shapes' ] = self . _shapes layout [ 'annotations' ] += self . _annotations return layout Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations categories List of string category names set in self.create_traces(). date_format Date format for bar chart. Default is DASHED_TIME_FORMAT_YEAR . fillcolor Default fillcolor for time vis events. hover_label_settings Plotly hover label settings. rh Height of each rectangular time vis. y_space Vertical spacing between rectangles. Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Set YAxis tick marks for category names (https://plotly.com/python/tick-formatting) layout [ 'yaxis' ][ 'tickmode' ] = 'array' layout [ 'yaxis' ][ 'tickvals' ] = np . subtract ( np . multiply ( np . array ( range ( len ( self . categories ))), self . y_space , ), self . rh / 2 , ) layout [ 'yaxis' ][ 'ticktext' ] = [ * self . categories ] layout [ 'yaxis' ][ 'zeroline' ] = False # Hide legend layout [ 'legend' ] = {} layout [ 'showlegend' ] = False # Add shapes and append new annotations layout [ 'shapes' ] = self . _shapes layout [ 'annotations' ] += self . _annotations return layout create_traces \u2693\ufe0e def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns: (category, label, start, end) Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end)` Returns: list: Dash chart traces \"\"\" # Get all unique category names and create lookup for y positions self . categories = sorted ( cat for cat in set ( df_raw [ 'category' ] . tolist ()) if cat ) y_pos_lookup = { cat : self . y_space * idx for idx , cat in enumerate ( self . categories )} # Create the Time Vis traces traces = [] self . _shapes = [] self . _annotations = [] for vis in df_raw . itertuples (): if vis . category in y_pos_lookup : y_pos = y_pos_lookup [ vis . category ] if vis . end : traces . append ( self . _create_time_vis_shape ( vis , y_pos )) if vis . label : traces . append ( self . _create_annotation ( vis , y_pos )) else : traces . append ( self . _create_event ( vis , y_pos )) else : y_pos = 0 traces . append ( self . _create_non_cat_shape ( vis , y_pos )) return traces initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"dash_charts.time_vis_chart"},{"location":"modules/dash_charts/time_vis_chart/#dash_chartstime_vis_chart","text":"R daattali/TimeVis-like charts for displaying chronological data. See daattali/TimeVis: https://github.com/daattali/timevis","title":"dash_charts.time_vis_chart"},{"location":"modules/dash_charts/time_vis_chart/#note-consider-automated-non-overlapping-textevent-placement","text":"MATLAB Adjust Text: https://github.com/Phlya/adjustText D3 Labeler: https://github.com/tinker10/D3-Labeler Plotly has implementation for contour? https://github.com/plotly/plotly.js/issues/4674#issuecomment-603571483 View Source \"\"\"R daattali/TimeVis-like charts for displaying chronological data. See daattali/TimeVis: https://github.com/daattali/timevis # NOTE: Consider automated (non-overlapping) text/event placement - MATLAB Adjust Text: https://github.com/Phlya/adjustText - D3 Labeler: https://github.com/tinker10/D3-Labeler - Plotly has implementation for contour? https://github.com/plotly/plotly.js/issues/4674#issuecomment-603571483 \"\"\" import numpy as np import plotly.graph_objects as go from .utils_data import DASHED_TIME_FORMAT_YEAR , GDP_TIME_FORMAT , format_unix , get_unix from .utils_fig import CustomChart class TimeVisChart ( CustomChart ): # noqa: H601 \"\"\"Time Vis Chart: resource use timeline.\"\"\" date_format = DASHED_TIME_FORMAT_YEAR \"\"\"Date format for bar chart. Default is `DASHED_TIME_FORMAT_YEAR`.\"\"\" fillcolor = '#D5DDF6' \"\"\"Default fillcolor for time vis events.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular time vis.\"\"\" y_space = - 1.5 * rh \"\"\"Vertical spacing between rectangles.\"\"\" categories = None \"\"\"List of string category names set in self.create_traces().\"\"\" _shapes = [] \"\"\"List of shapes for plotly layout.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end)` Returns: list: Dash chart traces \"\"\" # Get all unique category names and create lookup for y positions self . categories = sorted ( cat for cat in set ( df_raw [ 'category' ] . tolist ()) if cat ) y_pos_lookup = { cat : self . y_space * idx for idx , cat in enumerate ( self . categories )} # Create the Time Vis traces traces = [] self . _shapes = [] self . _annotations = [] for vis in df_raw . itertuples (): if vis . category in y_pos_lookup : y_pos = y_pos_lookup [ vis . category ] if vis . end : traces . append ( self . _create_time_vis_shape ( vis , y_pos )) if vis . label : traces . append ( self . _create_annotation ( vis , y_pos )) else : traces . append ( self . _create_event ( vis , y_pos )) else : y_pos = 0 traces . append ( self . _create_non_cat_shape ( vis , y_pos )) return traces def _create_hover_text ( self , vis ): \"\"\"Return hover text for given trace. Args: vis: row tuple from df_raw with: `(category, label, start, end)` Returns: string: HTML-formatted hover text \"\"\" new_format = f '%a, { GDP_TIME_FORMAT } ' start_date = format_unix ( get_unix ( vis . start , self . date_format ), new_format ) if vis . end : end_date = format_unix ( get_unix ( vis . end , self . date_format ), new_format ) date_range = f '<b>Start</b>: { start_date } <br><b>End</b>: { end_date } ' else : date_range = f '<b>Event</b>: { start_date } ' return f '<b> { vis . category } </b><br> { vis . label } <br> { date_range } ' def _create_non_cat_shape ( self , vis , y_pos ): \"\"\"Create non-category time visualization (vertical across all categories). Note: background shape is set below a transparent trace so that hover works Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" bot_y = self . y_space * len ( self . categories ) self . _shapes . append ( go . layout . Shape ( fillcolor = self . fillcolor , layer = 'below' , line = { 'width' : 0 }, opacity = 0.4 , type = 'rect' , x0 = vis . start , x1 = vis . end , xref = 'x' , y0 = bot_y , y1 = y_pos , yref = 'y' , ), ) return go . Scatter ( fill = 'toself' , opacity = 0 , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , bot_y , bot_y , y_pos ], ) def _create_time_vis_shape ( self , vis , y_pos ): \"\"\"Create filled rectangle for time visualization. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( fill = 'toself' , fillcolor = self . fillcolor , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], ) def _create_annotation ( self , vis , y_pos ): \"\"\"Add vis label to chart as text overlay. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), mode = 'text' , text = vis . label , textposition = 'middle right' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def _create_event ( self , vis , y_pos ): \"\"\"Create singular event with vertical line, marker, and text. If label is longer than 10 characters, then the annotation is shown offset with an arrow. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" if len ( vis . label ) > 10 : self . _annotations . append ({ 'align' : 'right' , 'arrowcolor' : self . fillcolor , 'showarrow' : True , 'arrowhead' : 2 , 'text' : vis . label , 'x' : vis . start , 'xanchor' : 'right' , 'y' : y_pos - self . rh / 2 , 'yanchor' : 'middle' , }) self . _shapes . append ( go . layout . Shape ( layer = 'below' , line = { 'color' : self . fillcolor , 'dash' : 'longdashdot' , 'width' : 2 , }, type = 'line' , x0 = vis . start , x1 = vis . start , xref = 'x' , y0 = self . y_space * len ( self . categories ), y1 = y_pos - self . rh / 2 , yref = 'y' , ), ) return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), marker = { 'color' : self . fillcolor }, mode = 'markers+text' , text = '' if len ( vis . label ) > 10 else vis . label , textposition = 'top center' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Set YAxis tick marks for category names (https://plotly.com/python/tick-formatting) layout [ 'yaxis' ][ 'tickmode' ] = 'array' layout [ 'yaxis' ][ 'tickvals' ] = np . subtract ( np . multiply ( np . array ( range ( len ( self . categories ))), self . y_space , ), self . rh / 2 , ) layout [ 'yaxis' ][ 'ticktext' ] = [ * self . categories ] layout [ 'yaxis' ][ 'zeroline' ] = False # Hide legend layout [ 'legend' ] = {} layout [ 'showlegend' ] = False # Add shapes and append new annotations layout [ 'shapes' ] = self . _shapes layout [ 'annotations' ] += self . _annotations return layout","title":"NOTE: Consider automated (non-overlapping) text/event placement"},{"location":"modules/dash_charts/time_vis_chart/#variables","text":"DASHED_TIME_FORMAT_YEAR GDP_TIME_FORMAT","title":"Variables"},{"location":"modules/dash_charts/time_vis_chart/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/time_vis_chart/#timevischart","text":"class TimeVisChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class TimeVisChart ( CustomChart ): # noqa: H601 \"\"\"Time Vis Chart: resource use timeline.\"\"\" date_format = DASHED_TIME_FORMAT_YEAR \"\"\"Date format for bar chart. Default is `DASHED_TIME_FORMAT_YEAR`.\"\"\" fillcolor = '#D5DDF6' \"\"\"Default fillcolor for time vis events.\"\"\" hover_label_settings = { 'bgcolor' : 'white' , 'font_size' : 12 , 'namelength' : 0 } \"\"\"Plotly hover label settings.\"\"\" rh = 1 \"\"\"Height of each rectangular time vis.\"\"\" y_space = - 1.5 * rh \"\"\"Vertical spacing between rectangles.\"\"\" categories = None \"\"\"List of string category names set in self.create_traces().\"\"\" _shapes = [] \"\"\"List of shapes for plotly layout.\"\"\" def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end)` Returns: list: Dash chart traces \"\"\" # Get all unique category names and create lookup for y positions self . categories = sorted ( cat for cat in set ( df_raw [ 'category' ] . tolist ()) if cat ) y_pos_lookup = { cat : self . y_space * idx for idx , cat in enumerate ( self . categories )} # Create the Time Vis traces traces = [] self . _shapes = [] self . _annotations = [] for vis in df_raw . itertuples (): if vis . category in y_pos_lookup : y_pos = y_pos_lookup [ vis . category ] if vis . end : traces . append ( self . _create_time_vis_shape ( vis , y_pos )) if vis . label : traces . append ( self . _create_annotation ( vis , y_pos )) else : traces . append ( self . _create_event ( vis , y_pos )) else : y_pos = 0 traces . append ( self . _create_non_cat_shape ( vis , y_pos )) return traces def _create_hover_text ( self , vis ): \"\"\"Return hover text for given trace. Args: vis: row tuple from df_raw with: `(category, label, start, end)` Returns: string: HTML-formatted hover text \"\"\" new_format = f '%a, { GDP_TIME_FORMAT } ' start_date = format_unix ( get_unix ( vis . start , self . date_format ), new_format ) if vis . end : end_date = format_unix ( get_unix ( vis . end , self . date_format ), new_format ) date_range = f '<b>Start</b>: { start_date } <br><b>End</b>: { end_date } ' else : date_range = f '<b>Event</b>: { start_date } ' return f '<b> { vis . category } </b><br> { vis . label } <br> { date_range } ' def _create_non_cat_shape ( self , vis , y_pos ): \"\"\"Create non-category time visualization (vertical across all categories). Note: background shape is set below a transparent trace so that hover works Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" bot_y = self . y_space * len ( self . categories ) self . _shapes . append ( go . layout . Shape ( fillcolor = self . fillcolor , layer = 'below' , line = { 'width' : 0 }, opacity = 0.4 , type = 'rect' , x0 = vis . start , x1 = vis . end , xref = 'x' , y0 = bot_y , y1 = y_pos , yref = 'y' , ), ) return go . Scatter ( fill = 'toself' , opacity = 0 , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , bot_y , bot_y , y_pos ], ) def _create_time_vis_shape ( self , vis , y_pos ): \"\"\"Create filled rectangle for time visualization. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( fill = 'toself' , fillcolor = self . fillcolor , hoverlabel = self . hover_label_settings , line = { 'width' : 0 }, mode = 'lines' , text = self . _create_hover_text ( vis ), x = [ vis . start , vis . end , vis . end , vis . start , vis . start ], y = [ y_pos , y_pos , y_pos - self . rh , y_pos - self . rh , y_pos ], ) def _create_annotation ( self , vis , y_pos ): \"\"\"Add vis label to chart as text overlay. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), mode = 'text' , text = vis . label , textposition = 'middle right' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def _create_event ( self , vis , y_pos ): \"\"\"Create singular event with vertical line, marker, and text. If label is longer than 10 characters, then the annotation is shown offset with an arrow. Args: vis: row tuple from df_raw with: `(category, label, start, end)` y_pos: top y-coordinate of vis Returns: trace: single Dash chart Scatter trace \"\"\" if len ( vis . label ) > 10 : self . _annotations . append ({ 'align' : 'right' , 'arrowcolor' : self . fillcolor , 'showarrow' : True , 'arrowhead' : 2 , 'text' : vis . label , 'x' : vis . start , 'xanchor' : 'right' , 'y' : y_pos - self . rh / 2 , 'yanchor' : 'middle' , }) self . _shapes . append ( go . layout . Shape ( layer = 'below' , line = { 'color' : self . fillcolor , 'dash' : 'longdashdot' , 'width' : 2 , }, type = 'line' , x0 = vis . start , x1 = vis . start , xref = 'x' , y0 = self . y_space * len ( self . categories ), y1 = y_pos - self . rh / 2 , yref = 'y' , ), ) return go . Scatter ( hoverlabel = self . hover_label_settings , hovertemplate = self . _create_hover_text ( vis ) + '<extra></extra>' , hovertext = self . _create_hover_text ( vis ), marker = { 'color' : self . fillcolor }, mode = 'markers+text' , text = '' if len ( vis . label ) > 10 else vis . label , textposition = 'top center' , x = [ vis . start ], y = [ y_pos - self . rh / 2 ], ) def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Set YAxis tick marks for category names (https://plotly.com/python/tick-formatting) layout [ 'yaxis' ][ 'tickmode' ] = 'array' layout [ 'yaxis' ][ 'tickvals' ] = np . subtract ( np . multiply ( np . array ( range ( len ( self . categories ))), self . y_space , ), self . rh / 2 , ) layout [ 'yaxis' ][ 'ticktext' ] = [ * self . categories ] layout [ 'yaxis' ][ 'zeroline' ] = False # Hide legend layout [ 'legend' ] = {} layout [ 'showlegend' ] = False # Add shapes and append new annotations layout [ 'shapes' ] = self . _shapes layout [ 'annotations' ] += self . _annotations return layout","title":"TimeVisChart"},{"location":"modules/dash_charts/time_vis_chart/#ancestors-in-mro","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/time_vis_chart/#class-variables","text":"annotations categories List of string category names set in self.create_traces(). date_format Date format for bar chart. Default is DASHED_TIME_FORMAT_YEAR . fillcolor Default fillcolor for time vis events. hover_label_settings Plotly hover label settings. rh Height of each rectangular time vis. y_space Vertical spacing between rectangles.","title":"Class variables"},{"location":"modules/dash_charts/time_vis_chart/#instance-variables","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/time_vis_chart/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/time_vis_chart/#apply_custom_layout","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/time_vis_chart/#create_figure","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/time_vis_chart/#create_layout","text":"def create_layout ( self ) Extend the standard layout. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Extend the standard layout. Returns: dict: layout for Dash figure \"\"\" layout = super () . create_layout () # Set YAxis tick marks for category names (https://plotly.com/python/tick-formatting) layout [ 'yaxis' ][ 'tickmode' ] = 'array' layout [ 'yaxis' ][ 'tickvals' ] = np . subtract ( np . multiply ( np . array ( range ( len ( self . categories ))), self . y_space , ), self . rh / 2 , ) layout [ 'yaxis' ][ 'ticktext' ] = [ * self . categories ] layout [ 'yaxis' ][ 'zeroline' ] = False # Hide legend layout [ 'legend' ] = {} layout [ 'showlegend' ] = False # Add shapes and append new annotations layout [ 'shapes' ] = self . _shapes layout [ 'annotations' ] += self . _annotations return layout","title":"create_layout"},{"location":"modules/dash_charts/time_vis_chart/#create_traces","text":"def create_traces ( self , df_raw ) Return traces for plotly chart. Parameters: Name Description df_raw pandas dataframe with columns: (category, label, start, end) Returns: Type Description list Dash chart traces View Source def create_traces ( self , df_raw ): # noqa: CCR001 \"\"\"Return traces for plotly chart. Args: df_raw: pandas dataframe with columns: `(category, label, start, end)` Returns: list: Dash chart traces \"\"\" # Get all unique category names and create lookup for y positions self . categories = sorted ( cat for cat in set ( df_raw [ 'category' ] . tolist ()) if cat ) y_pos_lookup = { cat : self . y_space * idx for idx , cat in enumerate ( self . categories )} # Create the Time Vis traces traces = [] self . _shapes = [] self . _annotations = [] for vis in df_raw . itertuples (): if vis . category in y_pos_lookup : y_pos = y_pos_lookup [ vis . category ] if vis . end : traces . append ( self . _create_time_vis_shape ( vis , y_pos )) if vis . label : traces . append ( self . _create_annotation ( vis , y_pos )) else : traces . append ( self . _create_event ( vis , y_pos )) else : y_pos = 0 traces . append ( self . _create_non_cat_shape ( vis , y_pos )) return traces","title":"create_traces"},{"location":"modules/dash_charts/time_vis_chart/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/utils_app/","text":"dash_charts.utils_app \u2693\ufe0e Utility functions and classes for building applications. View Source \"\"\"Utility functions and classes for building applications.\"\"\" from copy import deepcopy from itertools import count from pathlib import Path from pprint import pprint from typing import List , Optional import dash from box import Box from dash import html from implements import Interface from .utils_callbacks import format_app_callback ASSETS_DIR = Path ( __file__ ) . parent / 'assets' \"\"\"Path to the static files directory.\"\"\" COUNTER = count ( start = 0 , step = 1 ) \"\"\"Initialize iterator to provide set of unique integers when called with `next(...)`.\"\"\" STATIC_URLS = { 'dash' : { 'href' : 'https://codepen.io/chriddyp/pen/bWLwgP.css' , 'rel' : 'stylesheet' , 'crossorigin' : 'anonymous' , }, 'bulma' : { 'href' : 'https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css' , 'rel' : 'stylesheet' , 'integrity' : 'sha384-H5O3U+oUYwd/bFECZMaQ1XJlueV5e1gB4b7Xt0M06fPbgz48WH33qxUyQNPeZVou' , # pragma: allowlist secret 'crossorigin' : 'anonymous' , }, 'bulmaswatch-flatly' : { 'href' : 'https://jenil.github.io/bulmaswatch/flatly/bulmaswatch.min.css' , 'rel' : 'stylesheet' , }, 'normalize' : { 'href' : 'https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css' , 'rel' : 'stylesheet' , 'integrity' : 'sha384-9Z9AuAj0Xi0z7WFOSgjjow8EnNY9wPNp925TVLlAyWhvZPsf5Ks23Ex0mxIrWJzJ' , # pragma: allowlist secret 'crossorigin' : 'anonymous' , }, } \"\"\"Dictionary of stylesheet names and URL to minimized CSS asset. Hashes generated from: https://www.srihash.org/ \"\"\" def init_app ( ** app_kwargs : dict ) -> dash . Dash : \"\"\"Return new Dash app. If not overridden in kwargs, will set path to assets folder, add dash stylesheets, and default meta tags. Args: app_kwargs: any kwargs to pass to the dash initializer Returns: dash.Dash: instance (`app`) \"\"\" if 'assets_folder' not in app_kwargs : app_kwargs [ 'assets_folder' ] = str ( ASSETS_DIR ) if 'external_stylesheets' not in app_kwargs : app_kwargs [ 'external_stylesheets' ] = [ STATIC_URLS [ 'dash' ]] if 'meta_tags' not in app_kwargs : app_kwargs [ 'meta_tags' ] = [{ 'name' : 'viewport' , 'content' : 'width=device-width, initial-scale=1' }] return dash . Dash ( __name__ , ** app_kwargs ) class AppInterface ( Interface ): # noqa: H601 \"\"\"Base Dash Application Interface.\"\"\" name = None _il = {} external_stylesheets = [] modules : list = [] validation_layout = None init_app_kwargs = {} def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : # noqa: D102, D107 ... def create ( self , assign_layout : bool = True ) -> None : # noqa: D102 ... def override_module_defaults ( self ) -> None : # noqa: D102 ... def initialization ( self ) -> None : # noqa: D102 ... def generate_data ( self ) -> None : # noqa: D102 ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : # noqa: D102 ... def verify_app_initialization ( self ) -> None : # noqa: D102 ... def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex `self.chart_main = ParetoChart()`) \"\"\" ... def return_layout ( self ) -> dict : # noqa: D102 ... def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): # noqa: D102 ... def create_callbacks ( self ) -> None : \"\"\"Register the chart callbacks. Does not return a result. May `pass` as long as no callbacks are needed for application \"\"\" ... def run ( self , ** dash_kwargs : dict ) -> None : # noqa: D102 ... def get_server ( self ): # noqa: D102 ... class AppBase : # noqa: H601 \"\"\"Base class for building Dash Applications.\"\"\" name = None \"\"\"Child class must specify a name for the application. Set in `self.__init__()` \"\"\" nsi = Box ({}) \"\"\"Box dictionary of Non-Specific IDs (NSI). In `self.initialization()` automatically registered. Set in `self.__init__()` \"\"\" _il = {} \"\"\"Specific ID lookup (IL) used to track each element in UI that requires a callback.\"\"\" _id = {} \"\"\"Dotted-dict to store ID's relevant for a given chart (replaces storing each id as a data member). FIXME: Need to decide if there is a better approach. Reading this code is confusing... \"\"\" external_stylesheets = [ STATIC_URLS [ 'dash' ]] \"\"\"List of external stylesheets. Default is minimal Dash CSS. Only applies if app argument not provided.\"\"\" modules : list = [] \"\"\"Initialized modules for GUI set in `self.initialization()`. Leave as an empty list if no modules are needed. If list contains modules, in self.create(), each module's `*.create_elements` / `*.create_callbacks` will be called Child class must call `*.return_layout(ids)` to render each module's layout in `self.return_layout()` method \"\"\" validation_layout = None \"\"\"Validation layout used for callback validation. If None, will use the default layout for callback exceptions.\"\"\" init_app_kwargs = {} \"\"\"Additional keyword arguments passed to `init_app()`.\"\"\" # In child class, declare the rest of the static data members here def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : \"\"\"Initialize app and initial data members. Should be inherited in child class and called with super(). Args: app: Dash instance. If None, will create standalone app. Otherwise, will be part of existing app \"\"\" default = { 'title' : self . name , 'external_stylesheets' : self . external_stylesheets } self . init_app_kwargs = { ** default , ** self . init_app_kwargs } self . app = app or init_app ( ** self . init_app_kwargs ) def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" self . register_uniq_ids ([ * self . _id . values ()]) self . generate_data () def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server Variables \u2693\ufe0e ASSETS_DIR Path to the static files directory. COUNTER Initialize iterator to provide set of unique integers when called with next(...) . STATIC_URLS Dictionary of stylesheet names and URL to minimized CSS asset. Hashes generated from: https://www.srihash.org/ Functions \u2693\ufe0e init_app \u2693\ufe0e def init_app ( ** app_kwargs : dict ) -> dash . dash . Dash Return new Dash app. If not overridden in kwargs, will set path to assets folder, add dash stylesheets, and default meta tags. Parameters: Name Description app_kwargs any kwargs to pass to the dash initializer Returns: Type Description dash.Dash instance ( app ) View Source def init_app ( ** app_kwargs : dict ) -> dash . Dash : \"\"\"Return new Dash app. If not overridden in kwargs, will set path to assets folder, add dash stylesheets, and default meta tags. Args: app_kwargs: any kwargs to pass to the dash initializer Returns: dash.Dash: instance (`app`) \"\"\" if 'assets_folder' not in app_kwargs : app_kwargs [ 'assets_folder' ] = str ( ASSETS_DIR ) if 'external_stylesheets' not in app_kwargs : app_kwargs [ 'external_stylesheets' ] = [ STATIC_URLS [ 'dash' ]] if 'meta_tags' not in app_kwargs : app_kwargs [ 'meta_tags' ] = [{ 'name' : 'viewport' , 'content' : 'width=device-width, initial-scale=1' }] return dash . Dash ( __name__ , ** app_kwargs ) Classes \u2693\ufe0e AppBase \u2693\ufe0e class AppBase ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppBase : # noqa: H601 \"\"\"Base class for building Dash Applications.\"\"\" name = None \"\"\"Child class must specify a name for the application. Set in `self.__init__()` \"\"\" nsi = Box ({}) \"\"\"Box dictionary of Non-Specific IDs (NSI). In `self.initialization()` automatically registered. Set in `self.__init__()` \"\"\" _il = {} \"\"\"Specific ID lookup (IL) used to track each element in UI that requires a callback.\"\"\" _id = {} \"\"\"Dotted-dict to store ID's relevant for a given chart (replaces storing each id as a data member). FIXME: Need to decide if there is a better approach. Reading this code is confusing... \"\"\" external_stylesheets = [ STATIC_URLS [ 'dash' ]] \"\"\"List of external stylesheets. Default is minimal Dash CSS. Only applies if app argument not provided.\"\"\" modules : list = [] \"\"\"Initialized modules for GUI set in `self.initialization()`. Leave as an empty list if no modules are needed. If list contains modules, in self.create(), each module's `*.create_elements` / `*.create_callbacks` will be called Child class must call `*.return_layout(ids)` to render each module's layout in `self.return_layout()` method \"\"\" validation_layout = None \"\"\"Validation layout used for callback validation. If None, will use the default layout for callback exceptions.\"\"\" init_app_kwargs = {} \"\"\"Additional keyword arguments passed to `init_app()`.\"\"\" # In child class, declare the rest of the static data members here def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : \"\"\"Initialize app and initial data members. Should be inherited in child class and called with super(). Args: app: Dash instance. If None, will create standalone app. Otherwise, will be part of existing app \"\"\" default = { 'title' : self . name , 'external_stylesheets' : self . external_stylesheets } self . init_app_kwargs = { ** default , ** self . init_app_kwargs } self . app = app or init_app ( ** self . init_app_kwargs ) def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" self . register_uniq_ids ([ * self . _id . values ()]) self . generate_data () def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server Descendants \u2693\ufe0e dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app_with_navigation.StaticTab dash_charts.app_px.TabBase Class variables \u2693\ufe0e external_stylesheets List of external stylesheets. Default is minimal Dash CSS. Only applies if app argument not provided. init_app_kwargs Additional keyword arguments passed to init_app() . modules name Child class must specify a name for the application. Set in self.__init__() nsi Box dictionary of Non-Specific IDs (NSI). In self.initialization() automatically registered. Set in self.__init__() validation_layout Validation layout used for callback validation. If None, will use the default layout for callback exceptions. Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" self . register_uniq_ids ([ * self . _id . values ()]) self . generate_data () override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object. Default is simple HTML text View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) AppInterface \u2693\ufe0e class AppInterface ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppInterface ( Interface ): # noqa: H601 \"\"\"Base Dash Application Interface.\"\"\" name = None _il = {} external_stylesheets = [] modules : list = [] validation_layout = None init_app_kwargs = {} def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : # noqa: D102, D107 ... def create ( self , assign_layout : bool = True ) -> None : # noqa: D102 ... def override_module_defaults ( self ) -> None : # noqa: D102 ... def initialization ( self ) -> None : # noqa: D102 ... def generate_data ( self ) -> None : # noqa: D102 ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : # noqa: D102 ... def verify_app_initialization ( self ) -> None : # noqa: D102 ... def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex `self.chart_main = ParetoChart()`) \"\"\" ... def return_layout ( self ) -> dict : # noqa: D102 ... def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): # noqa: D102 ... def create_callbacks ( self ) -> None : \"\"\"Register the chart callbacks. Does not return a result. May `pass` as long as no callbacks are needed for application \"\"\" ... def run ( self , ** dash_kwargs : dict ) -> None : # noqa: D102 ... def get_server ( self ): # noqa: D102 ... Ancestors (in MRO) \u2693\ufe0e implements.Interface Class variables \u2693\ufe0e external_stylesheets init_app_kwargs modules name validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): # noqa: D102 ... create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: D102 ... create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register the chart callbacks. Does not return a result. May pass as long as no callbacks are needed for application View Source def create_callbacks ( self ) -> None : \"\"\"Register the chart callbacks. Does not return a result. May `pass` as long as no callbacks are needed for application \"\"\" ... create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex self.chart_main = ParetoChart() ) View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex `self.chart_main = ParetoChart()`) \"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None View Source def generate_data ( self ) -> None : # noqa: D102 ... get_server \u2693\ufe0e def get_server ( self ) View Source def get_server ( self ): # noqa: D102 ... initialization \u2693\ufe0e def initialization ( self ) -> None View Source def initialization ( self ) -> None : # noqa: D102 ... override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None View Source def override_module_defaults ( self ) -> None : # noqa: D102 ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : # noqa: D102 ... return_layout \u2693\ufe0e def return_layout ( self ) -> dict View Source def return_layout ( self ) -> dict : # noqa: D102 ... run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None View Source def run ( self , ** dash_kwargs : dict ) -> None : # noqa: D102 ... verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None View Source def verify_app_initialization ( self ) -> None : # noqa: D102 ...","title":"dash_charts.utils_app"},{"location":"modules/dash_charts/utils_app/#dash_chartsutils_app","text":"Utility functions and classes for building applications. View Source \"\"\"Utility functions and classes for building applications.\"\"\" from copy import deepcopy from itertools import count from pathlib import Path from pprint import pprint from typing import List , Optional import dash from box import Box from dash import html from implements import Interface from .utils_callbacks import format_app_callback ASSETS_DIR = Path ( __file__ ) . parent / 'assets' \"\"\"Path to the static files directory.\"\"\" COUNTER = count ( start = 0 , step = 1 ) \"\"\"Initialize iterator to provide set of unique integers when called with `next(...)`.\"\"\" STATIC_URLS = { 'dash' : { 'href' : 'https://codepen.io/chriddyp/pen/bWLwgP.css' , 'rel' : 'stylesheet' , 'crossorigin' : 'anonymous' , }, 'bulma' : { 'href' : 'https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css' , 'rel' : 'stylesheet' , 'integrity' : 'sha384-H5O3U+oUYwd/bFECZMaQ1XJlueV5e1gB4b7Xt0M06fPbgz48WH33qxUyQNPeZVou' , # pragma: allowlist secret 'crossorigin' : 'anonymous' , }, 'bulmaswatch-flatly' : { 'href' : 'https://jenil.github.io/bulmaswatch/flatly/bulmaswatch.min.css' , 'rel' : 'stylesheet' , }, 'normalize' : { 'href' : 'https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css' , 'rel' : 'stylesheet' , 'integrity' : 'sha384-9Z9AuAj0Xi0z7WFOSgjjow8EnNY9wPNp925TVLlAyWhvZPsf5Ks23Ex0mxIrWJzJ' , # pragma: allowlist secret 'crossorigin' : 'anonymous' , }, } \"\"\"Dictionary of stylesheet names and URL to minimized CSS asset. Hashes generated from: https://www.srihash.org/ \"\"\" def init_app ( ** app_kwargs : dict ) -> dash . Dash : \"\"\"Return new Dash app. If not overridden in kwargs, will set path to assets folder, add dash stylesheets, and default meta tags. Args: app_kwargs: any kwargs to pass to the dash initializer Returns: dash.Dash: instance (`app`) \"\"\" if 'assets_folder' not in app_kwargs : app_kwargs [ 'assets_folder' ] = str ( ASSETS_DIR ) if 'external_stylesheets' not in app_kwargs : app_kwargs [ 'external_stylesheets' ] = [ STATIC_URLS [ 'dash' ]] if 'meta_tags' not in app_kwargs : app_kwargs [ 'meta_tags' ] = [{ 'name' : 'viewport' , 'content' : 'width=device-width, initial-scale=1' }] return dash . Dash ( __name__ , ** app_kwargs ) class AppInterface ( Interface ): # noqa: H601 \"\"\"Base Dash Application Interface.\"\"\" name = None _il = {} external_stylesheets = [] modules : list = [] validation_layout = None init_app_kwargs = {} def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : # noqa: D102, D107 ... def create ( self , assign_layout : bool = True ) -> None : # noqa: D102 ... def override_module_defaults ( self ) -> None : # noqa: D102 ... def initialization ( self ) -> None : # noqa: D102 ... def generate_data ( self ) -> None : # noqa: D102 ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : # noqa: D102 ... def verify_app_initialization ( self ) -> None : # noqa: D102 ... def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex `self.chart_main = ParetoChart()`) \"\"\" ... def return_layout ( self ) -> dict : # noqa: D102 ... def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): # noqa: D102 ... def create_callbacks ( self ) -> None : \"\"\"Register the chart callbacks. Does not return a result. May `pass` as long as no callbacks are needed for application \"\"\" ... def run ( self , ** dash_kwargs : dict ) -> None : # noqa: D102 ... def get_server ( self ): # noqa: D102 ... class AppBase : # noqa: H601 \"\"\"Base class for building Dash Applications.\"\"\" name = None \"\"\"Child class must specify a name for the application. Set in `self.__init__()` \"\"\" nsi = Box ({}) \"\"\"Box dictionary of Non-Specific IDs (NSI). In `self.initialization()` automatically registered. Set in `self.__init__()` \"\"\" _il = {} \"\"\"Specific ID lookup (IL) used to track each element in UI that requires a callback.\"\"\" _id = {} \"\"\"Dotted-dict to store ID's relevant for a given chart (replaces storing each id as a data member). FIXME: Need to decide if there is a better approach. Reading this code is confusing... \"\"\" external_stylesheets = [ STATIC_URLS [ 'dash' ]] \"\"\"List of external stylesheets. Default is minimal Dash CSS. Only applies if app argument not provided.\"\"\" modules : list = [] \"\"\"Initialized modules for GUI set in `self.initialization()`. Leave as an empty list if no modules are needed. If list contains modules, in self.create(), each module's `*.create_elements` / `*.create_callbacks` will be called Child class must call `*.return_layout(ids)` to render each module's layout in `self.return_layout()` method \"\"\" validation_layout = None \"\"\"Validation layout used for callback validation. If None, will use the default layout for callback exceptions.\"\"\" init_app_kwargs = {} \"\"\"Additional keyword arguments passed to `init_app()`.\"\"\" # In child class, declare the rest of the static data members here def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : \"\"\"Initialize app and initial data members. Should be inherited in child class and called with super(). Args: app: Dash instance. If None, will create standalone app. Otherwise, will be part of existing app \"\"\" default = { 'title' : self . name , 'external_stylesheets' : self . external_stylesheets } self . init_app_kwargs = { ** default , ** self . init_app_kwargs } self . app = app or init_app ( ** self . init_app_kwargs ) def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" self . register_uniq_ids ([ * self . _id . values ()]) self . generate_data () def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"dash_charts.utils_app"},{"location":"modules/dash_charts/utils_app/#variables","text":"ASSETS_DIR Path to the static files directory. COUNTER Initialize iterator to provide set of unique integers when called with next(...) . STATIC_URLS Dictionary of stylesheet names and URL to minimized CSS asset. Hashes generated from: https://www.srihash.org/","title":"Variables"},{"location":"modules/dash_charts/utils_app/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_app/#init_app","text":"def init_app ( ** app_kwargs : dict ) -> dash . dash . Dash Return new Dash app. If not overridden in kwargs, will set path to assets folder, add dash stylesheets, and default meta tags. Parameters: Name Description app_kwargs any kwargs to pass to the dash initializer Returns: Type Description dash.Dash instance ( app ) View Source def init_app ( ** app_kwargs : dict ) -> dash . Dash : \"\"\"Return new Dash app. If not overridden in kwargs, will set path to assets folder, add dash stylesheets, and default meta tags. Args: app_kwargs: any kwargs to pass to the dash initializer Returns: dash.Dash: instance (`app`) \"\"\" if 'assets_folder' not in app_kwargs : app_kwargs [ 'assets_folder' ] = str ( ASSETS_DIR ) if 'external_stylesheets' not in app_kwargs : app_kwargs [ 'external_stylesheets' ] = [ STATIC_URLS [ 'dash' ]] if 'meta_tags' not in app_kwargs : app_kwargs [ 'meta_tags' ] = [{ 'name' : 'viewport' , 'content' : 'width=device-width, initial-scale=1' }] return dash . Dash ( __name__ , ** app_kwargs )","title":"init_app"},{"location":"modules/dash_charts/utils_app/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/utils_app/#appbase","text":"class AppBase ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppBase : # noqa: H601 \"\"\"Base class for building Dash Applications.\"\"\" name = None \"\"\"Child class must specify a name for the application. Set in `self.__init__()` \"\"\" nsi = Box ({}) \"\"\"Box dictionary of Non-Specific IDs (NSI). In `self.initialization()` automatically registered. Set in `self.__init__()` \"\"\" _il = {} \"\"\"Specific ID lookup (IL) used to track each element in UI that requires a callback.\"\"\" _id = {} \"\"\"Dotted-dict to store ID's relevant for a given chart (replaces storing each id as a data member). FIXME: Need to decide if there is a better approach. Reading this code is confusing... \"\"\" external_stylesheets = [ STATIC_URLS [ 'dash' ]] \"\"\"List of external stylesheets. Default is minimal Dash CSS. Only applies if app argument not provided.\"\"\" modules : list = [] \"\"\"Initialized modules for GUI set in `self.initialization()`. Leave as an empty list if no modules are needed. If list contains modules, in self.create(), each module's `*.create_elements` / `*.create_callbacks` will be called Child class must call `*.return_layout(ids)` to render each module's layout in `self.return_layout()` method \"\"\" validation_layout = None \"\"\"Validation layout used for callback validation. If None, will use the default layout for callback exceptions.\"\"\" init_app_kwargs = {} \"\"\"Additional keyword arguments passed to `init_app()`.\"\"\" # In child class, declare the rest of the static data members here def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : \"\"\"Initialize app and initial data members. Should be inherited in child class and called with super(). Args: app: Dash instance. If None, will create standalone app. Otherwise, will be part of existing app \"\"\" default = { 'title' : self . name , 'external_stylesheets' : self . external_stylesheets } self . init_app_kwargs = { ** default , ** self . init_app_kwargs } self . app = app or init_app ( ** self . init_app_kwargs ) def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" self . register_uniq_ids ([ * self . _id . values ()]) self . generate_data () def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"AppBase"},{"location":"modules/dash_charts/utils_app/#descendants","text":"dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app_with_navigation.StaticTab dash_charts.app_px.TabBase","title":"Descendants"},{"location":"modules/dash_charts/utils_app/#class-variables","text":"external_stylesheets List of external stylesheets. Default is minimal Dash CSS. Only applies if app argument not provided. init_app_kwargs Additional keyword arguments passed to init_app() . modules name Child class must specify a name for the application. Set in self.__init__() nsi Box dictionary of Non-Specific IDs (NSI). In self.initialization() automatically registered. Set in self.__init__() validation_layout Validation layout used for callback validation. If None, will use the default layout for callback exceptions.","title":"Class variables"},{"location":"modules/dash_charts/utils_app/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app/#callback","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/utils_app/#create","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/utils_app/#generate_data","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app/#get_server","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/utils_app/#initialization","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" self . register_uniq_ids ([ * self . _id . values ()]) self . generate_data ()","title":"initialization"},{"location":"modules/dash_charts/utils_app/#override_module_defaults","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app/#register_uniq_ids","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app/#return_layout","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object. Default is simple HTML text View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover","title":"return_layout"},{"location":"modules/dash_charts/utils_app/#run","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/utils_app/#verify_app_initialization","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_app/#appinterface","text":"class AppInterface ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppInterface ( Interface ): # noqa: H601 \"\"\"Base Dash Application Interface.\"\"\" name = None _il = {} external_stylesheets = [] modules : list = [] validation_layout = None init_app_kwargs = {} def __init__ ( self , app : Optional [ dash . Dash ] = None ) -> None : # noqa: D102, D107 ... def create ( self , assign_layout : bool = True ) -> None : # noqa: D102 ... def override_module_defaults ( self ) -> None : # noqa: D102 ... def initialization ( self ) -> None : # noqa: D102 ... def generate_data ( self ) -> None : # noqa: D102 ... def register_uniq_ids ( self , app_ids : List [ str ]) -> None : # noqa: D102 ... def verify_app_initialization ( self ) -> None : # noqa: D102 ... def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex `self.chart_main = ParetoChart()`) \"\"\" ... def return_layout ( self ) -> dict : # noqa: D102 ... def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): # noqa: D102 ... def create_callbacks ( self ) -> None : \"\"\"Register the chart callbacks. Does not return a result. May `pass` as long as no callbacks are needed for application \"\"\" ... def run ( self , ** dash_kwargs : dict ) -> None : # noqa: D102 ... def get_server ( self ): # noqa: D102 ...","title":"AppInterface"},{"location":"modules/dash_charts/utils_app/#ancestors-in-mro","text":"implements.Interface","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app/#class-variables_1","text":"external_stylesheets init_app_kwargs modules name validation_layout","title":"Class variables"},{"location":"modules/dash_charts/utils_app/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app/#callback_1","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): # noqa: D102 ...","title":"callback"},{"location":"modules/dash_charts/utils_app/#create_1","text":"def create ( self , assign_layout : bool = True ) -> None View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: D102 ...","title":"create"},{"location":"modules/dash_charts/utils_app/#create_callbacks","text":"def create_callbacks ( self ) -> None Register the chart callbacks. Does not return a result. May pass as long as no callbacks are needed for application View Source def create_callbacks ( self ) -> None : \"\"\"Register the chart callbacks. Does not return a result. May `pass` as long as no callbacks are needed for application \"\"\" ...","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app/#create_elements","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex self.chart_main = ParetoChart() ) View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements. Does not return a result. All charts should be initialized in this method (ex `self.chart_main = ParetoChart()`) \"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/utils_app/#generate_data_1","text":"def generate_data ( self ) -> None View Source def generate_data ( self ) -> None : # noqa: D102 ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app/#get_server_1","text":"def get_server ( self ) View Source def get_server ( self ): # noqa: D102 ...","title":"get_server"},{"location":"modules/dash_charts/utils_app/#initialization_1","text":"def initialization ( self ) -> None View Source def initialization ( self ) -> None : # noqa: D102 ...","title":"initialization"},{"location":"modules/dash_charts/utils_app/#override_module_defaults_1","text":"def override_module_defaults ( self ) -> None View Source def override_module_defaults ( self ) -> None : # noqa: D102 ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app/#register_uniq_ids_1","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : # noqa: D102 ...","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app/#return_layout_1","text":"def return_layout ( self ) -> dict View Source def return_layout ( self ) -> dict : # noqa: D102 ...","title":"return_layout"},{"location":"modules/dash_charts/utils_app/#run_1","text":"def run ( self , ** dash_kwargs : dict ) -> None View Source def run ( self , ** dash_kwargs : dict ) -> None : # noqa: D102 ...","title":"run"},{"location":"modules/dash_charts/utils_app/#verify_app_initialization_1","text":"def verify_app_initialization ( self ) -> None View Source def verify_app_initialization ( self ) -> None : # noqa: D102 ...","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_app_modules/","text":"dash_charts.utils_app_modules \u2693\ufe0e Utilities to build modules (delegated layout & callback methods) for Dash apps. View Source \"\"\"Utilities to build modules (delegated layout & callback methods) for Dash apps.\"\"\" import pandas as pd from dash import dcc class ModuleBase : # noqa: H601 \"\"\"Base class for building a modular component for use in a Dash application.\"\"\" all_ids = None \"\"\"List of ids to register for this module.\"\"\" def __init__ ( self , name ): \"\"\"Initialize module. Args: name: unique string name for this module Raises: NotImplementedError: if child class has not created a list, `all_ids` \"\"\" if self . all_ids is None : raise NotImplementedError ( 'Child class must create list of `self.all_ids`' ) # pragma: no cover # Make ids unique and update all ids so that modules can be reused in the same app self . name = name self . _ids = { _id : f ' { self . name } __ { _id } ' for _id in self . all_ids } self . all_ids = self . _ids . values () self . initialize_mutables () def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Raises: NotImplementedError: Dash HTML object. Default is simple HTML text \"\"\" raise NotImplementedError ( 'Must be implemented' ) # pragma: no cover def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover class DataCache ( ModuleBase ): # noqa: H601 \"\"\"Module to store data in UI and later loaded as needed.\"\"\" id_cache = 'cache' \"\"\"Session ID.\"\"\" all_ids = [ id_cache ] \"\"\"List of ids to register for this module.\"\"\" def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ): \"\"\"Return Dash application layout. `dcc.Store` documentation: https://dash.plotly.com/dash-core-components/store Args: ids: `self._il` from base application storage_type: `dcc.Store` storage type. Default is memory to clear on refresh store_kwargs: additional keyword arguments to pass to `dcc.Store` Returns: dict: Dash HTML object. \"\"\" return dcc . Store ( id = ids [ self . get ( self . id_cache )], storage_type = storage_type , ** store_kwargs ) def return_write_df_map ( self , df_table ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: df_table: dataframe to show in table Returns: list: list of tuples for `map_outputs` \"\"\" return [( self . get ( self . id_cache ), 'data' , df_table . to_json ())] def read_df ( self , args ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: args: either `a_in` or `a_state`, whichever has the id_cache-data Returns: dataframe: returns dataframe read from `dcc.Store` \"\"\" return pd . read_json ( args [ self . get ( self . id_cache )][ 'data' ]) Classes \u2693\ufe0e DataCache \u2693\ufe0e class DataCache ( name ) View Source class DataCache ( ModuleBase ): # noqa: H601 \"\"\"Module to store data in UI and later loaded as needed.\"\"\" id_cache = 'cache' \"\"\"Session ID.\"\"\" all_ids = [ id_cache ] \"\"\"List of ids to register for this module.\"\"\" def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ): \"\"\"Return Dash application layout. `dcc.Store` documentation: https://dash.plotly.com/dash-core-components/store Args: ids: `self._il` from base application storage_type: `dcc.Store` storage type. Default is memory to clear on refresh store_kwargs: additional keyword arguments to pass to `dcc.Store` Returns: dict: Dash HTML object. \"\"\" return dcc . Store ( id = ids [ self . get ( self . id_cache )], storage_type = storage_type , ** store_kwargs ) def return_write_df_map ( self , df_table ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: df_table: dataframe to show in table Returns: list: list of tuples for `map_outputs` \"\"\" return [( self . get ( self . id_cache ), 'data' , df_table . to_json ())] def read_df ( self , args ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: args: either `a_in` or `a_state`, whichever has the id_cache-data Returns: dataframe: returns dataframe read from `dcc.Store` \"\"\" return pd . read_json ( args [ self . get ( self . id_cache )][ 'data' ]) Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_modules.ModuleBase Class variables \u2693\ufe0e all_ids List of ids to register for this module. id_cache Session ID. Methods \u2693\ufe0e create_callbacks \u2693\ufe0e def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover create_elements \u2693\ufe0e def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover get \u2693\ufe0e def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... read_df \u2693\ufe0e def read_df ( self , args ) Return list of tuples for map_outputs that includes the new data cache JSON. Parameters: Name Description args either a_in or a_state , whichever has the id_cache-data Returns: Type Description dataframe returns dataframe read from dcc.Store View Source def read_df ( self , args ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: args: either `a_in` or `a_state`, whichever has the id_cache-data Returns: dataframe: returns dataframe read from `dcc.Store` \"\"\" return pd . read_json ( args [ self . get ( self . id_cache )][ 'data' ]) return_layout \u2693\ufe0e def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ) Return Dash application layout. dcc.Store documentation: https://dash.plotly.com/dash-core-components/store Parameters: Name Description ids self._il from base application storage_type dcc.Store storage type. Default is memory to clear on refresh store_kwargs additional keyword arguments to pass to dcc.Store Returns: Type Description dict Dash HTML object. View Source def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ): \"\"\"Return Dash application layout. `dcc.Store` documentation: https://dash.plotly.com/dash-core-components/store Args: ids: `self._il` from base application storage_type: `dcc.Store` storage type. Default is memory to clear on refresh store_kwargs: additional keyword arguments to pass to `dcc.Store` Returns: dict: Dash HTML object. \"\"\" return dcc . Store ( id = ids [ self . get ( self . id_cache )], storage_type = storage_type , ** store_kwargs ) return_write_df_map \u2693\ufe0e def return_write_df_map ( self , df_table ) Return list of tuples for map_outputs that includes the new data cache JSON. Parameters: Name Description df_table dataframe to show in table Returns: Type Description list list of tuples for map_outputs View Source def return_write_df_map ( self , df_table ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: df_table: dataframe to show in table Returns: list: list of tuples for `map_outputs` \"\"\" return [( self . get ( self . id_cache ), 'data' , df_table . to_json ())] ModuleBase \u2693\ufe0e class ModuleBase ( name ) View Source class ModuleBase : # noqa: H601 \"\"\"Base class for building a modular component for use in a Dash application.\"\"\" all_ids = None \"\"\"List of ids to register for this module.\"\"\" def __init__ ( self , name ): \"\"\"Initialize module. Args: name: unique string name for this module Raises: NotImplementedError: if child class has not created a list, `all_ids` \"\"\" if self . all_ids is None : raise NotImplementedError ( 'Child class must create list of `self.all_ids`' ) # pragma: no cover # Make ids unique and update all ids so that modules can be reused in the same app self . name = name self . _ids = { _id : f ' { self . name } __ { _id } ' for _id in self . all_ids } self . all_ids = self . _ids . values () self . initialize_mutables () def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Raises: NotImplementedError: Dash HTML object. Default is simple HTML text \"\"\" raise NotImplementedError ( 'Must be implemented' ) # pragma: no cover def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover Descendants \u2693\ufe0e dash_charts.utils_app_modules.DataCache dash_charts.modules_datatable.ModuleDataTable dash_charts.modules_upload.UploadModule Class variables \u2693\ufe0e all_ids List of ids to register for this module. Methods \u2693\ufe0e create_callbacks \u2693\ufe0e def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover create_elements \u2693\ufe0e def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover get \u2693\ufe0e def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... return_layout \u2693\ufe0e def return_layout ( self , ids ) Return Dash application layout. Parameters: Name Description ids self._il from base application Raises: Type Description NotImplementedError Dash HTML object. Default is simple HTML text View Source def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Raises: NotImplementedError: Dash HTML object. Default is simple HTML text \"\"\" raise NotImplementedError ( 'Must be implemented' ) # pragma: no cover","title":"dash_charts.utils_app_modules"},{"location":"modules/dash_charts/utils_app_modules/#dash_chartsutils_app_modules","text":"Utilities to build modules (delegated layout & callback methods) for Dash apps. View Source \"\"\"Utilities to build modules (delegated layout & callback methods) for Dash apps.\"\"\" import pandas as pd from dash import dcc class ModuleBase : # noqa: H601 \"\"\"Base class for building a modular component for use in a Dash application.\"\"\" all_ids = None \"\"\"List of ids to register for this module.\"\"\" def __init__ ( self , name ): \"\"\"Initialize module. Args: name: unique string name for this module Raises: NotImplementedError: if child class has not created a list, `all_ids` \"\"\" if self . all_ids is None : raise NotImplementedError ( 'Child class must create list of `self.all_ids`' ) # pragma: no cover # Make ids unique and update all ids so that modules can be reused in the same app self . name = name self . _ids = { _id : f ' { self . name } __ { _id } ' for _id in self . all_ids } self . all_ids = self . _ids . values () self . initialize_mutables () def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Raises: NotImplementedError: Dash HTML object. Default is simple HTML text \"\"\" raise NotImplementedError ( 'Must be implemented' ) # pragma: no cover def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover class DataCache ( ModuleBase ): # noqa: H601 \"\"\"Module to store data in UI and later loaded as needed.\"\"\" id_cache = 'cache' \"\"\"Session ID.\"\"\" all_ids = [ id_cache ] \"\"\"List of ids to register for this module.\"\"\" def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ): \"\"\"Return Dash application layout. `dcc.Store` documentation: https://dash.plotly.com/dash-core-components/store Args: ids: `self._il` from base application storage_type: `dcc.Store` storage type. Default is memory to clear on refresh store_kwargs: additional keyword arguments to pass to `dcc.Store` Returns: dict: Dash HTML object. \"\"\" return dcc . Store ( id = ids [ self . get ( self . id_cache )], storage_type = storage_type , ** store_kwargs ) def return_write_df_map ( self , df_table ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: df_table: dataframe to show in table Returns: list: list of tuples for `map_outputs` \"\"\" return [( self . get ( self . id_cache ), 'data' , df_table . to_json ())] def read_df ( self , args ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: args: either `a_in` or `a_state`, whichever has the id_cache-data Returns: dataframe: returns dataframe read from `dcc.Store` \"\"\" return pd . read_json ( args [ self . get ( self . id_cache )][ 'data' ])","title":"dash_charts.utils_app_modules"},{"location":"modules/dash_charts/utils_app_modules/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/utils_app_modules/#datacache","text":"class DataCache ( name ) View Source class DataCache ( ModuleBase ): # noqa: H601 \"\"\"Module to store data in UI and later loaded as needed.\"\"\" id_cache = 'cache' \"\"\"Session ID.\"\"\" all_ids = [ id_cache ] \"\"\"List of ids to register for this module.\"\"\" def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ): \"\"\"Return Dash application layout. `dcc.Store` documentation: https://dash.plotly.com/dash-core-components/store Args: ids: `self._il` from base application storage_type: `dcc.Store` storage type. Default is memory to clear on refresh store_kwargs: additional keyword arguments to pass to `dcc.Store` Returns: dict: Dash HTML object. \"\"\" return dcc . Store ( id = ids [ self . get ( self . id_cache )], storage_type = storage_type , ** store_kwargs ) def return_write_df_map ( self , df_table ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: df_table: dataframe to show in table Returns: list: list of tuples for `map_outputs` \"\"\" return [( self . get ( self . id_cache ), 'data' , df_table . to_json ())] def read_df ( self , args ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: args: either `a_in` or `a_state`, whichever has the id_cache-data Returns: dataframe: returns dataframe read from `dcc.Store` \"\"\" return pd . read_json ( args [ self . get ( self . id_cache )][ 'data' ])","title":"DataCache"},{"location":"modules/dash_charts/utils_app_modules/#ancestors-in-mro","text":"dash_charts.utils_app_modules.ModuleBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app_modules/#class-variables","text":"all_ids List of ids to register for this module. id_cache Session ID.","title":"Class variables"},{"location":"modules/dash_charts/utils_app_modules/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_modules/#create_callbacks","text":"def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_modules/#create_elements","text":"def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/utils_app_modules/#get","text":"def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ]","title":"get"},{"location":"modules/dash_charts/utils_app_modules/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/utils_app_modules/#read_df","text":"def read_df ( self , args ) Return list of tuples for map_outputs that includes the new data cache JSON. Parameters: Name Description args either a_in or a_state , whichever has the id_cache-data Returns: Type Description dataframe returns dataframe read from dcc.Store View Source def read_df ( self , args ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: args: either `a_in` or `a_state`, whichever has the id_cache-data Returns: dataframe: returns dataframe read from `dcc.Store` \"\"\" return pd . read_json ( args [ self . get ( self . id_cache )][ 'data' ])","title":"read_df"},{"location":"modules/dash_charts/utils_app_modules/#return_layout","text":"def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ) Return Dash application layout. dcc.Store documentation: https://dash.plotly.com/dash-core-components/store Parameters: Name Description ids self._il from base application storage_type dcc.Store storage type. Default is memory to clear on refresh store_kwargs additional keyword arguments to pass to dcc.Store Returns: Type Description dict Dash HTML object. View Source def return_layout ( self , ids , storage_type = 'memory' , ** store_kwargs ): \"\"\"Return Dash application layout. `dcc.Store` documentation: https://dash.plotly.com/dash-core-components/store Args: ids: `self._il` from base application storage_type: `dcc.Store` storage type. Default is memory to clear on refresh store_kwargs: additional keyword arguments to pass to `dcc.Store` Returns: dict: Dash HTML object. \"\"\" return dcc . Store ( id = ids [ self . get ( self . id_cache )], storage_type = storage_type , ** store_kwargs )","title":"return_layout"},{"location":"modules/dash_charts/utils_app_modules/#return_write_df_map","text":"def return_write_df_map ( self , df_table ) Return list of tuples for map_outputs that includes the new data cache JSON. Parameters: Name Description df_table dataframe to show in table Returns: Type Description list list of tuples for map_outputs View Source def return_write_df_map ( self , df_table ): \"\"\"Return list of tuples for `map_outputs` that includes the new data cache JSON. Args: df_table: dataframe to show in table Returns: list: list of tuples for `map_outputs` \"\"\" return [( self . get ( self . id_cache ), 'data' , df_table . to_json ())]","title":"return_write_df_map"},{"location":"modules/dash_charts/utils_app_modules/#modulebase","text":"class ModuleBase ( name ) View Source class ModuleBase : # noqa: H601 \"\"\"Base class for building a modular component for use in a Dash application.\"\"\" all_ids = None \"\"\"List of ids to register for this module.\"\"\" def __init__ ( self , name ): \"\"\"Initialize module. Args: name: unique string name for this module Raises: NotImplementedError: if child class has not created a list, `all_ids` \"\"\" if self . all_ids is None : raise NotImplementedError ( 'Child class must create list of `self.all_ids`' ) # pragma: no cover # Make ids unique and update all ids so that modules can be reused in the same app self . name = name self . _ids = { _id : f ' { self . name } __ { _id } ' for _id in self . all_ids } self . all_ids = self . _ids . values () self . initialize_mutables () def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ] def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Raises: NotImplementedError: Dash HTML object. Default is simple HTML text \"\"\" raise NotImplementedError ( 'Must be implemented' ) # pragma: no cover def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover","title":"ModuleBase"},{"location":"modules/dash_charts/utils_app_modules/#descendants","text":"dash_charts.utils_app_modules.DataCache dash_charts.modules_datatable.ModuleDataTable dash_charts.modules_upload.UploadModule","title":"Descendants"},{"location":"modules/dash_charts/utils_app_modules/#class-variables_1","text":"all_ids List of ids to register for this module.","title":"Class variables"},{"location":"modules/dash_charts/utils_app_modules/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_modules/#create_callbacks_1","text":"def create_callbacks ( self , parent ) Register callbacks to handle user interaction. Parameters: Name Description parent parent instance (ex: self ) View Source def create_callbacks ( self , parent ): \"\"\"Register callbacks to handle user interaction. Args: parent: parent instance (ex: `self`) \"\"\" ... # pragma: no cover","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_modules/#create_elements_1","text":"def create_elements ( self , ids ) Register the callback for creating the main chart. Parameters: Name Description ids self._il from base application View Source def create_elements ( self , ids ): \"\"\"Register the callback for creating the main chart. Args: ids: `self._il` from base application \"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/utils_app_modules/#get_1","text":"def get ( self , _id ) Return the the callback for creating the main chart. Parameters: Name Description _id id from this module that is found in self.all_ids Returns: Type Description str unique id name from instance of this module View Source def get ( self , _id ): \"\"\"Return the the callback for creating the main chart. Args: _id: id from this module that is found in `self.all_ids` Returns: str: unique id name from instance of this module \"\"\" return self . _ids [ _id ]","title":"get"},{"location":"modules/dash_charts/utils_app_modules/#initialize_mutables_1","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/utils_app_modules/#return_layout_1","text":"def return_layout ( self , ids ) Return Dash application layout. Parameters: Name Description ids self._il from base application Raises: Type Description NotImplementedError Dash HTML object. Default is simple HTML text View Source def return_layout ( self , ids ): \"\"\"Return Dash application layout. Args: ids: `self._il` from base application Raises: NotImplementedError: Dash HTML object. Default is simple HTML text \"\"\" raise NotImplementedError ( 'Must be implemented' ) # pragma: no cover","title":"return_layout"},{"location":"modules/dash_charts/utils_app_with_navigation/","text":"dash_charts.utils_app_with_navigation \u2693\ufe0e Classes for more complex applications that have tabbed or paged navigation. View Source \"\"\"Classes for more complex applications that have tabbed or paged navigation.\"\"\" from collections import OrderedDict from copy import deepcopy import dash_bootstrap_components as dbc from dash import dcc , html from implements import implements from .utils_app import AppBase , AppInterface TODO_CLIENT_CALLBACK = ''' TODO: Create clientside callbacks dynamically to update the title on navigation See: http://dash.plotly.com/external-resources ```py app.clientside_callback( \"\"\" function(tab_value) { if (tab_value === 'tab-1') { document.title = 'Tab 1' } else if (tab_value === 'tab-2') { document.title = 'Tab 2' } } \"\"\", Output('blank-output', 'children'), [Input('tabs-example', 'value')] ) \u2018\u2019\u2018 TODO: Try to see if I can resolve the interface differences or if I need make a subclass interface \u2693\ufe0e @implements(AppInterface) # noqa: H601 \u2693\ufe0e class AppWithNavigation(AppBase): \u201c\u201d\u201cBase class for building Dash Application with tabs or URL routing.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 app = None \"\"\"Main Dash application to pass to all child tabs.\"\"\" nav_lookup = None \"\"\"OrderedDict based on the list of tuples from `self.define_nav_elements()`.\"\"\" nav_layouts = None \"\"\"Dictionary with nav_names as keys and corresponding layout as value.\"\"\" def define_nav_elements ( self ) : \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma : no cover def create ( self , ** kwargs ) : \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ( [ (tab.name, tab) for tab in self.define_nav_elements() ] ) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items () : nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ *map(deepcopy, self.nav_layouts.values()) ] # Initialize parent application that handles navigation super (). create ( ** kwargs ) def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super (). initialization () self . register_uniq_ids ( self . app_ids ) def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma : no cover def create_callbacks ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma : no cover @implements(AppInterface) # noqa: H601 class StaticTab(AppBase): \u201c\u201d\u201cSimple App without charts or callbacks.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 basic_style = { ' marginLeft ' : ' auto ', ' marginRight ' : ' auto ', ' maxWidth ' : '1 000 px ', ' paddingTop ' : '1 0 px ', } def initialization ( self ) -> None: \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super (). initialization () self . register_uniq_ids ([' N / A ']) def create_elements ( self ) -> None: \"\"\"Initialize the charts, tables, and other Dash elements..\"\"\" ... def create_callbacks ( self ) -> None: \"\"\"Register callbacks necessary for this tab.\"\"\" ... class AppWithTabs(AppWithNavigation): \u201c\u201d\u201cBase class for building Dash Application with tabs.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # App ids id_tabs_content = 'tabs-wrapper' id_tabs_select = 'tabs-content' app_ids = [ id_tabs_content, id_tabs_select ] \"\"\"List of all ids for the top-level tab view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" tabs = [ dcc.Tab(label=name, value=name) for name, tab in self.nav_lookup.items() ] return html . Div ( children =[ dcc.Tabs( id=self._il[self.id_tabs_select ] , value = list ( self . nav_lookup . keys ()) [ 0 ] , children = tabs , ), html . Div ( id = self . _il [ self.id_tabs_content ] ), ] , ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [ (self.id_tabs_content, 'children') ] inputs = [ (self.id_tabs_select, 'value') ] @self . callback ( outputs , inputs , [] ) def render_tab ( tab_name ) : return [ self.nav_layouts[tab_name ] ] > PLANNED: Make the tabs and chart compact as well when the compact argument is set to True \u2693\ufe0e class FullScreenAppWithTabs(AppWithTabs): # noqa: H601 \u201c\u201d\u201cBase class for building Dash Application with tabs that uses the full window.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 tabs_location = ' left ' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '1 0 % ' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def verify_app_initialization ( self ) : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self . register_uniq_ids ` \"\"\" super (). verify_app_initialization () allowed_locations = (' left ', ' top ', ' bottom ', ' right ') if self . tabs_location not in allowed_locations: # pragma: no cover raise RuntimeError ( f ' `self . tabs_location = { self . tabs_location } ` is not in { allowed_locations }') def return_layout ( self ) -> dict: \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ self . tab_menu (), html . Div ( style = { f ' margin - { self . tabs_location }' : self . tabs_margin }, children = [ html . Div ( id = self . _il [ self . id_tabs_content ])], ), ], ) def generate_tab_kwargs ( self ) : \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc . Tab elements - tab_kwargs: with at minimum keys ` ( style , selected_style ) ` for dcc . Tab - tabs_kwargs: to be passed to dcc . Tabs - tabs_style: style for the dcc . Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact: tab_style = {' padding ' : ' 2 px 4 px 2 px 4 px '} tabs_padding = ' 6 px 0 0 2 px ' else : tab_style = {' padding ' : '1 0 px 20 px 10 px 20 px '} tabs_padding = '1 5 px 0 0 5 px ' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = {' top ' : ' bottom ', ' bottom ' : ' top ', ' left ' : ' right ', ' right ' : ' left '} tabs_style = { # noqa: ECE001 ' backgroundColor ' : '# F9F9F9 ', ' padding ' : tabs_padding , ' position ' : ' fixed ', 'z Index ' : ' 999 ', f ' border { opposite_lookup [ self . tabs_location ]. title ()}' : '1 px solid # d6d6d6 ', self . tabs_location: '0' , } if self . tabs_location in [' left ', ' right '] : # Configure for vertical case selected_style [' border - left '] = ' 3 px solid # 119 DFF ' tabs_kwargs = { ' vertical ' : True , ' style ' : {' width ' : '1 00 % '}, ' parent_style ' : {' width ' : '1 00 % '}, } tabs_style [' top '] = '0' tabs_style [' bottom '] = '0' tabs_style [' width '] = ' auto ' else : # Configure for horizontal case selected_style [' border - top '] = ' 3 px solid # 119 DFF ' tabs_kwargs = {} tabs_style [ 'he ight '] = ' auto ' tabs_style [' right '] = '0' tabs_style [' left '] = '0' tab_kwargs = {' style ' : tab_style , ' selected_style ' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style ) def tab_menu ( self ) : \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , ) class AppMultiPage(AppWithNavigation): # noqa: H601 \u201c\u201d\u201cBase class for building Dash Application with multiple pages.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 navbar_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" dropdown_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" logo = None \"\"\"Optional path to logo. If None, no logo will be shown in navbar.\"\"\" # App ids id_url = 'pages-url' id_pages_content = 'pages-wrapper' id_toggler = 'nav-toggle' id_collapse = 'nav-collapse' app_ids = [ id_url, id_pages_content, id_toggler, id_collapse ] \"\"\"List of all ids for the top-level pages view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children =[ dcc.Location(id=self._il[self.id_url ] , refresh = False ), self . nav_bar (), html . Div ( id = self . _il [ self.id_pages_content ] ), ] , ) def nav_bar ( self ) : \"\"\"Return the HTML elements for the navigation menu. Returns: dict: Dash HTML object \"\"\" # Create brand icon and name where icon in optional brand = [] if self . logo : brand . append ( dbc . Col ( html . Img ( src = self . logo , height = '25px' ))) brand . append ( dbc . Col ( dbc . NavbarBrand ( self . name , className = 'ml-2' ))) # Create links in navbar and dropdown . Both are optional links = [] if self . navbar_links : links . append ( dbc . Nav ( children =[ dbc.NavItem(dbc.NavLink(name, href=link)) for name, link in self.navbar_links ] , fill = True , navbar = True , ), ) if self . dropdown_links : links . append ( dbc . Nav ( dbc . DropdownMenu ( children =[ dbc.DropdownMenuItem(name, href=link) for name, link in self.dropdown_links ] , in_navbar = True , label = 'Links' , nav = True , ), navbar = True , ), ) # Layout default navbar return dbc . Navbar ( children =[ dbc.NavLink( [ dbc.Row( children=brand, align='center g-0', ), ] , href = '/' , ), dbc . NavbarToggler ( id = self . _il [ self.id_toggler ] ), dbc . Collapse ( dbc . Row ( children = links , className = 'flex-nowrap mt-3 mt-md-0 g-0' , align = 'center' , ), id = self . _il [ self.id_collapse ] , navbar = True , ), ] , sticky = 'top' , color = 'dark' , dark = True , ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [ (self.id_pages_content, 'children') ] inputs = [ (self.id_url, 'pathname') ] @self . callback ( outputs , inputs , [] ) def render_page ( pathname ) : try : # TODO : Demo how pages could use parameters from pathname return [ self.nav_layouts[self.select_page_name(pathname) ] ] except Exception as err : return [ html.Div(children=[f'Error rendering \"{pathname}\":\\n{err}' ] ) ] @self . callback ( [ (self.id_collapse, 'is_open') ] , [ (self.id_toggler, 'n_clicks') ] , [ (self.id_collapse, 'is_open') ] , ) def toggle_navbar_collapse ( n_clicks , is_open ) : return [ not is_open if n_clicks else is_open ] def select_page_name ( self , pathname ) : \"\"\"Return the page name determined based on the pathname. Should return str: page name Args: pathname: relative pathname from URL Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'nav_bar must be implemented by child class' ) # pragma : no cover ``` Variables \u2693\ufe0e TODO_CLIENT_CALLBACK Classes \u2693\ufe0e AppMultiPage \u2693\ufe0e class AppMultiPage ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppMultiPage ( AppWithNavigation ): # noqa: H601 \"\"\"Base class for building Dash Application with multiple pages.\"\"\" navbar_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" dropdown_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" logo = None \"\"\"Optional path to logo. If None, no logo will be shown in navbar.\"\"\" # App ids id_url = 'pages-url' id_pages_content = 'pages-wrapper' id_toggler = 'nav-toggle' id_collapse = 'nav-collapse' app_ids = [ id_url , id_pages_content , id_toggler , id_collapse ] \"\"\"List of all ids for the top-level pages view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ dcc . Location ( id = self . _il [ self . id_url ], refresh = False ), self . nav_bar (), html . Div ( id = self . _il [ self . id_pages_content ]), ], ) def nav_bar ( self ): \"\"\"Return the HTML elements for the navigation menu. Returns: dict: Dash HTML object \"\"\" # Create brand icon and name where icon in optional brand = [] if self . logo : brand . append ( dbc . Col ( html . Img ( src = self . logo , height = '25px' ))) brand . append ( dbc . Col ( dbc . NavbarBrand ( self . name , className = 'ml-2' ))) # Create links in navbar and dropdown. Both are optional links = [] if self . navbar_links : links . append ( dbc . Nav ( children = [ dbc . NavItem ( dbc . NavLink ( name , href = link )) for name , link in self . navbar_links ], fill = True , navbar = True , ), ) if self . dropdown_links : links . append ( dbc . Nav ( dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( name , href = link ) for name , link in self . dropdown_links ], in_navbar = True , label = 'Links' , nav = True , ), navbar = True , ), ) # Layout default navbar return dbc . Navbar ( children = [ dbc . NavLink ( [ dbc . Row ( children = brand , align = 'center g-0' , ), ], href = '/' , ), dbc . NavbarToggler ( id = self . _il [ self . id_toggler ]), dbc . Collapse ( dbc . Row ( children = links , className = 'flex-nowrap mt-3 mt-md-0 g-0' , align = 'center' , ), id = self . _il [ self . id_collapse ], navbar = True , ), ], sticky = 'top' , color = 'dark' , dark = True , ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_pages_content , 'children' )] inputs = [( self . id_url , 'pathname' )] @self . callback ( outputs , inputs , []) def render_page ( pathname ): try : # TODO: Demo how pages could use parameters from pathname return [ self . nav_layouts [ self . select_page_name ( pathname )]] except Exception as err : return [ html . Div ( children = [ f 'Error rendering \" { pathname } \": \\n { err } ' ])] @self . callback ( [( self . id_collapse , 'is_open' )], [( self . id_toggler , 'n_clicks' )], [( self . id_collapse , 'is_open' )], ) def toggle_navbar_collapse ( n_clicks , is_open ): return [ not is_open if n_clicks else is_open ] def select_page_name ( self , pathname ): \"\"\"Return the page name determined based on the pathname. Should return str: page name Args: pathname: relative pathname from URL Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'nav_bar must be implemented by child class' ) # pragma: no cover Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase Class variables \u2693\ufe0e app app_ids List of all ids for the top-level pages view. Will be mapped to self._il for globally unique ids. dropdown_links Base class must create list of tuples [('Link Name', '/link'), ] to use default self.nav_bar() . external_stylesheets id_collapse id_pages_content id_toggler id_url init_app_kwargs logo Optional path to logo. If None, no logo will be shown in navbar. modules name nav_layouts nav_lookup navbar_links Base class must create list of tuples [('Link Name', '/link'), ] to use default self.nav_bar() . nsi validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_pages_content , 'children' )] inputs = [( self . id_url , 'pathname' )] @self . callback ( outputs , inputs , []) def render_page ( pathname ): try : # TODO: Demo how pages could use parameters from pathname return [ self . nav_layouts [ self . select_page_name ( pathname )]] except Exception as err : return [ html . Div ( children = [ f 'Error rendering \" { pathname } \": \\n { err } ' ])] @self . callback ( [( self . id_collapse , 'is_open' )], [( self . id_toggler , 'n_clicks' )], [( self . id_collapse , 'is_open' )], ) def toggle_navbar_collapse ( n_clicks , is_open ): return [ not is_open if n_clicks else is_open ] create_elements \u2693\ufe0e def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover define_nav_elements \u2693\ufe0e def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) nav_bar \u2693\ufe0e def nav_bar ( self ) Return the HTML elements for the navigation menu. Returns: Type Description dict Dash HTML object View Source def nav_bar ( self ): \"\"\"Return the HTML elements for the navigation menu. Returns: dict: Dash HTML object \"\"\" # Create brand icon and name where icon in optional brand = [] if self . logo : brand . append ( dbc . Col ( html . Img ( src = self . logo , height = '25px' ))) brand . append ( dbc . Col ( dbc . NavbarBrand ( self . name , className = 'ml-2' ))) # Create links in navbar and dropdown. Both are optional links = [] if self . navbar_links : links . append ( dbc . Nav ( children = [ dbc . NavItem ( dbc . NavLink ( name , href = link )) for name , link in self . navbar_links ], fill = True , navbar = True , ), ) if self . dropdown_links : links . append ( dbc . Nav ( dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( name , href = link ) for name , link in self . dropdown_links ], in_navbar = True , label = 'Links' , nav = True , ), navbar = True , ), ) # Layout default navbar return dbc . Navbar ( children = [ dbc . NavLink ( [ dbc . Row ( children = brand , align = 'center g-0' , ), ], href = '/' , ), dbc . NavbarToggler ( id = self . _il [ self . id_toggler ]), dbc . Collapse ( dbc . Row ( children = links , className = 'flex-nowrap mt-3 mt-md-0 g-0' , align = 'center' , ), id = self . _il [ self . id_collapse ], navbar = True , ), ], sticky = 'top' , color = 'dark' , dark = True , ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ dcc . Location ( id = self . _il [ self . id_url ], refresh = False ), self . nav_bar (), html . Div ( id = self . _il [ self . id_pages_content ]), ], ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover select_page_name \u2693\ufe0e def select_page_name ( self , pathname ) Return the page name determined based on the pathname. Should return str: page name Parameters: Name Description pathname relative pathname from URL Raises: Type Description NotImplementedError Child class must implement this method View Source def select_page_name ( self , pathname ): \"\"\"Return the page name determined based on the pathname. Should return str: page name Args: pathname: relative pathname from URL Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'nav_bar must be implemented by child class' ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) AppWithNavigation \u2693\ufe0e class AppWithNavigation ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppWithNavigation ( AppBase ): \"\"\"Base class for building Dash Application with tabs or URL routing.\"\"\" app = None \"\"\"Main Dash application to pass to all child tabs.\"\"\" nav_lookup = None \"\"\"OrderedDict based on the list of tuples from `self.define_nav_elements()`.\"\"\" nav_layouts = None \"\"\"Dictionary with nav_names as keys and corresponding layout as value.\"\"\" def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover def create_callbacks ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app.AppBase Descendants \u2693\ufe0e dash_charts.utils_app_with_navigation.AppWithTabs dash_charts.utils_app_with_navigation.AppMultiPage Class variables \u2693\ufe0e app Main Dash application to pass to all child tabs. external_stylesheets init_app_kwargs modules name nav_layouts Dictionary with nav_names as keys and corresponding layout as value. nav_lookup OrderedDict based on the list of tuples from self.define_nav_elements() . nsi validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Override method as not needed at navigation-level. View Source def create_callbacks ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover create_elements \u2693\ufe0e def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover define_nav_elements \u2693\ufe0e def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object. Default is simple HTML text View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) AppWithTabs \u2693\ufe0e class AppWithTabs ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppWithTabs ( AppWithNavigation ): \"\"\"Base class for building Dash Application with tabs.\"\"\" # App ids id_tabs_content = 'tabs-wrapper' id_tabs_select = 'tabs-content' app_ids = [ id_tabs_content , id_tabs_select ] \"\"\"List of all ids for the top-level tab view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" tabs = [ dcc . Tab ( label = name , value = name ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ), html . Div ( id = self . _il [ self . id_tabs_content ]), ], ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]] Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase Descendants \u2693\ufe0e dash_charts.utils_app_with_navigation.FullScreenAppWithTabs Class variables \u2693\ufe0e app app_ids List of all ids for the top-level tab view. Will be mapped to self._il for globally unique ids. external_stylesheets id_tabs_content id_tabs_select init_app_kwargs modules name nav_layouts nav_lookup nsi validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]] create_elements \u2693\ufe0e def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover define_nav_elements \u2693\ufe0e def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" tabs = [ dcc . Tab ( label = name , value = name ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ), html . Div ( id = self . _il [ self . id_tabs_content ]), ], ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' ) FullScreenAppWithTabs \u2693\ufe0e class FullScreenAppWithTabs ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class FullScreenAppWithTabs ( AppWithTabs ): # noqa: H601 \"\"\"Base class for building Dash Application with tabs that uses the full window.\"\"\" tabs_location = 'left' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '10%' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def verify_app_initialization ( self ): \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" super () . verify_app_initialization () allowed_locations = ( 'left' , 'top' , 'bottom' , 'right' ) if self . tabs_location not in allowed_locations : # pragma: no cover raise RuntimeError ( f '`self.tabs_location = { self . tabs_location } ` is not in { allowed_locations } ' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ self . tab_menu (), html . Div ( style = { f 'margin- { self . tabs_location } ' : self . tabs_margin }, children = [ html . Div ( id = self . _il [ self . id_tabs_content ])], ), ], ) def generate_tab_kwargs ( self ): \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys `(style, selected_style)` for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact : tab_style = { 'padding' : '2px 4px 2px 4px' } tabs_padding = '6px 0 0 2px' else : tab_style = { 'padding' : '10px 20px 10px 20px' } tabs_padding = '15px 0 0 5px' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = { 'top' : 'bottom' , 'bottom' : 'top' , 'left' : 'right' , 'right' : 'left' } tabs_style = { # noqa: ECE001 'backgroundColor' : '#F9F9F9' , 'padding' : tabs_padding , 'position' : 'fixed' , 'zIndex' : '999' , f 'border { opposite_lookup [ self . tabs_location ] . title () } ' : '1px solid #d6d6d6' , self . tabs_location : '0' , } if self . tabs_location in [ 'left' , 'right' ]: # Configure for vertical case selected_style [ 'border-left' ] = '3px solid #119DFF' tabs_kwargs = { 'vertical' : True , 'style' : { 'width' : '100%' }, 'parent_style' : { 'width' : '100%' }, } tabs_style [ 'top' ] = '0' tabs_style [ 'bottom' ] = '0' tabs_style [ 'width' ] = 'auto' else : # Configure for horizontal case selected_style [ 'border-top' ] = '3px solid #119DFF' tabs_kwargs = {} tabs_style [ 'height' ] = 'auto' tabs_style [ 'right' ] = '0' tabs_style [ 'left' ] = '0' tab_kwargs = { 'style' : tab_style , 'selected_style' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style ) def tab_menu ( self ): \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , ) Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app_with_navigation.AppWithTabs dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase Descendants \u2693\ufe0e dash_charts.app_px.InteractivePXApp Class variables \u2693\ufe0e app app_ids external_stylesheets id_tabs_content id_tabs_select init_app_kwargs modules name nav_layouts nav_lookup nsi tabs_compact Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True. tabs_location Tab orientation setting. One of (left, top, bottom, right) . tabs_margin Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs. validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]] create_elements \u2693\ufe0e def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover define_nav_elements \u2693\ufe0e def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... generate_tab_kwargs \u2693\ufe0e def generate_tab_kwargs ( self ) Create the tab keyword arguments. Intended to be modified through inheritance. Returns: Type Description tuple keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys (style, selected_style) for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element View Source def generate_tab_kwargs ( self ): \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys `(style, selected_style)` for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact : tab_style = { 'padding' : '2px 4px 2px 4px' } tabs_padding = '6px 0 0 2px' else : tab_style = { 'padding' : '10px 20px 10px 20px' } tabs_padding = '15px 0 0 5px' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = { 'top' : 'bottom' , 'bottom' : 'top' , 'left' : 'right' , 'right' : 'left' } tabs_style = { # noqa: ECE001 'backgroundColor' : '#F9F9F9' , 'padding' : tabs_padding , 'position' : 'fixed' , 'zIndex' : '999' , f 'border { opposite_lookup [ self . tabs_location ] . title () } ' : '1px solid #d6d6d6' , self . tabs_location : '0' , } if self . tabs_location in [ 'left' , 'right' ]: # Configure for vertical case selected_style [ 'border-left' ] = '3px solid #119DFF' tabs_kwargs = { 'vertical' : True , 'style' : { 'width' : '100%' }, 'parent_style' : { 'width' : '100%' }, } tabs_style [ 'top' ] = '0' tabs_style [ 'bottom' ] = '0' tabs_style [ 'width' ] = 'auto' else : # Configure for horizontal case selected_style [ 'border-top' ] = '3px solid #119DFF' tabs_kwargs = {} tabs_style [ 'height' ] = 'auto' tabs_style [ 'right' ] = '0' tabs_style [ 'left' ] = '0' tab_kwargs = { 'style' : tab_style , 'selected_style' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style ) get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ self . tab_menu (), html . Div ( style = { f 'margin- { self . tabs_location } ' : self . tabs_margin }, children = [ html . Div ( id = self . _il [ self . id_tabs_content ])], ), ], ) run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover tab_menu \u2693\ufe0e def tab_menu ( self ) Return the HTML elements for the tab menu. Returns: Type Description dict Dash HTML object View Source def tab_menu ( self ): \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , ) verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ): \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" super () . verify_app_initialization () allowed_locations = ( 'left' , 'top' , 'bottom' , 'right' ) if self . tabs_location not in allowed_locations : # pragma: no cover raise RuntimeError ( f '`self.tabs_location = { self . tabs_location } ` is not in { allowed_locations } ' ) StaticTab \u2693\ufe0e class StaticTab ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class StaticTab ( AppBase ): \"\"\"Simple App without charts or callbacks.\"\"\" basic_style = { 'marginLeft' : 'auto' , 'marginRight' : 'auto' , 'maxWidth' : '1000px' , 'paddingTop' : '10px' , } def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ([ 'N/A' ]) def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements..\"\"\" ... def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" ... Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_app.AppBase Class variables \u2693\ufe0e basic_style external_stylesheets init_app_kwargs modules name nsi validation_layout Methods \u2693\ufe0e callback \u2693\ufe0e def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , ) create \u2693\ufe0e def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization () create_callbacks \u2693\ufe0e def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" ... create_elements \u2693\ufe0e def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements.. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements..\"\"\" ... generate_data \u2693\ufe0e def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ... get_server \u2693\ufe0e def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server initialization \u2693\ufe0e def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ([ 'N/A' ]) override_module_defaults \u2693\ufe0e def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ... register_uniq_ids \u2693\ufe0e def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' ) return_layout \u2693\ufe0e def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object. Default is simple HTML text View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover run \u2693\ufe0e def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover verify_app_initialization \u2693\ufe0e def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"dash_charts.utils_app_with_navigation"},{"location":"modules/dash_charts/utils_app_with_navigation/#dash_chartsutils_app_with_navigation","text":"Classes for more complex applications that have tabbed or paged navigation. View Source \"\"\"Classes for more complex applications that have tabbed or paged navigation.\"\"\" from collections import OrderedDict from copy import deepcopy import dash_bootstrap_components as dbc from dash import dcc , html from implements import implements from .utils_app import AppBase , AppInterface TODO_CLIENT_CALLBACK = ''' TODO: Create clientside callbacks dynamically to update the title on navigation See: http://dash.plotly.com/external-resources ```py app.clientside_callback( \"\"\" function(tab_value) { if (tab_value === 'tab-1') { document.title = 'Tab 1' } else if (tab_value === 'tab-2') { document.title = 'Tab 2' } } \"\"\", Output('blank-output', 'children'), [Input('tabs-example', 'value')] ) \u2018\u2019\u2018","title":"dash_charts.utils_app_with_navigation"},{"location":"modules/dash_charts/utils_app_with_navigation/#todo-try-to-see-if-i-can-resolve-the-interface-differences-or-if-i-need-make-a-subclass-interface","text":"","title":"TODO: Try to see if I can resolve the interface differences or if I need make a subclass interface"},{"location":"modules/dash_charts/utils_app_with_navigation/#implementsappinterface-noqa-h601","text":"class AppWithNavigation(AppBase): \u201c\u201d\u201cBase class for building Dash Application with tabs or URL routing.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 app = None \"\"\"Main Dash application to pass to all child tabs.\"\"\" nav_lookup = None \"\"\"OrderedDict based on the list of tuples from `self.define_nav_elements()`.\"\"\" nav_layouts = None \"\"\"Dictionary with nav_names as keys and corresponding layout as value.\"\"\" def define_nav_elements ( self ) : \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma : no cover def create ( self , ** kwargs ) : \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ( [ (tab.name, tab) for tab in self.define_nav_elements() ] ) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items () : nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ *map(deepcopy, self.nav_layouts.values()) ] # Initialize parent application that handles navigation super (). create ( ** kwargs ) def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super (). initialization () self . register_uniq_ids ( self . app_ids ) def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma : no cover def create_callbacks ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma : no cover @implements(AppInterface) # noqa: H601 class StaticTab(AppBase): \u201c\u201d\u201cSimple App without charts or callbacks.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 basic_style = { ' marginLeft ' : ' auto ', ' marginRight ' : ' auto ', ' maxWidth ' : '1 000 px ', ' paddingTop ' : '1 0 px ', } def initialization ( self ) -> None: \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super (). initialization () self . register_uniq_ids ([' N / A ']) def create_elements ( self ) -> None: \"\"\"Initialize the charts, tables, and other Dash elements..\"\"\" ... def create_callbacks ( self ) -> None: \"\"\"Register callbacks necessary for this tab.\"\"\" ... class AppWithTabs(AppWithNavigation): \u201c\u201d\u201cBase class for building Dash Application with tabs.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # App ids id_tabs_content = 'tabs-wrapper' id_tabs_select = 'tabs-content' app_ids = [ id_tabs_content, id_tabs_select ] \"\"\"List of all ids for the top-level tab view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" tabs = [ dcc.Tab(label=name, value=name) for name, tab in self.nav_lookup.items() ] return html . Div ( children =[ dcc.Tabs( id=self._il[self.id_tabs_select ] , value = list ( self . nav_lookup . keys ()) [ 0 ] , children = tabs , ), html . Div ( id = self . _il [ self.id_tabs_content ] ), ] , ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [ (self.id_tabs_content, 'children') ] inputs = [ (self.id_tabs_select, 'value') ] @self . callback ( outputs , inputs , [] ) def render_tab ( tab_name ) : return [ self.nav_layouts[tab_name ] ]","title":"@implements(AppInterface)  # noqa: H601"},{"location":"modules/dash_charts/utils_app_with_navigation/#planned-make-the-tabs-and-chart-compact-as-well-when-the-compact-argument-is-set-to-true","text":"class FullScreenAppWithTabs(AppWithTabs): # noqa: H601 \u201c\u201d\u201cBase class for building Dash Application with tabs that uses the full window.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 tabs_location = ' left ' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '1 0 % ' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def verify_app_initialization ( self ) : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self . register_uniq_ids ` \"\"\" super (). verify_app_initialization () allowed_locations = (' left ', ' top ', ' bottom ', ' right ') if self . tabs_location not in allowed_locations: # pragma: no cover raise RuntimeError ( f ' `self . tabs_location = { self . tabs_location } ` is not in { allowed_locations }') def return_layout ( self ) -> dict: \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ self . tab_menu (), html . Div ( style = { f ' margin - { self . tabs_location }' : self . tabs_margin }, children = [ html . Div ( id = self . _il [ self . id_tabs_content ])], ), ], ) def generate_tab_kwargs ( self ) : \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc . Tab elements - tab_kwargs: with at minimum keys ` ( style , selected_style ) ` for dcc . Tab - tabs_kwargs: to be passed to dcc . Tabs - tabs_style: style for the dcc . Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact: tab_style = {' padding ' : ' 2 px 4 px 2 px 4 px '} tabs_padding = ' 6 px 0 0 2 px ' else : tab_style = {' padding ' : '1 0 px 20 px 10 px 20 px '} tabs_padding = '1 5 px 0 0 5 px ' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = {' top ' : ' bottom ', ' bottom ' : ' top ', ' left ' : ' right ', ' right ' : ' left '} tabs_style = { # noqa: ECE001 ' backgroundColor ' : '# F9F9F9 ', ' padding ' : tabs_padding , ' position ' : ' fixed ', 'z Index ' : ' 999 ', f ' border { opposite_lookup [ self . tabs_location ]. title ()}' : '1 px solid # d6d6d6 ', self . tabs_location: '0' , } if self . tabs_location in [' left ', ' right '] : # Configure for vertical case selected_style [' border - left '] = ' 3 px solid # 119 DFF ' tabs_kwargs = { ' vertical ' : True , ' style ' : {' width ' : '1 00 % '}, ' parent_style ' : {' width ' : '1 00 % '}, } tabs_style [' top '] = '0' tabs_style [' bottom '] = '0' tabs_style [' width '] = ' auto ' else : # Configure for horizontal case selected_style [' border - top '] = ' 3 px solid # 119 DFF ' tabs_kwargs = {} tabs_style [ 'he ight '] = ' auto ' tabs_style [' right '] = '0' tabs_style [' left '] = '0' tab_kwargs = {' style ' : tab_style , ' selected_style ' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style ) def tab_menu ( self ) : \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , ) class AppMultiPage(AppWithNavigation): # noqa: H601 \u201c\u201d\u201cBase class for building Dash Application with multiple pages.\u201d\u201c\u201d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 navbar_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" dropdown_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" logo = None \"\"\"Optional path to logo. If None, no logo will be shown in navbar.\"\"\" # App ids id_url = 'pages-url' id_pages_content = 'pages-wrapper' id_toggler = 'nav-toggle' id_collapse = 'nav-collapse' app_ids = [ id_url, id_pages_content, id_toggler, id_collapse ] \"\"\"List of all ids for the top-level pages view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children =[ dcc.Location(id=self._il[self.id_url ] , refresh = False ), self . nav_bar (), html . Div ( id = self . _il [ self.id_pages_content ] ), ] , ) def nav_bar ( self ) : \"\"\"Return the HTML elements for the navigation menu. Returns: dict: Dash HTML object \"\"\" # Create brand icon and name where icon in optional brand = [] if self . logo : brand . append ( dbc . Col ( html . Img ( src = self . logo , height = '25px' ))) brand . append ( dbc . Col ( dbc . NavbarBrand ( self . name , className = 'ml-2' ))) # Create links in navbar and dropdown . Both are optional links = [] if self . navbar_links : links . append ( dbc . Nav ( children =[ dbc.NavItem(dbc.NavLink(name, href=link)) for name, link in self.navbar_links ] , fill = True , navbar = True , ), ) if self . dropdown_links : links . append ( dbc . Nav ( dbc . DropdownMenu ( children =[ dbc.DropdownMenuItem(name, href=link) for name, link in self.dropdown_links ] , in_navbar = True , label = 'Links' , nav = True , ), navbar = True , ), ) # Layout default navbar return dbc . Navbar ( children =[ dbc.NavLink( [ dbc.Row( children=brand, align='center g-0', ), ] , href = '/' , ), dbc . NavbarToggler ( id = self . _il [ self.id_toggler ] ), dbc . Collapse ( dbc . Row ( children = links , className = 'flex-nowrap mt-3 mt-md-0 g-0' , align = 'center' , ), id = self . _il [ self.id_collapse ] , navbar = True , ), ] , sticky = 'top' , color = 'dark' , dark = True , ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [ (self.id_pages_content, 'children') ] inputs = [ (self.id_url, 'pathname') ] @self . callback ( outputs , inputs , [] ) def render_page ( pathname ) : try : # TODO : Demo how pages could use parameters from pathname return [ self.nav_layouts[self.select_page_name(pathname) ] ] except Exception as err : return [ html.Div(children=[f'Error rendering \"{pathname}\":\\n{err}' ] ) ] @self . callback ( [ (self.id_collapse, 'is_open') ] , [ (self.id_toggler, 'n_clicks') ] , [ (self.id_collapse, 'is_open') ] , ) def toggle_navbar_collapse ( n_clicks , is_open ) : return [ not is_open if n_clicks else is_open ] def select_page_name ( self , pathname ) : \"\"\"Return the page name determined based on the pathname. Should return str: page name Args: pathname: relative pathname from URL Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'nav_bar must be implemented by child class' ) # pragma : no cover ```","title":"&gt; PLANNED: Make the tabs and chart compact as well when the compact argument is set to True"},{"location":"modules/dash_charts/utils_app_with_navigation/#variables","text":"TODO_CLIENT_CALLBACK","title":"Variables"},{"location":"modules/dash_charts/utils_app_with_navigation/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/utils_app_with_navigation/#appmultipage","text":"class AppMultiPage ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppMultiPage ( AppWithNavigation ): # noqa: H601 \"\"\"Base class for building Dash Application with multiple pages.\"\"\" navbar_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" dropdown_links = None \"\"\"Base class must create list of tuples `[('Link Name', '/link'), ]` to use default `self.nav_bar()`.\"\"\" logo = None \"\"\"Optional path to logo. If None, no logo will be shown in navbar.\"\"\" # App ids id_url = 'pages-url' id_pages_content = 'pages-wrapper' id_toggler = 'nav-toggle' id_collapse = 'nav-collapse' app_ids = [ id_url , id_pages_content , id_toggler , id_collapse ] \"\"\"List of all ids for the top-level pages view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ dcc . Location ( id = self . _il [ self . id_url ], refresh = False ), self . nav_bar (), html . Div ( id = self . _il [ self . id_pages_content ]), ], ) def nav_bar ( self ): \"\"\"Return the HTML elements for the navigation menu. Returns: dict: Dash HTML object \"\"\" # Create brand icon and name where icon in optional brand = [] if self . logo : brand . append ( dbc . Col ( html . Img ( src = self . logo , height = '25px' ))) brand . append ( dbc . Col ( dbc . NavbarBrand ( self . name , className = 'ml-2' ))) # Create links in navbar and dropdown. Both are optional links = [] if self . navbar_links : links . append ( dbc . Nav ( children = [ dbc . NavItem ( dbc . NavLink ( name , href = link )) for name , link in self . navbar_links ], fill = True , navbar = True , ), ) if self . dropdown_links : links . append ( dbc . Nav ( dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( name , href = link ) for name , link in self . dropdown_links ], in_navbar = True , label = 'Links' , nav = True , ), navbar = True , ), ) # Layout default navbar return dbc . Navbar ( children = [ dbc . NavLink ( [ dbc . Row ( children = brand , align = 'center g-0' , ), ], href = '/' , ), dbc . NavbarToggler ( id = self . _il [ self . id_toggler ]), dbc . Collapse ( dbc . Row ( children = links , className = 'flex-nowrap mt-3 mt-md-0 g-0' , align = 'center' , ), id = self . _il [ self . id_collapse ], navbar = True , ), ], sticky = 'top' , color = 'dark' , dark = True , ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_pages_content , 'children' )] inputs = [( self . id_url , 'pathname' )] @self . callback ( outputs , inputs , []) def render_page ( pathname ): try : # TODO: Demo how pages could use parameters from pathname return [ self . nav_layouts [ self . select_page_name ( pathname )]] except Exception as err : return [ html . Div ( children = [ f 'Error rendering \" { pathname } \": \\n { err } ' ])] @self . callback ( [( self . id_collapse , 'is_open' )], [( self . id_toggler , 'n_clicks' )], [( self . id_collapse , 'is_open' )], ) def toggle_navbar_collapse ( n_clicks , is_open ): return [ not is_open if n_clicks else is_open ] def select_page_name ( self , pathname ): \"\"\"Return the page name determined based on the pathname. Should return str: page name Args: pathname: relative pathname from URL Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'nav_bar must be implemented by child class' ) # pragma: no cover","title":"AppMultiPage"},{"location":"modules/dash_charts/utils_app_with_navigation/#ancestors-in-mro","text":"dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app_with_navigation/#class-variables","text":"app app_ids List of all ids for the top-level pages view. Will be mapped to self._il for globally unique ids. dropdown_links Base class must create list of tuples [('Link Name', '/link'), ] to use default self.nav_bar() . external_stylesheets id_collapse id_pages_content id_toggler id_url init_app_kwargs logo Optional path to logo. If None, no logo will be shown in navbar. modules name nav_layouts nav_lookup navbar_links Base class must create list of tuples [('Link Name', '/link'), ] to use default self.nav_bar() . nsi validation_layout","title":"Class variables"},{"location":"modules/dash_charts/utils_app_with_navigation/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_with_navigation/#callback","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/utils_app_with_navigation/#create","text":"def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs )","title":"create"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_callbacks","text":"def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_pages_content , 'children' )] inputs = [( self . id_url , 'pathname' )] @self . callback ( outputs , inputs , []) def render_page ( pathname ): try : # TODO: Demo how pages could use parameters from pathname return [ self . nav_layouts [ self . select_page_name ( pathname )]] except Exception as err : return [ html . Div ( children = [ f 'Error rendering \" { pathname } \": \\n { err } ' ])] @self . callback ( [( self . id_collapse , 'is_open' )], [( self . id_toggler , 'n_clicks' )], [( self . id_collapse , 'is_open' )], ) def toggle_navbar_collapse ( n_clicks , is_open ): return [ not is_open if n_clicks else is_open ]","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_elements","text":"def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#define_nav_elements","text":"def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover","title":"define_nav_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#generate_data","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app_with_navigation/#get_server","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/utils_app_with_navigation/#initialization","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids )","title":"initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#nav_bar","text":"def nav_bar ( self ) Return the HTML elements for the navigation menu. Returns: Type Description dict Dash HTML object View Source def nav_bar ( self ): \"\"\"Return the HTML elements for the navigation menu. Returns: dict: Dash HTML object \"\"\" # Create brand icon and name where icon in optional brand = [] if self . logo : brand . append ( dbc . Col ( html . Img ( src = self . logo , height = '25px' ))) brand . append ( dbc . Col ( dbc . NavbarBrand ( self . name , className = 'ml-2' ))) # Create links in navbar and dropdown. Both are optional links = [] if self . navbar_links : links . append ( dbc . Nav ( children = [ dbc . NavItem ( dbc . NavLink ( name , href = link )) for name , link in self . navbar_links ], fill = True , navbar = True , ), ) if self . dropdown_links : links . append ( dbc . Nav ( dbc . DropdownMenu ( children = [ dbc . DropdownMenuItem ( name , href = link ) for name , link in self . dropdown_links ], in_navbar = True , label = 'Links' , nav = True , ), navbar = True , ), ) # Layout default navbar return dbc . Navbar ( children = [ dbc . NavLink ( [ dbc . Row ( children = brand , align = 'center g-0' , ), ], href = '/' , ), dbc . NavbarToggler ( id = self . _il [ self . id_toggler ]), dbc . Collapse ( dbc . Row ( children = links , className = 'flex-nowrap mt-3 mt-md-0 g-0' , align = 'center' , ), id = self . _il [ self . id_collapse ], navbar = True , ), ], sticky = 'top' , color = 'dark' , dark = True , )","title":"nav_bar"},{"location":"modules/dash_charts/utils_app_with_navigation/#override_module_defaults","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app_with_navigation/#register_uniq_ids","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app_with_navigation/#return_layout","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ dcc . Location ( id = self . _il [ self . id_url ], refresh = False ), self . nav_bar (), html . Div ( id = self . _il [ self . id_pages_content ]), ], )","title":"return_layout"},{"location":"modules/dash_charts/utils_app_with_navigation/#run","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/utils_app_with_navigation/#select_page_name","text":"def select_page_name ( self , pathname ) Return the page name determined based on the pathname. Should return str: page name Parameters: Name Description pathname relative pathname from URL Raises: Type Description NotImplementedError Child class must implement this method View Source def select_page_name ( self , pathname ): \"\"\"Return the page name determined based on the pathname. Should return str: page name Args: pathname: relative pathname from URL Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'nav_bar must be implemented by child class' ) # pragma: no cover","title":"select_page_name"},{"location":"modules/dash_charts/utils_app_with_navigation/#verify_app_initialization","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#appwithnavigation","text":"class AppWithNavigation ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppWithNavigation ( AppBase ): \"\"\"Base class for building Dash Application with tabs or URL routing.\"\"\" app = None \"\"\"Main Dash application to pass to all child tabs.\"\"\" nav_lookup = None \"\"\"OrderedDict based on the list of tuples from `self.define_nav_elements()`.\"\"\" nav_layouts = None \"\"\"Dictionary with nav_names as keys and corresponding layout as value.\"\"\" def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs ) def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids ) def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover def create_callbacks ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"AppWithNavigation"},{"location":"modules/dash_charts/utils_app_with_navigation/#ancestors-in-mro_1","text":"dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app_with_navigation/#descendants","text":"dash_charts.utils_app_with_navigation.AppWithTabs dash_charts.utils_app_with_navigation.AppMultiPage","title":"Descendants"},{"location":"modules/dash_charts/utils_app_with_navigation/#class-variables_1","text":"app Main Dash application to pass to all child tabs. external_stylesheets init_app_kwargs modules name nav_layouts Dictionary with nav_names as keys and corresponding layout as value. nav_lookup OrderedDict based on the list of tuples from self.define_nav_elements() . nsi validation_layout","title":"Class variables"},{"location":"modules/dash_charts/utils_app_with_navigation/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_with_navigation/#callback_1","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_1","text":"def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs )","title":"create"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_callbacks_1","text":"def create_callbacks ( self ) -> None Override method as not needed at navigation-level. View Source def create_callbacks ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_elements_1","text":"def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#define_nav_elements_1","text":"def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover","title":"define_nav_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#generate_data_1","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app_with_navigation/#get_server_1","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/utils_app_with_navigation/#initialization_1","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids )","title":"initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#override_module_defaults_1","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app_with_navigation/#register_uniq_ids_1","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app_with_navigation/#return_layout_1","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object. Default is simple HTML text View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover","title":"return_layout"},{"location":"modules/dash_charts/utils_app_with_navigation/#run_1","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/utils_app_with_navigation/#verify_app_initialization_1","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#appwithtabs","text":"class AppWithTabs ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class AppWithTabs ( AppWithNavigation ): \"\"\"Base class for building Dash Application with tabs.\"\"\" # App ids id_tabs_content = 'tabs-wrapper' id_tabs_select = 'tabs-content' app_ids = [ id_tabs_content , id_tabs_select ] \"\"\"List of all ids for the top-level tab view. Will be mapped to `self._il` for globally unique ids.\"\"\" def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" tabs = [ dcc . Tab ( label = name , value = name ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ), html . Div ( id = self . _il [ self . id_tabs_content ]), ], ) def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]]","title":"AppWithTabs"},{"location":"modules/dash_charts/utils_app_with_navigation/#ancestors-in-mro_2","text":"dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app_with_navigation/#descendants_1","text":"dash_charts.utils_app_with_navigation.FullScreenAppWithTabs","title":"Descendants"},{"location":"modules/dash_charts/utils_app_with_navigation/#class-variables_2","text":"app app_ids List of all ids for the top-level tab view. Will be mapped to self._il for globally unique ids. external_stylesheets id_tabs_content id_tabs_select init_app_kwargs modules name nav_layouts nav_lookup nsi validation_layout","title":"Class variables"},{"location":"modules/dash_charts/utils_app_with_navigation/#methods_2","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_with_navigation/#callback_2","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_2","text":"def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs )","title":"create"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_callbacks_2","text":"def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]]","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_elements_2","text":"def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#define_nav_elements_2","text":"def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover","title":"define_nav_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#generate_data_2","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app_with_navigation/#get_server_2","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/utils_app_with_navigation/#initialization_2","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids )","title":"initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#override_module_defaults_2","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app_with_navigation/#register_uniq_ids_2","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app_with_navigation/#return_layout_2","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" tabs = [ dcc . Tab ( label = name , value = name ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ), html . Div ( id = self . _il [ self . id_tabs_content ]), ], )","title":"return_layout"},{"location":"modules/dash_charts/utils_app_with_navigation/#run_2","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/utils_app_with_navigation/#verify_app_initialization_2","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#fullscreenappwithtabs","text":"class FullScreenAppWithTabs ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class FullScreenAppWithTabs ( AppWithTabs ): # noqa: H601 \"\"\"Base class for building Dash Application with tabs that uses the full window.\"\"\" tabs_location = 'left' \"\"\"Tab orientation setting. One of `(left, top, bottom, right)`.\"\"\" tabs_margin = '10%' \"\"\"Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs.\"\"\" tabs_compact = False \"\"\"Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True.\"\"\" def verify_app_initialization ( self ): \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" super () . verify_app_initialization () allowed_locations = ( 'left' , 'top' , 'bottom' , 'right' ) if self . tabs_location not in allowed_locations : # pragma: no cover raise RuntimeError ( f '`self.tabs_location = { self . tabs_location } ` is not in { allowed_locations } ' ) def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ self . tab_menu (), html . Div ( style = { f 'margin- { self . tabs_location } ' : self . tabs_margin }, children = [ html . Div ( id = self . _il [ self . id_tabs_content ])], ), ], ) def generate_tab_kwargs ( self ): \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys `(style, selected_style)` for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact : tab_style = { 'padding' : '2px 4px 2px 4px' } tabs_padding = '6px 0 0 2px' else : tab_style = { 'padding' : '10px 20px 10px 20px' } tabs_padding = '15px 0 0 5px' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = { 'top' : 'bottom' , 'bottom' : 'top' , 'left' : 'right' , 'right' : 'left' } tabs_style = { # noqa: ECE001 'backgroundColor' : '#F9F9F9' , 'padding' : tabs_padding , 'position' : 'fixed' , 'zIndex' : '999' , f 'border { opposite_lookup [ self . tabs_location ] . title () } ' : '1px solid #d6d6d6' , self . tabs_location : '0' , } if self . tabs_location in [ 'left' , 'right' ]: # Configure for vertical case selected_style [ 'border-left' ] = '3px solid #119DFF' tabs_kwargs = { 'vertical' : True , 'style' : { 'width' : '100%' }, 'parent_style' : { 'width' : '100%' }, } tabs_style [ 'top' ] = '0' tabs_style [ 'bottom' ] = '0' tabs_style [ 'width' ] = 'auto' else : # Configure for horizontal case selected_style [ 'border-top' ] = '3px solid #119DFF' tabs_kwargs = {} tabs_style [ 'height' ] = 'auto' tabs_style [ 'right' ] = '0' tabs_style [ 'left' ] = '0' tab_kwargs = { 'style' : tab_style , 'selected_style' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style ) def tab_menu ( self ): \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , )","title":"FullScreenAppWithTabs"},{"location":"modules/dash_charts/utils_app_with_navigation/#ancestors-in-mro_3","text":"dash_charts.utils_app_with_navigation.AppWithTabs dash_charts.utils_app_with_navigation.AppWithNavigation dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app_with_navigation/#descendants_2","text":"dash_charts.app_px.InteractivePXApp","title":"Descendants"},{"location":"modules/dash_charts/utils_app_with_navigation/#class-variables_3","text":"app app_ids external_stylesheets id_tabs_content id_tabs_select init_app_kwargs modules name nav_layouts nav_lookup nsi tabs_compact Boolean setting to toggle between a padded tab layout if False and a minimal compact version if True. tabs_location Tab orientation setting. One of (left, top, bottom, right) . tabs_margin Adjust this setting based on the width or height of the tabs to prevent the content from overlapping the tabs. validation_layout","title":"Class variables"},{"location":"modules/dash_charts/utils_app_with_navigation/#methods_3","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_with_navigation/#callback_3","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_3","text":"def create ( self , ** kwargs ) Create each navigation componet, storing the layout. Then parent class to create application. Parameters: Name Description kwargs keyword arguments passed to self.create View Source def create ( self , ** kwargs ): \"\"\"Create each navigation componet, storing the layout. Then parent class to create application. Args: kwargs: keyword arguments passed to `self.create` \"\"\" # Initialize the lookup for each tab then configure each tab self . nav_lookup = OrderedDict ([( tab . name , tab ) for tab in self . define_nav_elements ()]) self . nav_layouts = {} for nav_name , nav in self . nav_lookup . items (): nav . create ( assign_layout = False ) self . nav_layouts [ nav_name ] = nav . return_layout () # Store validation_layout that is later used for callback verification in base class self . validation_layout = [ * map ( deepcopy , self . nav_layouts . values ())] # Initialize parent application that handles navigation super () . create ( ** kwargs )","title":"create"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_callbacks_3","text":"def create_callbacks ( self ) -> None Register the navigation callback. View Source def create_callbacks ( self ) -> None : \"\"\"Register the navigation callback.\"\"\" outputs = [( self . id_tabs_content , 'children' )] inputs = [( self . id_tabs_select , 'value' )] @self . callback ( outputs , inputs , []) def render_tab ( tab_name ): return [ self . nav_layouts [ tab_name ]]","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_elements_3","text":"def create_elements ( self ) -> None Override method as not needed at navigation-level. View Source def create_elements ( self ) -> None : \"\"\"Override method as not needed at navigation-level.\"\"\" ... # pragma: no cover","title":"create_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#define_nav_elements_3","text":"def define_nav_elements ( self ) Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex [AppBase(self.app)] in the order each tab is rendered Raises: Type Description NotImplementedError Child class must implement this method View Source def define_nav_elements ( self ): \"\"\"Return list of initialized pages or tabs accordingly. Should return, list: each item is an initialized app (ex `[AppBase(self.app)]` in the order each tab is rendered Raises: NotImplementedError: Child class must implement this method \"\"\" raise NotImplementedError ( 'define_nav_elements must be implemented by child class' ) # pragma: no cover","title":"define_nav_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#generate_data_3","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app_with_navigation/#generate_tab_kwargs","text":"def generate_tab_kwargs ( self ) Create the tab keyword arguments. Intended to be modified through inheritance. Returns: Type Description tuple keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys (style, selected_style) for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element View Source def generate_tab_kwargs ( self ): \"\"\"Create the tab keyword arguments. Intended to be modified through inheritance. Returns: tuple: keyword arguments and styling for the dcc.Tab elements - tab_kwargs: with at minimum keys `(style, selected_style)` for dcc.Tab - tabs_kwargs: to be passed to dcc.Tabs - tabs_style: style for the dcc.Tabs HTML element \"\"\" # Unselected tab style if self . tabs_compact : tab_style = { 'padding' : '2px 4px 2px 4px' } tabs_padding = '6px 0 0 2px' else : tab_style = { 'padding' : '10px 20px 10px 20px' } tabs_padding = '15px 0 0 5px' # Extend tab style for selected case selected_style = deepcopy ( tab_style ) opposite_lookup = { 'top' : 'bottom' , 'bottom' : 'top' , 'left' : 'right' , 'right' : 'left' } tabs_style = { # noqa: ECE001 'backgroundColor' : '#F9F9F9' , 'padding' : tabs_padding , 'position' : 'fixed' , 'zIndex' : '999' , f 'border { opposite_lookup [ self . tabs_location ] . title () } ' : '1px solid #d6d6d6' , self . tabs_location : '0' , } if self . tabs_location in [ 'left' , 'right' ]: # Configure for vertical case selected_style [ 'border-left' ] = '3px solid #119DFF' tabs_kwargs = { 'vertical' : True , 'style' : { 'width' : '100%' }, 'parent_style' : { 'width' : '100%' }, } tabs_style [ 'top' ] = '0' tabs_style [ 'bottom' ] = '0' tabs_style [ 'width' ] = 'auto' else : # Configure for horizontal case selected_style [ 'border-top' ] = '3px solid #119DFF' tabs_kwargs = {} tabs_style [ 'height' ] = 'auto' tabs_style [ 'right' ] = '0' tabs_style [ 'left' ] = '0' tab_kwargs = { 'style' : tab_style , 'selected_style' : selected_style } return ( tab_kwargs , tabs_kwargs , tabs_style )","title":"generate_tab_kwargs"},{"location":"modules/dash_charts/utils_app_with_navigation/#get_server_3","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/utils_app_with_navigation/#initialization_3","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ( self . app_ids )","title":"initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#override_module_defaults_3","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app_with_navigation/#register_uniq_ids_3","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app_with_navigation/#return_layout_3","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object \"\"\" return html . Div ( children = [ self . tab_menu (), html . Div ( style = { f 'margin- { self . tabs_location } ' : self . tabs_margin }, children = [ html . Div ( id = self . _il [ self . id_tabs_content ])], ), ], )","title":"return_layout"},{"location":"modules/dash_charts/utils_app_with_navigation/#run_3","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/utils_app_with_navigation/#tab_menu","text":"def tab_menu ( self ) Return the HTML elements for the tab menu. Returns: Type Description dict Dash HTML object View Source def tab_menu ( self ): \"\"\"Return the HTML elements for the tab menu. Returns: dict: Dash HTML object \"\"\" tab_kwargs , tabs_kwargs , tabs_style = self . generate_tab_kwargs () tabs = [ dcc . Tab ( label = name , value = name , ** tab_kwargs ) for name , tab in self . nav_lookup . items ()] return html . Div ( children = [ dcc . Tabs ( id = self . _il [ self . id_tabs_select ], value = list ( self . nav_lookup . keys ())[ 0 ], children = tabs , ** tabs_kwargs , ), ], style = tabs_style , )","title":"tab_menu"},{"location":"modules/dash_charts/utils_app_with_navigation/#verify_app_initialization_3","text":"def verify_app_initialization ( self ) Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ): \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" super () . verify_app_initialization () allowed_locations = ( 'left' , 'top' , 'bottom' , 'right' ) if self . tabs_location not in allowed_locations : # pragma: no cover raise RuntimeError ( f '`self.tabs_location = { self . tabs_location } ` is not in { allowed_locations } ' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#statictab","text":"class StaticTab ( app : Union [ dash . dash . Dash , NoneType ] = None ) View Source class StaticTab ( AppBase ): \"\"\"Simple App without charts or callbacks.\"\"\" basic_style = { 'marginLeft' : 'auto' , 'marginRight' : 'auto' , 'maxWidth' : '1000px' , 'paddingTop' : '10px' , } def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ([ 'N/A' ]) def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements..\"\"\" ... def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" ...","title":"StaticTab"},{"location":"modules/dash_charts/utils_app_with_navigation/#ancestors-in-mro_4","text":"dash_charts.utils_app.AppBase","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_app_with_navigation/#class-variables_4","text":"basic_style external_stylesheets init_app_kwargs modules name nsi validation_layout","title":"Class variables"},{"location":"modules/dash_charts/utils_app_with_navigation/#methods_4","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_app_with_navigation/#callback_4","text":"def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ) Return app callback decorator based on provided components. Parameters: Name Description outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name pic If True, prevent call on page load ( prevent_initial_call ). Default is False **kwargs any additional keyword arguments for self.app.callback Returns: Type Description dict result of self.app.callback() View Source def callback ( self , outputs , inputs , states , pic : bool = False , ** kwargs : dict ): \"\"\"Return app callback decorator based on provided components. Args: outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name pic: If True, prevent call on page load (`prevent_initial_call`). Default is False **kwargs: any additional keyword arguments for `self.app.callback` Returns: dict: result of `self.app.callback()` \"\"\" return self . app . callback ( * format_app_callback ( self . _il , outputs , inputs , states ), prevent_initial_call = pic , ** kwargs , )","title":"callback"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_4","text":"def create ( self , assign_layout : bool = True ) -> None Create the ids, app charts, layout, callbacks, and optional modules. Parameters: Name Description assign_layout if True, will assign self.app.layout . If False, must call self.return_layout separately. Default is True Raises: Type Description NotImplementedError if child class has not set the self.name data member View Source def create ( self , assign_layout : bool = True ) -> None : # noqa: CCR001 \"\"\"Create the ids, app charts, layout, callbacks, and optional modules. Args: assign_layout: if True, will assign `self.app.layout`. If False, must call `self.return_layout` separately. Default is True Raises: NotImplementedError: if child class has not set the `self.name` data member \"\"\" if self . name is None : # pragma: no cover raise NotImplementedError ( 'Child class must set `self.name` to a unique string for this app' ) # Initialize app and each module self . initialization () for mod in self . modules : self . register_uniq_ids ( mod . all_ids ) self . override_module_defaults () # Call optional override method # Create charts for app and each module self . create_elements () for mod in self . modules : mod . create_elements ( self . _il ) # Create app layout. User must call the return_layout method from each module within own return_layout method if assign_layout : self . app . layout = self . return_layout () if assign_layout and self . validation_layout : self . app . validation_layout = [ deepcopy ( self . app . layout )] + self . validation_layout pprint ( ' \\n\\n ValidationLayout?' ) pprint ( self . app . validation_layout ) # Create callbacks for app and each module self . create_callbacks () for mod in self . modules : mod . create_callbacks ( self ) self . verify_app_initialization ()","title":"create"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_callbacks_4","text":"def create_callbacks ( self ) -> None Register callbacks necessary for this tab. View Source def create_callbacks ( self ) -> None : \"\"\"Register callbacks necessary for this tab.\"\"\" ...","title":"create_callbacks"},{"location":"modules/dash_charts/utils_app_with_navigation/#create_elements_4","text":"def create_elements ( self ) -> None Initialize the charts, tables, and other Dash elements.. View Source def create_elements ( self ) -> None : \"\"\"Initialize the charts, tables, and other Dash elements..\"\"\" ...","title":"create_elements"},{"location":"modules/dash_charts/utils_app_with_navigation/#generate_data_4","text":"def generate_data ( self ) -> None Recommended method for generating data stored in memory. Called in initialization. View Source def generate_data ( self ) -> None : \"\"\"Recommended method for generating data stored in memory. Called in initialization.\"\"\" ...","title":"generate_data"},{"location":"modules/dash_charts/utils_app_with_navigation/#get_server_4","text":"def get_server ( self ) Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: Type Description dict the Flask server component of the Dash app View Source def get_server ( self ): \"\"\"Retrieve server from app instance for production hosting with green unicorn, waitress, IIS, etc. Returns: dict: the Flask `server` component of the Dash app \"\"\" return self . app . server","title":"get_server"},{"location":"modules/dash_charts/utils_app_with_navigation/#initialization_4","text":"def initialization ( self ) -> None Initialize ids with self.register_uniq_ids([...]) and other one-time actions. View Source def initialization ( self ) -> None : \"\"\"Initialize ids with `self.register_uniq_ids([...])` and other one-time actions.\"\"\" super () . initialization () self . register_uniq_ids ([ 'N/A' ])","title":"initialization"},{"location":"modules/dash_charts/utils_app_with_navigation/#override_module_defaults_4","text":"def override_module_defaults ( self ) -> None Override default values from modules. View Source def override_module_defaults ( self ) -> None : \"\"\"Override default values from modules.\"\"\" ...","title":"override_module_defaults"},{"location":"modules/dash_charts/utils_app_with_navigation/#register_uniq_ids_4","text":"def register_uniq_ids ( self , app_ids : List [ str ] ) -> None Register the app_ids to the corresponding global_id in the self._il lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers self._il which are a list of globally unique ids (incorporating this App\u2019s unique self.name ) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Parameters: Name Description app_ids list of strings that are unique within this App View Source def register_uniq_ids ( self , app_ids : List [ str ]) -> None : \"\"\"Register the `app_ids` to the corresponding global_id in the `self._il` lookup dictionary. The app_ids must be unique within this App so that a layout can be created. This method registers `self._il` which are a list of globally unique ids (incorporating this App's unique `self.name`) allowing for the child class of this base App to be resused multiple times within a tabbed or multi-page application without id-collision Args: app_ids: list of strings that are unique within this App \"\"\" self . _il = deepcopy ( self . _il ) for app_id in app_ids : self . _il [ app_id ] = f ' { self . name } - { app_id } ' . replace ( ' ' , '-' )","title":"register_uniq_ids"},{"location":"modules/dash_charts/utils_app_with_navigation/#return_layout_4","text":"def return_layout ( self ) -> dict Return Dash application layout. Returns: Type Description dict Dash HTML object. Default is simple HTML text View Source def return_layout ( self ) -> dict : \"\"\"Return Dash application layout. Returns: dict: Dash HTML object. Default is simple HTML text \"\"\" return html . Div ([ 'Welcome to the BaseApp! Override return_layout() in child class.' ]) # pragma: no cover","title":"return_layout"},{"location":"modules/dash_charts/utils_app_with_navigation/#run_4","text":"def run ( self , ** dash_kwargs : dict ) -> None Launch the Dash server instance. Parameters: Name Description **dash_kwargs keyword arguments for Dash.run_server() View Source def run ( self , ** dash_kwargs : dict ) -> None : \"\"\"Launch the Dash server instance. Args: **dash_kwargs: keyword arguments for `Dash.run_server()` \"\"\" self . app . run_server ( ** dash_kwargs ) # pragma: no cover","title":"run"},{"location":"modules/dash_charts/utils_app_with_navigation/#verify_app_initialization_4","text":"def verify_app_initialization ( self ) -> None Check that the app was properly initialized. Raises: Type Description RuntimeError if child class has not called self.register_uniq_ids View Source def verify_app_initialization ( self ) -> None : \"\"\"Check that the app was properly initialized. Raises: RuntimeError: if child class has not called `self.register_uniq_ids` \"\"\" if not self . _il . keys (): # pragma: no cover raise RuntimeError ( 'Child class must first call `self.register_uniq_ids(__)` before self.run()' )","title":"verify_app_initialization"},{"location":"modules/dash_charts/utils_callbacks/","text":"dash_charts.utils_callbacks \u2693\ufe0e Utilities for better Dash callbacks. View Source \"\"\"Utilities for better Dash callbacks.\"\"\" import re import dash from dash.dependencies import Input , Output , State from dash.exceptions import PreventUpdate def format_app_callback ( lookup , outputs , inputs , states ): \"\"\"Format list of [Output, Input, State] for `@app.callback()`. Args: lookup: dict with app_id keys that map to a globally unique component id outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name Returns: list: list[lists] in order `(Outputs, Inputs, States)` for `@app.callback()`. Some sublists may be empty \"\"\" return ( [ Output ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in outputs ], [ Input ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in inputs ], [ State ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in states ], ) def map_args ( raw_args , inputs , states ): \"\"\"Map the function arguments into a dictionary with keys for the input and state names. For situations where the order of inputs and states may change, use this function to verbosely define the inputs: ```python a_in, a_state = map_args(raw_args, inputs, states) click_data = a_in[self.id_main_figure]['clickData'] n_clicks = a_in[self.id_randomize_button]['n_clicks'] data_cache = a_state[self.id_store]['data'] ``` Alternatively, for use cases that are unlikely to change the order of Inputs/State, unwrap positionally with: ```python click_data, n_clicks = args[:len(inputs)] data_cache = args[len(inputs):] ``` Args: raw_args: list of arguments passed to callback inputs: list of input components. May be empty list states: list of state components. May be empty list Returns: dict: with keys of the app_id, property, and arg value (`a_in[key][arg_type]`) \"\"\" # Split args into groups of inputs/states a_in = raw_args [: len ( inputs )] a_state = raw_args [ len ( inputs ):] # Map args into dictionaries arg_map = [{ app_id : [] for app_id in { items [ 0 ] for items in group }} for group in [ inputs , states ]] for group_idx , ( groups , args ) in enumerate ([( inputs , a_in ), ( states , a_state )]): # Assign the arg to the appropriate dictionary in arg_map for arg_idx , ( app_id , prop ) in enumerate ( groups ): arg_map [ group_idx ][ app_id ] . append (( prop , args [ arg_idx ])) for app_id in arg_map [ group_idx ] . keys (): arg_map [ group_idx ][ app_id ] = dict ( arg_map [ group_idx ][ app_id ]) return arg_map def map_outputs ( outputs , element_info ): \"\"\"Return properly ordered list of new Dash elements based on the order of outputs. Alternatively, for simple cases of 1-2 outputs, just return the list with: ```python return [new_element_1, new_element_2] ``` Args: outputs: list of output components element_info: list of tuples with keys `(app_id, prop, element)` Returns: list: ordered list to match the order of outputs Raises: RuntimeError: Check that the number of outputs and the number of element_info match \"\"\" if len ( outputs ) != len ( element_info ): raise RuntimeError ( f 'Expected same number of items between: \\n outputs: { outputs } \\n element_info: { element_info } ' ) # Create a dictionary of the elements lookup = { app_id : [] for app_id in { info [ 0 ] for info in element_info }} for app_id , prop , element in element_info : lookup [ app_id ] . append (( prop , element )) for app_id in lookup : lookup [ app_id ] = dict ( lookup [ app_id ]) return [ lookup [ app_id ][ prop ] for app_id , prop in outputs ] def get_triggered_id (): \"\"\"Use Dash context to get the id of the input element that triggered the callback. See advanced callbacks: https://dash.plotly.com/advanced-callbacks Returns: str: id of the input that triggered the callback Raises: PreventUpdate: if callback was fired without an input \"\"\" ctx = dash . callback_context if not ctx . triggered : raise PreventUpdate prop_id = ctx . triggered [ 0 ][ 'prop_id' ] # in format: `id.key` where we only want the `id` return re . search ( r '(^.+)\\.[^\\.]+$' , prop_id ) . group ( 1 ) Functions \u2693\ufe0e format_app_callback \u2693\ufe0e def format_app_callback ( lookup , outputs , inputs , states ) Format list of [Output, Input, State] for @app.callback() . Parameters: Name Description lookup dict with app_id keys that map to a globally unique component id outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name Returns: Type Description list list[lists] in order (Outputs, Inputs, States) for @app.callback() . Some sublists may be empty View Source def format_app_callback ( lookup , outputs , inputs , states ): \"\"\"Format list of [Output, Input, State] for `@app.callback()`. Args: lookup: dict with app_id keys that map to a globally unique component id outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name Returns: list: list[lists] in order `(Outputs, Inputs, States)` for `@app.callback()`. Some sublists may be empty \"\"\" return ( [ Output ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in outputs ], [ Input ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in inputs ], [ State ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in states ], ) get_triggered_id \u2693\ufe0e def get_triggered_id () Use Dash context to get the id of the input element that triggered the callback. See advanced callbacks: https://dash.plotly.com/advanced-callbacks Returns: Type Description str id of the input that triggered the callback Raises: Type Description PreventUpdate if callback was fired without an input View Source def get_triggered_id (): \"\"\"Use Dash context to get the id of the input element that triggered the callback. See advanced callbacks: https://dash.plotly.com/advanced-callbacks Returns: str: id of the input that triggered the callback Raises: PreventUpdate: if callback was fired without an input \"\"\" ctx = dash . callback_context if not ctx . triggered : raise PreventUpdate prop_id = ctx . triggered [ 0 ][ 'prop_id' ] # in format: `id.key` where we only want the `id` return re . search ( r '(^.+)\\.[^\\.]+$' , prop_id ) . group ( 1 ) map_args \u2693\ufe0e def map_args ( raw_args , inputs , states ) Map the function arguments into a dictionary with keys for the input and state names. For situations where the order of inputs and states may change, use this function to verbosely define the inputs: a_in , a_state = map_args ( raw_args , inputs , states ) click_data = a_in [ self . id_main_figure ][ 'clickData' ] n_clicks = a_in [ self . id_randomize_button ][ 'n_clicks' ] data_cache = a_state [ self . id_store ][ 'data' ] Alternatively, for use cases that are unlikely to change the order of Inputs/State, unwrap positionally with: click_data , n_clicks = args [: len ( inputs )] data_cache = args [ len ( inputs ):] Parameters: Name Description raw_args list of arguments passed to callback inputs list of input components. May be empty list states list of state components. May be empty list Returns: Type Description dict with keys of the app_id, property, and arg value ( a_in[key][arg_type] ) View Source def map_args ( raw_args , inputs , states ): \"\"\"Map the function arguments into a dictionary with keys for the input and state names. For situations where the order of inputs and states may change, use this function to verbosely define the inputs: ```python a_in, a_state = map_args(raw_args, inputs, states) click_data = a_in[self.id_main_figure]['clickData'] n_clicks = a_in[self.id_randomize_button]['n_clicks'] data_cache = a_state[self.id_store]['data'] ``` Alternatively, for use cases that are unlikely to change the order of Inputs/State, unwrap positionally with: ```python click_data, n_clicks = args[:len(inputs)] data_cache = args[len(inputs):] ``` Args: raw_args: list of arguments passed to callback inputs: list of input components. May be empty list states: list of state components. May be empty list Returns: dict: with keys of the app_id, property, and arg value (`a_in[key][arg_type]`) \"\"\" # Split args into groups of inputs/states a_in = raw_args [: len ( inputs )] a_state = raw_args [ len ( inputs ):] # Map args into dictionaries arg_map = [{ app_id : [] for app_id in { items [ 0 ] for items in group }} for group in [ inputs , states ]] for group_idx , ( groups , args ) in enumerate ([( inputs , a_in ), ( states , a_state )]): # Assign the arg to the appropriate dictionary in arg_map for arg_idx , ( app_id , prop ) in enumerate ( groups ): arg_map [ group_idx ][ app_id ] . append (( prop , args [ arg_idx ])) for app_id in arg_map [ group_idx ] . keys (): arg_map [ group_idx ][ app_id ] = dict ( arg_map [ group_idx ][ app_id ]) return arg_map map_outputs \u2693\ufe0e def map_outputs ( outputs , element_info ) Return properly ordered list of new Dash elements based on the order of outputs. Alternatively, for simple cases of 1-2 outputs, just return the list with: return [ new_element_1 , new_element_2 ] Parameters: Name Description outputs list of output components element_info list of tuples with keys (app_id, prop, element) Returns: Type Description list ordered list to match the order of outputs Raises: Type Description RuntimeError Check that the number of outputs and the number of element_info match View Source def map_outputs ( outputs , element_info ): \"\"\"Return properly ordered list of new Dash elements based on the order of outputs. Alternatively, for simple cases of 1-2 outputs, just return the list with: ```python return [new_element_1, new_element_2] ``` Args: outputs: list of output components element_info: list of tuples with keys `(app_id, prop, element)` Returns: list: ordered list to match the order of outputs Raises: RuntimeError: Check that the number of outputs and the number of element_info match \"\"\" if len ( outputs ) != len ( element_info ): raise RuntimeError ( f 'Expected same number of items between: \\n outputs: { outputs } \\n element_info: { element_info } ' ) # Create a dictionary of the elements lookup = { app_id : [] for app_id in { info [ 0 ] for info in element_info }} for app_id , prop , element in element_info : lookup [ app_id ] . append (( prop , element )) for app_id in lookup : lookup [ app_id ] = dict ( lookup [ app_id ]) return [ lookup [ app_id ][ prop ] for app_id , prop in outputs ]","title":"dash_charts.utils_callbacks"},{"location":"modules/dash_charts/utils_callbacks/#dash_chartsutils_callbacks","text":"Utilities for better Dash callbacks. View Source \"\"\"Utilities for better Dash callbacks.\"\"\" import re import dash from dash.dependencies import Input , Output , State from dash.exceptions import PreventUpdate def format_app_callback ( lookup , outputs , inputs , states ): \"\"\"Format list of [Output, Input, State] for `@app.callback()`. Args: lookup: dict with app_id keys that map to a globally unique component id outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name Returns: list: list[lists] in order `(Outputs, Inputs, States)` for `@app.callback()`. Some sublists may be empty \"\"\" return ( [ Output ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in outputs ], [ Input ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in inputs ], [ State ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in states ], ) def map_args ( raw_args , inputs , states ): \"\"\"Map the function arguments into a dictionary with keys for the input and state names. For situations where the order of inputs and states may change, use this function to verbosely define the inputs: ```python a_in, a_state = map_args(raw_args, inputs, states) click_data = a_in[self.id_main_figure]['clickData'] n_clicks = a_in[self.id_randomize_button]['n_clicks'] data_cache = a_state[self.id_store]['data'] ``` Alternatively, for use cases that are unlikely to change the order of Inputs/State, unwrap positionally with: ```python click_data, n_clicks = args[:len(inputs)] data_cache = args[len(inputs):] ``` Args: raw_args: list of arguments passed to callback inputs: list of input components. May be empty list states: list of state components. May be empty list Returns: dict: with keys of the app_id, property, and arg value (`a_in[key][arg_type]`) \"\"\" # Split args into groups of inputs/states a_in = raw_args [: len ( inputs )] a_state = raw_args [ len ( inputs ):] # Map args into dictionaries arg_map = [{ app_id : [] for app_id in { items [ 0 ] for items in group }} for group in [ inputs , states ]] for group_idx , ( groups , args ) in enumerate ([( inputs , a_in ), ( states , a_state )]): # Assign the arg to the appropriate dictionary in arg_map for arg_idx , ( app_id , prop ) in enumerate ( groups ): arg_map [ group_idx ][ app_id ] . append (( prop , args [ arg_idx ])) for app_id in arg_map [ group_idx ] . keys (): arg_map [ group_idx ][ app_id ] = dict ( arg_map [ group_idx ][ app_id ]) return arg_map def map_outputs ( outputs , element_info ): \"\"\"Return properly ordered list of new Dash elements based on the order of outputs. Alternatively, for simple cases of 1-2 outputs, just return the list with: ```python return [new_element_1, new_element_2] ``` Args: outputs: list of output components element_info: list of tuples with keys `(app_id, prop, element)` Returns: list: ordered list to match the order of outputs Raises: RuntimeError: Check that the number of outputs and the number of element_info match \"\"\" if len ( outputs ) != len ( element_info ): raise RuntimeError ( f 'Expected same number of items between: \\n outputs: { outputs } \\n element_info: { element_info } ' ) # Create a dictionary of the elements lookup = { app_id : [] for app_id in { info [ 0 ] for info in element_info }} for app_id , prop , element in element_info : lookup [ app_id ] . append (( prop , element )) for app_id in lookup : lookup [ app_id ] = dict ( lookup [ app_id ]) return [ lookup [ app_id ][ prop ] for app_id , prop in outputs ] def get_triggered_id (): \"\"\"Use Dash context to get the id of the input element that triggered the callback. See advanced callbacks: https://dash.plotly.com/advanced-callbacks Returns: str: id of the input that triggered the callback Raises: PreventUpdate: if callback was fired without an input \"\"\" ctx = dash . callback_context if not ctx . triggered : raise PreventUpdate prop_id = ctx . triggered [ 0 ][ 'prop_id' ] # in format: `id.key` where we only want the `id` return re . search ( r '(^.+)\\.[^\\.]+$' , prop_id ) . group ( 1 )","title":"dash_charts.utils_callbacks"},{"location":"modules/dash_charts/utils_callbacks/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_callbacks/#format_app_callback","text":"def format_app_callback ( lookup , outputs , inputs , states ) Format list of [Output, Input, State] for @app.callback() . Parameters: Name Description lookup dict with app_id keys that map to a globally unique component id outputs list of tuples with app_id and property name inputs list of tuples with app_id and property name states list of tuples with app_id and property name Returns: Type Description list list[lists] in order (Outputs, Inputs, States) for @app.callback() . Some sublists may be empty View Source def format_app_callback ( lookup , outputs , inputs , states ): \"\"\"Format list of [Output, Input, State] for `@app.callback()`. Args: lookup: dict with app_id keys that map to a globally unique component id outputs: list of tuples with app_id and property name inputs: list of tuples with app_id and property name states: list of tuples with app_id and property name Returns: list: list[lists] in order `(Outputs, Inputs, States)` for `@app.callback()`. Some sublists may be empty \"\"\" return ( [ Output ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in outputs ], [ Input ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in inputs ], [ State ( component_id = lookup [ _id ], component_property = prop ) for _id , prop in states ], )","title":"format_app_callback"},{"location":"modules/dash_charts/utils_callbacks/#get_triggered_id","text":"def get_triggered_id () Use Dash context to get the id of the input element that triggered the callback. See advanced callbacks: https://dash.plotly.com/advanced-callbacks Returns: Type Description str id of the input that triggered the callback Raises: Type Description PreventUpdate if callback was fired without an input View Source def get_triggered_id (): \"\"\"Use Dash context to get the id of the input element that triggered the callback. See advanced callbacks: https://dash.plotly.com/advanced-callbacks Returns: str: id of the input that triggered the callback Raises: PreventUpdate: if callback was fired without an input \"\"\" ctx = dash . callback_context if not ctx . triggered : raise PreventUpdate prop_id = ctx . triggered [ 0 ][ 'prop_id' ] # in format: `id.key` where we only want the `id` return re . search ( r '(^.+)\\.[^\\.]+$' , prop_id ) . group ( 1 )","title":"get_triggered_id"},{"location":"modules/dash_charts/utils_callbacks/#map_args","text":"def map_args ( raw_args , inputs , states ) Map the function arguments into a dictionary with keys for the input and state names. For situations where the order of inputs and states may change, use this function to verbosely define the inputs: a_in , a_state = map_args ( raw_args , inputs , states ) click_data = a_in [ self . id_main_figure ][ 'clickData' ] n_clicks = a_in [ self . id_randomize_button ][ 'n_clicks' ] data_cache = a_state [ self . id_store ][ 'data' ] Alternatively, for use cases that are unlikely to change the order of Inputs/State, unwrap positionally with: click_data , n_clicks = args [: len ( inputs )] data_cache = args [ len ( inputs ):] Parameters: Name Description raw_args list of arguments passed to callback inputs list of input components. May be empty list states list of state components. May be empty list Returns: Type Description dict with keys of the app_id, property, and arg value ( a_in[key][arg_type] ) View Source def map_args ( raw_args , inputs , states ): \"\"\"Map the function arguments into a dictionary with keys for the input and state names. For situations where the order of inputs and states may change, use this function to verbosely define the inputs: ```python a_in, a_state = map_args(raw_args, inputs, states) click_data = a_in[self.id_main_figure]['clickData'] n_clicks = a_in[self.id_randomize_button]['n_clicks'] data_cache = a_state[self.id_store]['data'] ``` Alternatively, for use cases that are unlikely to change the order of Inputs/State, unwrap positionally with: ```python click_data, n_clicks = args[:len(inputs)] data_cache = args[len(inputs):] ``` Args: raw_args: list of arguments passed to callback inputs: list of input components. May be empty list states: list of state components. May be empty list Returns: dict: with keys of the app_id, property, and arg value (`a_in[key][arg_type]`) \"\"\" # Split args into groups of inputs/states a_in = raw_args [: len ( inputs )] a_state = raw_args [ len ( inputs ):] # Map args into dictionaries arg_map = [{ app_id : [] for app_id in { items [ 0 ] for items in group }} for group in [ inputs , states ]] for group_idx , ( groups , args ) in enumerate ([( inputs , a_in ), ( states , a_state )]): # Assign the arg to the appropriate dictionary in arg_map for arg_idx , ( app_id , prop ) in enumerate ( groups ): arg_map [ group_idx ][ app_id ] . append (( prop , args [ arg_idx ])) for app_id in arg_map [ group_idx ] . keys (): arg_map [ group_idx ][ app_id ] = dict ( arg_map [ group_idx ][ app_id ]) return arg_map","title":"map_args"},{"location":"modules/dash_charts/utils_callbacks/#map_outputs","text":"def map_outputs ( outputs , element_info ) Return properly ordered list of new Dash elements based on the order of outputs. Alternatively, for simple cases of 1-2 outputs, just return the list with: return [ new_element_1 , new_element_2 ] Parameters: Name Description outputs list of output components element_info list of tuples with keys (app_id, prop, element) Returns: Type Description list ordered list to match the order of outputs Raises: Type Description RuntimeError Check that the number of outputs and the number of element_info match View Source def map_outputs ( outputs , element_info ): \"\"\"Return properly ordered list of new Dash elements based on the order of outputs. Alternatively, for simple cases of 1-2 outputs, just return the list with: ```python return [new_element_1, new_element_2] ``` Args: outputs: list of output components element_info: list of tuples with keys `(app_id, prop, element)` Returns: list: ordered list to match the order of outputs Raises: RuntimeError: Check that the number of outputs and the number of element_info match \"\"\" if len ( outputs ) != len ( element_info ): raise RuntimeError ( f 'Expected same number of items between: \\n outputs: { outputs } \\n element_info: { element_info } ' ) # Create a dictionary of the elements lookup = { app_id : [] for app_id in { info [ 0 ] for info in element_info }} for app_id , prop , element in element_info : lookup [ app_id ] . append (( prop , element )) for app_id in lookup : lookup [ app_id ] = dict ( lookup [ app_id ]) return [ lookup [ app_id ][ prop ] for app_id , prop in outputs ]","title":"map_outputs"},{"location":"modules/dash_charts/utils_data/","text":"dash_charts.utils_data \u2693\ufe0e Helpers for building Dash applications. View Source \"\"\"Helpers for building Dash applications.\"\"\" import csv import json import sqlite3 import time from contextlib import ContextDecorator from datetime import datetime from pathlib import Path import pandas as pd from cerberus import Validator # ---------------------------------------------------------------------------------------------------------------------- # For Working with Data def enable_verbose_pandas ( max_columns = None , max_rows = None , max_seq_items = None ): \"\"\"Update global pandas configuration for printed dataframes. Args: max_columns: the number of max columns. Default is None (to show all) max_rows: the number of max rows. Default is None (to show all) max_seq_items: the number of max sequence items. Default is None (to show all) # TODO: what does this set? \"\"\" # Enable all columns to be displayed at once (or tweak to set a new limit) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , max_columns ) # Optionally modify number of rows shown pd . set_option ( 'display.max_rows' , max_rows ) if max_seq_items : pd . options ( 'display.max_seq_items' , max_seq_items ) def append_df ( df_old , df_new ): \"\"\"Handle appending a dataframe if the old_df is None. Useful for iteration. Args: df_old: dataframe or None df_new: new dataframe to append. Expects all columns to match Returns: dataframe: combined dataframe \"\"\" return df_new if df_old is None else pd . concat ([ df_old , df_new ]) . reset_index ( drop = True ) def validate ( document , schema , ** validator_kwargs ): \"\"\"Validate a data structure. Return errors if any found. Cerberus Documentation: https://docs.python-cerberus.org/en/stable/validation-rules.html Args: document: data structure to validate schema: expected structure validator_kwargs: additional keyword arguments for Validator class Returns: list: validation errors \"\"\" validator = Validator ( schema , ** validator_kwargs ) validator . validate ( document ) return validator . errors def json_dumps_compact ( data ): # noqa: CCR001 \"\"\"Format provided dictionary into compact JSON. Lists will be in one line rather than split on new lines. Args: data: JSON-serializable dictionary Returns: str: JSON-formatted string with lists compacted into a single line \"\"\" clean_data = {} # Check each key/value pair to determine if any intermediary strings are needed for later formatting for key , raw in data . items (): # PLANNED: Convert to FP and recursive calls? if isinstance ( raw , list ): values = [ f '`` { value } ``' if isinstance ( value , str ) else value for value in raw ] clean_data [ key ] = '[' + ',' . join ( map ( str , values )) + ']' else : clean_data [ key ] = raw # Format the dictionary into JSON and replace the special characters used as intermediaries raw_json = json . dumps ( clean_data , indent = 4 , separators = ( ',' , ': ' ), sort_keys = True ) return ( raw_json . replace ( ': \"[' , ': [' ) . replace ( ']\"' , ']' ) . replace ( '``' , '\"' ) . replace ( \"'\" , '\"' ) ) def write_pretty_json ( filename , obj ): \"\"\"Write indented JSON file. Args: filename: Path or plain string filename to write (should end with `.json`) obj: JSON object to write \"\"\" Path ( filename ) . write_text ( json . dumps ( obj , indent = 4 , separators = ( ',' , ': ' ))) def write_csv ( csv_path , rows ): \"\"\"Write a csv file with appropriate line terminator and encoding. Args: csv_path: path to CSV file rows: list of lists to write to CSV file \"\"\" with open ( csv_path , 'w' , newline = ' \\n ' , encoding = 'utf-8' ) as csv_file : writer = csv . writer ( csv_file , delimiter = ',' , quoting = csv . QUOTE_MINIMAL ) for row in rows : writer . writerow ( row ) # ---------------------------------------------------------------------------------------------------------------------- # Time Helpers US_TIME_FORMAT = '%m/ %d /%Y %H:%M:%S' \"\"\"String time format with month/year (MM/DD/YYYY HH:MM:SS).\"\"\" DASHED_TIME_FORMAT_US = '%m- %d -%Y %H:%M:%S' \"\"\"Dashed time format with month first (MM-DD-YYYY HH:MM:SS).\"\"\" DASHED_TIME_FORMAT_YEAR = '%Y-%m- %d %H:%M:%S' \"\"\"Dashed time format with year first (YYYY-MM-DD HH:MM:SS).\"\"\" TIME_FORMAT_FILE = '%Y-%m- %d _%H%M%S' \"\"\"Filename-safe time format with year first (YYYY-MM-DD_HHMMSS).\"\"\" GDP_TIME_FORMAT = ' %d %b%Y %H:%M:%S' \"\"\"Good Documentation Practice time format (DDMMMYYYY HH:MM:SS).\"\"\" def get_unix ( str_ts , date_format ): \"\"\"Get unix timestamp from a string timestamp in date_format. Args: str_ts: string timestamp in `date_format` date_format: datetime time stamp format Returns: int: unix timestamp \"\"\" return datetime . strptime ( str_ts , date_format ) . timestamp () def format_unix ( unix_ts , date_format ): \"\"\"Format unix timestamp as a string timestamp in date_format. Args: unix_ts: unix timestamp date_format: datetime time stamp format Returns: string: formatted timestamp in `date_format` \"\"\" return datetime . fromtimestamp ( unix_ts ) . strftime ( date_format ) # ---------------------------------------------------------------------------------------------------------------------- # General SQL def uniq_table_id (): \"\"\"Return a unique table ID based on the current time in ms. Returns: str: in format `U<timestamp_ns>` \"\"\" return f 'U { time . time_ns () } ' # ---------------------------------------------------------------------------------------------------------------------- # sqlite3 class SQLConnection ( ContextDecorator ): \"\"\"Ensure the SQLite connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to a SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = sqlite3 . connect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close () def list_sql_tables ( db_path ): \"\"\"Return all table names from the SQL database. Args: db_path: path to SQLite database file Returns: list: of unique table names in the SQL database \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () cursor . execute ( 'SELECT name FROM sqlite_master WHERE TYPE = \"table\"' ) return [ names [ 0 ] for names in cursor . fetchall ()] Variables \u2693\ufe0e DASHED_TIME_FORMAT_US Dashed time format with month first (MM-DD-YYYY HH:MM:SS). DASHED_TIME_FORMAT_YEAR Dashed time format with year first (YYYY-MM-DD HH:MM:SS). GDP_TIME_FORMAT Good Documentation Practice time format (DDMMMYYYY HH:MM:SS). TIME_FORMAT_FILE Filename-safe time format with year first (YYYY-MM-DD_HHMMSS). US_TIME_FORMAT String time format with month/year (MM/DD/YYYY HH:MM:SS). Functions \u2693\ufe0e append_df \u2693\ufe0e def append_df ( df_old , df_new ) Handle appending a dataframe if the old_df is None. Useful for iteration. Parameters: Name Description df_old dataframe or None df_new new dataframe to append. Expects all columns to match Returns: Type Description dataframe combined dataframe View Source def append_df ( df_old , df_new ): \"\"\"Handle appending a dataframe if the old_df is None. Useful for iteration. Args: df_old: dataframe or None df_new: new dataframe to append. Expects all columns to match Returns: dataframe: combined dataframe \"\"\" return df_new if df_old is None else pd . concat ([ df_old , df_new ]) . reset_index ( drop = True ) enable_verbose_pandas \u2693\ufe0e def enable_verbose_pandas ( max_columns = None , max_rows = None , max_seq_items = None ) Update global pandas configuration for printed dataframes. Parameters: Name Description max_columns the number of max columns. Default is None (to show all) max_rows the number of max rows. Default is None (to show all) max_seq_items the number of max sequence items. Default is None (to show all) # TODO: what does this set? View Source def enable_verbose_pandas ( max_columns = None , max_rows = None , max_seq_items = None ): \"\"\"Update global pandas configuration for printed dataframes. Args: max_columns: the number of max columns. Default is None (to show all) max_rows: the number of max rows. Default is None (to show all) max_seq_items: the number of max sequence items. Default is None (to show all) # TODO: what does this set? \"\"\" # Enable all columns to be displayed at once (or tweak to set a new limit) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , max_columns ) # Optionally modify number of rows shown pd . set_option ( 'display.max_rows' , max_rows ) if max_seq_items : pd . options ( 'display.max_seq_items' , max_seq_items ) format_unix \u2693\ufe0e def format_unix ( unix_ts , date_format ) Format unix timestamp as a string timestamp in date_format. Parameters: Name Description unix_ts unix timestamp date_format datetime time stamp format Returns: Type Description string formatted timestamp in date_format View Source def format_unix ( unix_ts , date_format ): \"\"\"Format unix timestamp as a string timestamp in date_format. Args: unix_ts: unix timestamp date_format: datetime time stamp format Returns: string: formatted timestamp in `date_format` \"\"\" return datetime . fromtimestamp ( unix_ts ) . strftime ( date_format ) get_unix \u2693\ufe0e def get_unix ( str_ts , date_format ) Get unix timestamp from a string timestamp in date_format. Parameters: Name Description str_ts string timestamp in date_format date_format datetime time stamp format Returns: Type Description int unix timestamp View Source def get_unix ( str_ts , date_format ): \"\"\"Get unix timestamp from a string timestamp in date_format. Args: str_ts: string timestamp in `date_format` date_format: datetime time stamp format Returns: int: unix timestamp \"\"\" return datetime . strptime ( str_ts , date_format ) . timestamp () json_dumps_compact \u2693\ufe0e def json_dumps_compact ( data ) Format provided dictionary into compact JSON. Lists will be in one line rather than split on new lines. Parameters: Name Description data JSON-serializable dictionary Returns: Type Description str JSON-formatted string with lists compacted into a single line View Source def json_dumps_compact ( data ): # noqa: CCR001 \"\"\"Format provided dictionary into compact JSON. Lists will be in one line rather than split on new lines. Args: data: JSON-serializable dictionary Returns: str: JSON-formatted string with lists compacted into a single line \"\"\" clean_data = {} # Check each key/value pair to determine if any intermediary strings are needed for later formatting for key , raw in data . items (): # PLANNED: Convert to FP and recursive calls? if isinstance ( raw , list ): values = [ f '`` { value } ``' if isinstance ( value , str ) else value for value in raw ] clean_data [ key ] = '[' + ',' . join ( map ( str , values )) + ']' else : clean_data [ key ] = raw # Format the dictionary into JSON and replace the special characters used as intermediaries raw_json = json . dumps ( clean_data , indent = 4 , separators = ( ',' , ': ' ), sort_keys = True ) return ( raw_json . replace ( ': \"[' , ': [' ) . replace ( ']\"' , ']' ) . replace ( '``' , '\"' ) . replace ( \"'\" , '\"' ) ) list_sql_tables \u2693\ufe0e def list_sql_tables ( db_path ) Return all table names from the SQL database. Parameters: Name Description db_path path to SQLite database file Returns: Type Description list of unique table names in the SQL database View Source def list_sql_tables ( db_path ): \"\"\"Return all table names from the SQL database. Args: db_path: path to SQLite database file Returns: list: of unique table names in the SQL database \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () cursor . execute ( 'SELECT name FROM sqlite_master WHERE TYPE = \"table\"' ) return [ names [ 0 ] for names in cursor . fetchall ()] uniq_table_id \u2693\ufe0e def uniq_table_id () Return a unique table ID based on the current time in ms. Returns: Type Description str in format U<timestamp_ns> View Source def uniq_table_id (): \"\"\"Return a unique table ID based on the current time in ms. Returns: str: in format `U<timestamp_ns>` \"\"\" return f 'U { time . time_ns () } ' validate \u2693\ufe0e def validate ( document , schema , ** validator_kwargs ) Validate a data structure. Return errors if any found. Cerberus Documentation: https://docs.python-cerberus.org/en/stable/validation-rules.html Parameters: Name Description document data structure to validate schema expected structure validator_kwargs additional keyword arguments for Validator class Returns: Type Description list validation errors View Source def validate ( document , schema , ** validator_kwargs ): \"\"\"Validate a data structure. Return errors if any found. Cerberus Documentation: https://docs.python-cerberus.org/en/stable/validation-rules.html Args: document: data structure to validate schema: expected structure validator_kwargs: additional keyword arguments for Validator class Returns: list: validation errors \"\"\" validator = Validator ( schema , ** validator_kwargs ) validator . validate ( document ) return validator . errors write_csv \u2693\ufe0e def write_csv ( csv_path , rows ) Write a csv file with appropriate line terminator and encoding. Parameters: Name Description csv_path path to CSV file rows list of lists to write to CSV file View Source def write_csv ( csv_path , rows ): \"\"\"Write a csv file with appropriate line terminator and encoding. Args: csv_path: path to CSV file rows: list of lists to write to CSV file \"\"\" with open ( csv_path , 'w' , newline = ' \\n ' , encoding = 'utf-8' ) as csv_file : writer = csv . writer ( csv_file , delimiter = ',' , quoting = csv . QUOTE_MINIMAL ) for row in rows : writer . writerow ( row ) write_pretty_json \u2693\ufe0e def write_pretty_json ( filename , obj ) Write indented JSON file. Parameters: Name Description filename Path or plain string filename to write (should end with .json ) obj JSON object to write View Source def write_pretty_json ( filename , obj ): \"\"\"Write indented JSON file. Args: filename: Path or plain string filename to write (should end with `.json`) obj: JSON object to write \"\"\" Path ( filename ) . write_text ( json . dumps ( obj , indent = 4 , separators = ( ',' , ': ' ))) Classes \u2693\ufe0e SQLConnection \u2693\ufe0e class SQLConnection ( db_path ) View Source class SQLConnection ( ContextDecorator ): \"\"\"Ensure the SQLite connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to a SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = sqlite3 . connect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close () Ancestors (in MRO) \u2693\ufe0e contextlib.ContextDecorator","title":"dash_charts.utils_data"},{"location":"modules/dash_charts/utils_data/#dash_chartsutils_data","text":"Helpers for building Dash applications. View Source \"\"\"Helpers for building Dash applications.\"\"\" import csv import json import sqlite3 import time from contextlib import ContextDecorator from datetime import datetime from pathlib import Path import pandas as pd from cerberus import Validator # ---------------------------------------------------------------------------------------------------------------------- # For Working with Data def enable_verbose_pandas ( max_columns = None , max_rows = None , max_seq_items = None ): \"\"\"Update global pandas configuration for printed dataframes. Args: max_columns: the number of max columns. Default is None (to show all) max_rows: the number of max rows. Default is None (to show all) max_seq_items: the number of max sequence items. Default is None (to show all) # TODO: what does this set? \"\"\" # Enable all columns to be displayed at once (or tweak to set a new limit) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , max_columns ) # Optionally modify number of rows shown pd . set_option ( 'display.max_rows' , max_rows ) if max_seq_items : pd . options ( 'display.max_seq_items' , max_seq_items ) def append_df ( df_old , df_new ): \"\"\"Handle appending a dataframe if the old_df is None. Useful for iteration. Args: df_old: dataframe or None df_new: new dataframe to append. Expects all columns to match Returns: dataframe: combined dataframe \"\"\" return df_new if df_old is None else pd . concat ([ df_old , df_new ]) . reset_index ( drop = True ) def validate ( document , schema , ** validator_kwargs ): \"\"\"Validate a data structure. Return errors if any found. Cerberus Documentation: https://docs.python-cerberus.org/en/stable/validation-rules.html Args: document: data structure to validate schema: expected structure validator_kwargs: additional keyword arguments for Validator class Returns: list: validation errors \"\"\" validator = Validator ( schema , ** validator_kwargs ) validator . validate ( document ) return validator . errors def json_dumps_compact ( data ): # noqa: CCR001 \"\"\"Format provided dictionary into compact JSON. Lists will be in one line rather than split on new lines. Args: data: JSON-serializable dictionary Returns: str: JSON-formatted string with lists compacted into a single line \"\"\" clean_data = {} # Check each key/value pair to determine if any intermediary strings are needed for later formatting for key , raw in data . items (): # PLANNED: Convert to FP and recursive calls? if isinstance ( raw , list ): values = [ f '`` { value } ``' if isinstance ( value , str ) else value for value in raw ] clean_data [ key ] = '[' + ',' . join ( map ( str , values )) + ']' else : clean_data [ key ] = raw # Format the dictionary into JSON and replace the special characters used as intermediaries raw_json = json . dumps ( clean_data , indent = 4 , separators = ( ',' , ': ' ), sort_keys = True ) return ( raw_json . replace ( ': \"[' , ': [' ) . replace ( ']\"' , ']' ) . replace ( '``' , '\"' ) . replace ( \"'\" , '\"' ) ) def write_pretty_json ( filename , obj ): \"\"\"Write indented JSON file. Args: filename: Path or plain string filename to write (should end with `.json`) obj: JSON object to write \"\"\" Path ( filename ) . write_text ( json . dumps ( obj , indent = 4 , separators = ( ',' , ': ' ))) def write_csv ( csv_path , rows ): \"\"\"Write a csv file with appropriate line terminator and encoding. Args: csv_path: path to CSV file rows: list of lists to write to CSV file \"\"\" with open ( csv_path , 'w' , newline = ' \\n ' , encoding = 'utf-8' ) as csv_file : writer = csv . writer ( csv_file , delimiter = ',' , quoting = csv . QUOTE_MINIMAL ) for row in rows : writer . writerow ( row ) # ---------------------------------------------------------------------------------------------------------------------- # Time Helpers US_TIME_FORMAT = '%m/ %d /%Y %H:%M:%S' \"\"\"String time format with month/year (MM/DD/YYYY HH:MM:SS).\"\"\" DASHED_TIME_FORMAT_US = '%m- %d -%Y %H:%M:%S' \"\"\"Dashed time format with month first (MM-DD-YYYY HH:MM:SS).\"\"\" DASHED_TIME_FORMAT_YEAR = '%Y-%m- %d %H:%M:%S' \"\"\"Dashed time format with year first (YYYY-MM-DD HH:MM:SS).\"\"\" TIME_FORMAT_FILE = '%Y-%m- %d _%H%M%S' \"\"\"Filename-safe time format with year first (YYYY-MM-DD_HHMMSS).\"\"\" GDP_TIME_FORMAT = ' %d %b%Y %H:%M:%S' \"\"\"Good Documentation Practice time format (DDMMMYYYY HH:MM:SS).\"\"\" def get_unix ( str_ts , date_format ): \"\"\"Get unix timestamp from a string timestamp in date_format. Args: str_ts: string timestamp in `date_format` date_format: datetime time stamp format Returns: int: unix timestamp \"\"\" return datetime . strptime ( str_ts , date_format ) . timestamp () def format_unix ( unix_ts , date_format ): \"\"\"Format unix timestamp as a string timestamp in date_format. Args: unix_ts: unix timestamp date_format: datetime time stamp format Returns: string: formatted timestamp in `date_format` \"\"\" return datetime . fromtimestamp ( unix_ts ) . strftime ( date_format ) # ---------------------------------------------------------------------------------------------------------------------- # General SQL def uniq_table_id (): \"\"\"Return a unique table ID based on the current time in ms. Returns: str: in format `U<timestamp_ns>` \"\"\" return f 'U { time . time_ns () } ' # ---------------------------------------------------------------------------------------------------------------------- # sqlite3 class SQLConnection ( ContextDecorator ): \"\"\"Ensure the SQLite connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to a SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = sqlite3 . connect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close () def list_sql_tables ( db_path ): \"\"\"Return all table names from the SQL database. Args: db_path: path to SQLite database file Returns: list: of unique table names in the SQL database \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () cursor . execute ( 'SELECT name FROM sqlite_master WHERE TYPE = \"table\"' ) return [ names [ 0 ] for names in cursor . fetchall ()]","title":"dash_charts.utils_data"},{"location":"modules/dash_charts/utils_data/#variables","text":"DASHED_TIME_FORMAT_US Dashed time format with month first (MM-DD-YYYY HH:MM:SS). DASHED_TIME_FORMAT_YEAR Dashed time format with year first (YYYY-MM-DD HH:MM:SS). GDP_TIME_FORMAT Good Documentation Practice time format (DDMMMYYYY HH:MM:SS). TIME_FORMAT_FILE Filename-safe time format with year first (YYYY-MM-DD_HHMMSS). US_TIME_FORMAT String time format with month/year (MM/DD/YYYY HH:MM:SS).","title":"Variables"},{"location":"modules/dash_charts/utils_data/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_data/#append_df","text":"def append_df ( df_old , df_new ) Handle appending a dataframe if the old_df is None. Useful for iteration. Parameters: Name Description df_old dataframe or None df_new new dataframe to append. Expects all columns to match Returns: Type Description dataframe combined dataframe View Source def append_df ( df_old , df_new ): \"\"\"Handle appending a dataframe if the old_df is None. Useful for iteration. Args: df_old: dataframe or None df_new: new dataframe to append. Expects all columns to match Returns: dataframe: combined dataframe \"\"\" return df_new if df_old is None else pd . concat ([ df_old , df_new ]) . reset_index ( drop = True )","title":"append_df"},{"location":"modules/dash_charts/utils_data/#enable_verbose_pandas","text":"def enable_verbose_pandas ( max_columns = None , max_rows = None , max_seq_items = None ) Update global pandas configuration for printed dataframes. Parameters: Name Description max_columns the number of max columns. Default is None (to show all) max_rows the number of max rows. Default is None (to show all) max_seq_items the number of max sequence items. Default is None (to show all) # TODO: what does this set? View Source def enable_verbose_pandas ( max_columns = None , max_rows = None , max_seq_items = None ): \"\"\"Update global pandas configuration for printed dataframes. Args: max_columns: the number of max columns. Default is None (to show all) max_rows: the number of max rows. Default is None (to show all) max_seq_items: the number of max sequence items. Default is None (to show all) # TODO: what does this set? \"\"\" # Enable all columns to be displayed at once (or tweak to set a new limit) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , max_columns ) # Optionally modify number of rows shown pd . set_option ( 'display.max_rows' , max_rows ) if max_seq_items : pd . options ( 'display.max_seq_items' , max_seq_items )","title":"enable_verbose_pandas"},{"location":"modules/dash_charts/utils_data/#format_unix","text":"def format_unix ( unix_ts , date_format ) Format unix timestamp as a string timestamp in date_format. Parameters: Name Description unix_ts unix timestamp date_format datetime time stamp format Returns: Type Description string formatted timestamp in date_format View Source def format_unix ( unix_ts , date_format ): \"\"\"Format unix timestamp as a string timestamp in date_format. Args: unix_ts: unix timestamp date_format: datetime time stamp format Returns: string: formatted timestamp in `date_format` \"\"\" return datetime . fromtimestamp ( unix_ts ) . strftime ( date_format )","title":"format_unix"},{"location":"modules/dash_charts/utils_data/#get_unix","text":"def get_unix ( str_ts , date_format ) Get unix timestamp from a string timestamp in date_format. Parameters: Name Description str_ts string timestamp in date_format date_format datetime time stamp format Returns: Type Description int unix timestamp View Source def get_unix ( str_ts , date_format ): \"\"\"Get unix timestamp from a string timestamp in date_format. Args: str_ts: string timestamp in `date_format` date_format: datetime time stamp format Returns: int: unix timestamp \"\"\" return datetime . strptime ( str_ts , date_format ) . timestamp ()","title":"get_unix"},{"location":"modules/dash_charts/utils_data/#json_dumps_compact","text":"def json_dumps_compact ( data ) Format provided dictionary into compact JSON. Lists will be in one line rather than split on new lines. Parameters: Name Description data JSON-serializable dictionary Returns: Type Description str JSON-formatted string with lists compacted into a single line View Source def json_dumps_compact ( data ): # noqa: CCR001 \"\"\"Format provided dictionary into compact JSON. Lists will be in one line rather than split on new lines. Args: data: JSON-serializable dictionary Returns: str: JSON-formatted string with lists compacted into a single line \"\"\" clean_data = {} # Check each key/value pair to determine if any intermediary strings are needed for later formatting for key , raw in data . items (): # PLANNED: Convert to FP and recursive calls? if isinstance ( raw , list ): values = [ f '`` { value } ``' if isinstance ( value , str ) else value for value in raw ] clean_data [ key ] = '[' + ',' . join ( map ( str , values )) + ']' else : clean_data [ key ] = raw # Format the dictionary into JSON and replace the special characters used as intermediaries raw_json = json . dumps ( clean_data , indent = 4 , separators = ( ',' , ': ' ), sort_keys = True ) return ( raw_json . replace ( ': \"[' , ': [' ) . replace ( ']\"' , ']' ) . replace ( '``' , '\"' ) . replace ( \"'\" , '\"' ) )","title":"json_dumps_compact"},{"location":"modules/dash_charts/utils_data/#list_sql_tables","text":"def list_sql_tables ( db_path ) Return all table names from the SQL database. Parameters: Name Description db_path path to SQLite database file Returns: Type Description list of unique table names in the SQL database View Source def list_sql_tables ( db_path ): \"\"\"Return all table names from the SQL database. Args: db_path: path to SQLite database file Returns: list: of unique table names in the SQL database \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () cursor . execute ( 'SELECT name FROM sqlite_master WHERE TYPE = \"table\"' ) return [ names [ 0 ] for names in cursor . fetchall ()]","title":"list_sql_tables"},{"location":"modules/dash_charts/utils_data/#uniq_table_id","text":"def uniq_table_id () Return a unique table ID based on the current time in ms. Returns: Type Description str in format U<timestamp_ns> View Source def uniq_table_id (): \"\"\"Return a unique table ID based on the current time in ms. Returns: str: in format `U<timestamp_ns>` \"\"\" return f 'U { time . time_ns () } '","title":"uniq_table_id"},{"location":"modules/dash_charts/utils_data/#validate","text":"def validate ( document , schema , ** validator_kwargs ) Validate a data structure. Return errors if any found. Cerberus Documentation: https://docs.python-cerberus.org/en/stable/validation-rules.html Parameters: Name Description document data structure to validate schema expected structure validator_kwargs additional keyword arguments for Validator class Returns: Type Description list validation errors View Source def validate ( document , schema , ** validator_kwargs ): \"\"\"Validate a data structure. Return errors if any found. Cerberus Documentation: https://docs.python-cerberus.org/en/stable/validation-rules.html Args: document: data structure to validate schema: expected structure validator_kwargs: additional keyword arguments for Validator class Returns: list: validation errors \"\"\" validator = Validator ( schema , ** validator_kwargs ) validator . validate ( document ) return validator . errors","title":"validate"},{"location":"modules/dash_charts/utils_data/#write_csv","text":"def write_csv ( csv_path , rows ) Write a csv file with appropriate line terminator and encoding. Parameters: Name Description csv_path path to CSV file rows list of lists to write to CSV file View Source def write_csv ( csv_path , rows ): \"\"\"Write a csv file with appropriate line terminator and encoding. Args: csv_path: path to CSV file rows: list of lists to write to CSV file \"\"\" with open ( csv_path , 'w' , newline = ' \\n ' , encoding = 'utf-8' ) as csv_file : writer = csv . writer ( csv_file , delimiter = ',' , quoting = csv . QUOTE_MINIMAL ) for row in rows : writer . writerow ( row )","title":"write_csv"},{"location":"modules/dash_charts/utils_data/#write_pretty_json","text":"def write_pretty_json ( filename , obj ) Write indented JSON file. Parameters: Name Description filename Path or plain string filename to write (should end with .json ) obj JSON object to write View Source def write_pretty_json ( filename , obj ): \"\"\"Write indented JSON file. Args: filename: Path or plain string filename to write (should end with `.json`) obj: JSON object to write \"\"\" Path ( filename ) . write_text ( json . dumps ( obj , indent = 4 , separators = ( ',' , ': ' )))","title":"write_pretty_json"},{"location":"modules/dash_charts/utils_data/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/utils_data/#sqlconnection","text":"class SQLConnection ( db_path ) View Source class SQLConnection ( ContextDecorator ): \"\"\"Ensure the SQLite connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to a SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = sqlite3 . connect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close ()","title":"SQLConnection"},{"location":"modules/dash_charts/utils_data/#ancestors-in-mro","text":"contextlib.ContextDecorator","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_dataset/","text":"dash_charts.utils_dataset \u2693\ufe0e Helpers for building Dash applications. View Source \"\"\"Helpers for building Dash applications.\"\"\" from contextlib import ContextDecorator import dataset import pandas as pd from .utils_data import SQLConnection , uniq_table_id , write_csv # ---------------------------------------------------------------------------------------------------------------------- # dataset META_TABLE_NAME = 'meta' \"\"\"Name of the Meta-Data table in a typical SQLite database.\"\"\" class DBConnect : # noqa: H601 \"\"\"Manage database connection since closing connection isn't possible.\"\"\" db_path = None \"\"\"Path to the local storage SQLite database file. Initialize in `__init__()`.\"\"\" _db = None @property def db ( self ): \"\"\"Return connection to database. Will create new connection if one does not exist already. Returns: dict: `dataset` database instance \"\"\" if self . _db is None : self . _db = dataset . connect ( f 'sqlite:/// { self . db_path } ' ) return self . _db def __init__ ( self , db_path ): \"\"\"Store the database path and ensure the parent directory exists. Args: db_path: Path to the SQLite file \"\"\" self . db_path = db_path . resolve () self . db_path . parent . mkdir ( exist_ok = True ) self . db # Check initial connection def new_table ( self , table_name ): \"\"\"Create a table. Drop a table if one existed before. Args: table_name: string table name to create Returns: table: a dataset Table instance \"\"\" if table_name in self . db . tables : self . db [ table_name ] . drop () return self . db . create_table ( table_name ) def close ( self ): \"\"\"Safely disconnect and release the SQLite file.\"\"\" self . db . executable . close () self . _db = None class DBConnection ( ContextDecorator ): \"\"\"Ensure the DBConnect connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to the SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = DBConnect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close () def export_table_as_csv ( csv_filename , table ): \"\"\"Create a CSV file summarizing a table of a `dataset` database. Args: csv_filename: Path to csv file table: table from dataset database \"\"\" rows = [[ * table . columns ]] rows . extend ([ * row . values ()] for row in table ) write_csv ( csv_filename , rows ) def safe_col_name ( args_pair ): \"\"\"Ensure that the column name is safe for SQL (unique value, no spaces, no trailing punctuation). Typically called with `df.columns = [*map(safe_col_name, enumerate(df.columns.to_list()))]` Args: args_pair: tuple of arguments from map function in `(idx, col)` Returns: string: safely formatted string for SQLite \"\"\" idx , col = args_pair col = col . strip () . replace ( ' ' , '_' ) . replace ( '.' , '_' ) . replace ( ',' , '_' ) return str ( idx ) if col == '' else col def store_reference_tables ( db_path , data_dicts , meta_table_name = META_TABLE_NAME , use_raw_sql = True ): # noqa: CCR001 \"\"\"Store multi-dimensionsal data in a SQLite database. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file data_dicts: all data to be stored in SQLite. Can contain Pandas dataframes meta_table_name: optional name of the main SQLite table. Default is `META_TABLE_NAME` use_raw_sql: if True, will use the raw SQL connection rather than DataSet. This is faster for meta_tables that have more than 1000 rows, but less safe \"\"\" with SQLConnection ( db_path ) as conn : meta_table = [] unique = uniq_table_id () for dict_idx , data_dict in enumerate ( data_dicts ): lookup = {} for key_idx , ( key , value ) in enumerate ( data_dict . items ()): if isinstance ( value , pd . DataFrame ): value . columns = [ * map ( safe_col_name , enumerate ( value . columns . to_list ()))] table_name = f ' { unique } Dict { dict_idx } Key { key_idx } ' value . to_sql ( table_name , con = conn ) lookup [ key ] = table_name else : lookup [ key ] = value meta_table . append ( lookup ) if use_raw_sql : add_meta_table_records_sql ( db_path , meta_table , meta_table_name ) else : with DBConnection ( db_path ) as data_db : table_main = data_db . db . create_table ( meta_table_name ) table_main . insert_many ( meta_table ) def add_meta_table_records_sql ( db_path , meta_table , meta_table_name ): \"\"\"Store new rows for the meta table using a more performant SQLite implementation. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file meta_table: list of dictionaries to add to the meta_table meta_table_name: optional name of the main SQLite table \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () keys = [ * meta_table [ 0 ] . keys ()] names_formatted = ',' . join ( map ( safe_col_name , enumerate ( keys ))) cursor . execute ( f 'CREATE TABLE IF NOT EXISTS { meta_table_name } ( { names_formatted } );' ) rows = [[ row [ col ] for col in keys ] for row in meta_table ] places = ',' . join ([ '?' ] * len ( keys )) cursor . executemany ( f 'INSERT INTO { meta_table_name } ( { names_formatted } ) VALUES ( { places } );' , rows ) conn . commit () def get_table ( db_path , table_name , drop_id_col = True ): \"\"\"Retrieve the meta table as a Pandas dataframe. Args: db_path: Path to a `.db` file table_name: SQLite table name drop_id_col: if True, drop the `id` column from SQL. Default is True Returns: df_table: pandas dataframe for the values in the specified table (`meta_table_name`) \"\"\" with DBConnection ( db_path ) as data_db : df_table = pd . DataFrame ([ * data_db . db [ table_name ] . all ()]) # Optionally remove the 'id' column added in the SQL database if drop_id_col : df_table = df_table . drop ( labels = [ 'id' , 'index' ], axis = 1 , errors = 'ignore' ) return df_table # noqa: R504 Variables \u2693\ufe0e META_TABLE_NAME Name of the Meta-Data table in a typical SQLite database. Functions \u2693\ufe0e add_meta_table_records_sql \u2693\ufe0e def add_meta_table_records_sql ( db_path , meta_table , meta_table_name ) Store new rows for the meta table using a more performant SQLite implementation. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Parameters: Name Description db_path Path to a .db file meta_table list of dictionaries to add to the meta_table meta_table_name optional name of the main SQLite table View Source def add_meta_table_records_sql ( db_path , meta_table , meta_table_name ): \"\"\"Store new rows for the meta table using a more performant SQLite implementation. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file meta_table: list of dictionaries to add to the meta_table meta_table_name: optional name of the main SQLite table \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () keys = [ * meta_table [ 0 ] . keys ()] names_formatted = ',' . join ( map ( safe_col_name , enumerate ( keys ))) cursor . execute ( f 'CREATE TABLE IF NOT EXISTS { meta_table_name } ( { names_formatted } );' ) rows = [[ row [ col ] for col in keys ] for row in meta_table ] places = ',' . join ([ '?' ] * len ( keys )) cursor . executemany ( f 'INSERT INTO { meta_table_name } ( { names_formatted } ) VALUES ( { places } );' , rows ) conn . commit () export_table_as_csv \u2693\ufe0e def export_table_as_csv ( csv_filename , table ) Create a CSV file summarizing a table of a dataset database. Parameters: Name Description csv_filename Path to csv file table table from dataset database View Source def export_table_as_csv ( csv_filename , table ): \"\"\"Create a CSV file summarizing a table of a `dataset` database. Args: csv_filename: Path to csv file table: table from dataset database \"\"\" rows = [[ * table . columns ]] rows . extend ([ * row . values ()] for row in table ) write_csv ( csv_filename , rows ) get_table \u2693\ufe0e def get_table ( db_path , table_name , drop_id_col = True ) Retrieve the meta table as a Pandas dataframe. Parameters: Name Description db_path Path to a .db file table_name SQLite table name drop_id_col if True, drop the id column from SQL. Default is True Returns: Type Description df_table pandas dataframe for the values in the specified table ( meta_table_name ) View Source def get_table ( db_path , table_name , drop_id_col = True ): \"\"\"Retrieve the meta table as a Pandas dataframe. Args: db_path: Path to a `.db` file table_name: SQLite table name drop_id_col: if True, drop the `id` column from SQL. Default is True Returns: df_table: pandas dataframe for the values in the specified table (`meta_table_name`) \"\"\" with DBConnection ( db_path ) as data_db : df_table = pd . DataFrame ([ * data_db . db [ table_name ] . all ()]) # Optionally remove the 'id' column added in the SQL database if drop_id_col : df_table = df_table . drop ( labels = [ 'id' , 'index' ], axis = 1 , errors = 'ignore' ) return df_table # noqa: R504 safe_col_name \u2693\ufe0e def safe_col_name ( args_pair ) Ensure that the column name is safe for SQL (unique value, no spaces, no trailing punctuation). Typically called with df.columns = [*map(safe_col_name, enumerate(df.columns.to_list()))] Parameters: Name Description args_pair tuple of arguments from map function in (idx, col) Returns: Type Description string safely formatted string for SQLite View Source def safe_col_name ( args_pair ): \"\"\"Ensure that the column name is safe for SQL (unique value, no spaces, no trailing punctuation). Typically called with `df.columns = [*map(safe_col_name, enumerate(df.columns.to_list()))]` Args: args_pair: tuple of arguments from map function in `(idx, col)` Returns: string: safely formatted string for SQLite \"\"\" idx , col = args_pair col = col . strip () . replace ( ' ' , '_' ) . replace ( '.' , '_' ) . replace ( ',' , '_' ) return str ( idx ) if col == '' else col store_reference_tables \u2693\ufe0e def store_reference_tables ( db_path , data_dicts , meta_table_name = 'meta' , use_raw_sql = True ) Store multi-dimensionsal data in a SQLite database. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Parameters: Name Description db_path Path to a .db file data_dicts all data to be stored in SQLite. Can contain Pandas dataframes meta_table_name optional name of the main SQLite table. Default is META_TABLE_NAME use_raw_sql if True, will use the raw SQL connection rather than DataSet. This is faster for meta_tables that have more than 1000 rows, but less safe View Source def store_reference_tables ( db_path , data_dicts , meta_table_name = META_TABLE_NAME , use_raw_sql = True ): # noqa: CCR001 \"\"\"Store multi-dimensionsal data in a SQLite database. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file data_dicts: all data to be stored in SQLite. Can contain Pandas dataframes meta_table_name: optional name of the main SQLite table. Default is `META_TABLE_NAME` use_raw_sql: if True, will use the raw SQL connection rather than DataSet. This is faster for meta_tables that have more than 1000 rows, but less safe \"\"\" with SQLConnection ( db_path ) as conn : meta_table = [] unique = uniq_table_id () for dict_idx , data_dict in enumerate ( data_dicts ): lookup = {} for key_idx , ( key , value ) in enumerate ( data_dict . items ()): if isinstance ( value , pd . DataFrame ): value . columns = [ * map ( safe_col_name , enumerate ( value . columns . to_list ()))] table_name = f ' { unique } Dict { dict_idx } Key { key_idx } ' value . to_sql ( table_name , con = conn ) lookup [ key ] = table_name else : lookup [ key ] = value meta_table . append ( lookup ) if use_raw_sql : add_meta_table_records_sql ( db_path , meta_table , meta_table_name ) else : with DBConnection ( db_path ) as data_db : table_main = data_db . db . create_table ( meta_table_name ) table_main . insert_many ( meta_table ) Classes \u2693\ufe0e DBConnect \u2693\ufe0e class DBConnect ( db_path ) View Source class DBConnect : # noqa: H601 \"\"\"Manage database connection since closing connection isn't possible.\"\"\" db_path = None \"\"\"Path to the local storage SQLite database file. Initialize in `__init__()`.\"\"\" _db = None @property def db ( self ): \"\"\"Return connection to database. Will create new connection if one does not exist already. Returns: dict: `dataset` database instance \"\"\" if self . _db is None : self . _db = dataset . connect ( f 'sqlite:/// { self . db_path } ' ) return self . _db def __init__ ( self , db_path ): \"\"\"Store the database path and ensure the parent directory exists. Args: db_path: Path to the SQLite file \"\"\" self . db_path = db_path . resolve () self . db_path . parent . mkdir ( exist_ok = True ) self . db # Check initial connection def new_table ( self , table_name ): \"\"\"Create a table. Drop a table if one existed before. Args: table_name: string table name to create Returns: table: a dataset Table instance \"\"\" if table_name in self . db . tables : self . db [ table_name ] . drop () return self . db . create_table ( table_name ) def close ( self ): \"\"\"Safely disconnect and release the SQLite file.\"\"\" self . db . executable . close () self . _db = None Class variables \u2693\ufe0e db_path Path to the local storage SQLite database file. Initialize in __init__() . Instance variables \u2693\ufe0e db Return connection to database. Will create new connection if one does not exist already. Methods \u2693\ufe0e close \u2693\ufe0e def close ( self ) Safely disconnect and release the SQLite file. View Source def close ( self ): \"\"\"Safely disconnect and release the SQLite file.\"\"\" self . db . executable . close () self . _db = None new_table \u2693\ufe0e def new_table ( self , table_name ) Create a table. Drop a table if one existed before. Parameters: Name Description table_name string table name to create Returns: Type Description table a dataset Table instance View Source def new_table ( self , table_name ): \"\"\"Create a table. Drop a table if one existed before. Args: table_name: string table name to create Returns: table: a dataset Table instance \"\"\" if table_name in self . db . tables : self . db [ table_name ] . drop () return self . db . create_table ( table_name ) DBConnection \u2693\ufe0e class DBConnection ( db_path ) View Source class DBConnection ( ContextDecorator ): \"\"\"Ensure the DBConnect connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to the SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = DBConnect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close () Ancestors (in MRO) \u2693\ufe0e contextlib.ContextDecorator","title":"dash_charts.utils_dataset"},{"location":"modules/dash_charts/utils_dataset/#dash_chartsutils_dataset","text":"Helpers for building Dash applications. View Source \"\"\"Helpers for building Dash applications.\"\"\" from contextlib import ContextDecorator import dataset import pandas as pd from .utils_data import SQLConnection , uniq_table_id , write_csv # ---------------------------------------------------------------------------------------------------------------------- # dataset META_TABLE_NAME = 'meta' \"\"\"Name of the Meta-Data table in a typical SQLite database.\"\"\" class DBConnect : # noqa: H601 \"\"\"Manage database connection since closing connection isn't possible.\"\"\" db_path = None \"\"\"Path to the local storage SQLite database file. Initialize in `__init__()`.\"\"\" _db = None @property def db ( self ): \"\"\"Return connection to database. Will create new connection if one does not exist already. Returns: dict: `dataset` database instance \"\"\" if self . _db is None : self . _db = dataset . connect ( f 'sqlite:/// { self . db_path } ' ) return self . _db def __init__ ( self , db_path ): \"\"\"Store the database path and ensure the parent directory exists. Args: db_path: Path to the SQLite file \"\"\" self . db_path = db_path . resolve () self . db_path . parent . mkdir ( exist_ok = True ) self . db # Check initial connection def new_table ( self , table_name ): \"\"\"Create a table. Drop a table if one existed before. Args: table_name: string table name to create Returns: table: a dataset Table instance \"\"\" if table_name in self . db . tables : self . db [ table_name ] . drop () return self . db . create_table ( table_name ) def close ( self ): \"\"\"Safely disconnect and release the SQLite file.\"\"\" self . db . executable . close () self . _db = None class DBConnection ( ContextDecorator ): \"\"\"Ensure the DBConnect connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to the SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = DBConnect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close () def export_table_as_csv ( csv_filename , table ): \"\"\"Create a CSV file summarizing a table of a `dataset` database. Args: csv_filename: Path to csv file table: table from dataset database \"\"\" rows = [[ * table . columns ]] rows . extend ([ * row . values ()] for row in table ) write_csv ( csv_filename , rows ) def safe_col_name ( args_pair ): \"\"\"Ensure that the column name is safe for SQL (unique value, no spaces, no trailing punctuation). Typically called with `df.columns = [*map(safe_col_name, enumerate(df.columns.to_list()))]` Args: args_pair: tuple of arguments from map function in `(idx, col)` Returns: string: safely formatted string for SQLite \"\"\" idx , col = args_pair col = col . strip () . replace ( ' ' , '_' ) . replace ( '.' , '_' ) . replace ( ',' , '_' ) return str ( idx ) if col == '' else col def store_reference_tables ( db_path , data_dicts , meta_table_name = META_TABLE_NAME , use_raw_sql = True ): # noqa: CCR001 \"\"\"Store multi-dimensionsal data in a SQLite database. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file data_dicts: all data to be stored in SQLite. Can contain Pandas dataframes meta_table_name: optional name of the main SQLite table. Default is `META_TABLE_NAME` use_raw_sql: if True, will use the raw SQL connection rather than DataSet. This is faster for meta_tables that have more than 1000 rows, but less safe \"\"\" with SQLConnection ( db_path ) as conn : meta_table = [] unique = uniq_table_id () for dict_idx , data_dict in enumerate ( data_dicts ): lookup = {} for key_idx , ( key , value ) in enumerate ( data_dict . items ()): if isinstance ( value , pd . DataFrame ): value . columns = [ * map ( safe_col_name , enumerate ( value . columns . to_list ()))] table_name = f ' { unique } Dict { dict_idx } Key { key_idx } ' value . to_sql ( table_name , con = conn ) lookup [ key ] = table_name else : lookup [ key ] = value meta_table . append ( lookup ) if use_raw_sql : add_meta_table_records_sql ( db_path , meta_table , meta_table_name ) else : with DBConnection ( db_path ) as data_db : table_main = data_db . db . create_table ( meta_table_name ) table_main . insert_many ( meta_table ) def add_meta_table_records_sql ( db_path , meta_table , meta_table_name ): \"\"\"Store new rows for the meta table using a more performant SQLite implementation. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file meta_table: list of dictionaries to add to the meta_table meta_table_name: optional name of the main SQLite table \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () keys = [ * meta_table [ 0 ] . keys ()] names_formatted = ',' . join ( map ( safe_col_name , enumerate ( keys ))) cursor . execute ( f 'CREATE TABLE IF NOT EXISTS { meta_table_name } ( { names_formatted } );' ) rows = [[ row [ col ] for col in keys ] for row in meta_table ] places = ',' . join ([ '?' ] * len ( keys )) cursor . executemany ( f 'INSERT INTO { meta_table_name } ( { names_formatted } ) VALUES ( { places } );' , rows ) conn . commit () def get_table ( db_path , table_name , drop_id_col = True ): \"\"\"Retrieve the meta table as a Pandas dataframe. Args: db_path: Path to a `.db` file table_name: SQLite table name drop_id_col: if True, drop the `id` column from SQL. Default is True Returns: df_table: pandas dataframe for the values in the specified table (`meta_table_name`) \"\"\" with DBConnection ( db_path ) as data_db : df_table = pd . DataFrame ([ * data_db . db [ table_name ] . all ()]) # Optionally remove the 'id' column added in the SQL database if drop_id_col : df_table = df_table . drop ( labels = [ 'id' , 'index' ], axis = 1 , errors = 'ignore' ) return df_table # noqa: R504","title":"dash_charts.utils_dataset"},{"location":"modules/dash_charts/utils_dataset/#variables","text":"META_TABLE_NAME Name of the Meta-Data table in a typical SQLite database.","title":"Variables"},{"location":"modules/dash_charts/utils_dataset/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_dataset/#add_meta_table_records_sql","text":"def add_meta_table_records_sql ( db_path , meta_table , meta_table_name ) Store new rows for the meta table using a more performant SQLite implementation. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Parameters: Name Description db_path Path to a .db file meta_table list of dictionaries to add to the meta_table meta_table_name optional name of the main SQLite table View Source def add_meta_table_records_sql ( db_path , meta_table , meta_table_name ): \"\"\"Store new rows for the meta table using a more performant SQLite implementation. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file meta_table: list of dictionaries to add to the meta_table meta_table_name: optional name of the main SQLite table \"\"\" with SQLConnection ( db_path ) as conn : cursor = conn . cursor () keys = [ * meta_table [ 0 ] . keys ()] names_formatted = ',' . join ( map ( safe_col_name , enumerate ( keys ))) cursor . execute ( f 'CREATE TABLE IF NOT EXISTS { meta_table_name } ( { names_formatted } );' ) rows = [[ row [ col ] for col in keys ] for row in meta_table ] places = ',' . join ([ '?' ] * len ( keys )) cursor . executemany ( f 'INSERT INTO { meta_table_name } ( { names_formatted } ) VALUES ( { places } );' , rows ) conn . commit ()","title":"add_meta_table_records_sql"},{"location":"modules/dash_charts/utils_dataset/#export_table_as_csv","text":"def export_table_as_csv ( csv_filename , table ) Create a CSV file summarizing a table of a dataset database. Parameters: Name Description csv_filename Path to csv file table table from dataset database View Source def export_table_as_csv ( csv_filename , table ): \"\"\"Create a CSV file summarizing a table of a `dataset` database. Args: csv_filename: Path to csv file table: table from dataset database \"\"\" rows = [[ * table . columns ]] rows . extend ([ * row . values ()] for row in table ) write_csv ( csv_filename , rows )","title":"export_table_as_csv"},{"location":"modules/dash_charts/utils_dataset/#get_table","text":"def get_table ( db_path , table_name , drop_id_col = True ) Retrieve the meta table as a Pandas dataframe. Parameters: Name Description db_path Path to a .db file table_name SQLite table name drop_id_col if True, drop the id column from SQL. Default is True Returns: Type Description df_table pandas dataframe for the values in the specified table ( meta_table_name ) View Source def get_table ( db_path , table_name , drop_id_col = True ): \"\"\"Retrieve the meta table as a Pandas dataframe. Args: db_path: Path to a `.db` file table_name: SQLite table name drop_id_col: if True, drop the `id` column from SQL. Default is True Returns: df_table: pandas dataframe for the values in the specified table (`meta_table_name`) \"\"\" with DBConnection ( db_path ) as data_db : df_table = pd . DataFrame ([ * data_db . db [ table_name ] . all ()]) # Optionally remove the 'id' column added in the SQL database if drop_id_col : df_table = df_table . drop ( labels = [ 'id' , 'index' ], axis = 1 , errors = 'ignore' ) return df_table # noqa: R504","title":"get_table"},{"location":"modules/dash_charts/utils_dataset/#safe_col_name","text":"def safe_col_name ( args_pair ) Ensure that the column name is safe for SQL (unique value, no spaces, no trailing punctuation). Typically called with df.columns = [*map(safe_col_name, enumerate(df.columns.to_list()))] Parameters: Name Description args_pair tuple of arguments from map function in (idx, col) Returns: Type Description string safely formatted string for SQLite View Source def safe_col_name ( args_pair ): \"\"\"Ensure that the column name is safe for SQL (unique value, no spaces, no trailing punctuation). Typically called with `df.columns = [*map(safe_col_name, enumerate(df.columns.to_list()))]` Args: args_pair: tuple of arguments from map function in `(idx, col)` Returns: string: safely formatted string for SQLite \"\"\" idx , col = args_pair col = col . strip () . replace ( ' ' , '_' ) . replace ( '.' , '_' ) . replace ( ',' , '_' ) return str ( idx ) if col == '' else col","title":"safe_col_name"},{"location":"modules/dash_charts/utils_dataset/#store_reference_tables","text":"def store_reference_tables ( db_path , data_dicts , meta_table_name = 'meta' , use_raw_sql = True ) Store multi-dimensionsal data in a SQLite database. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Parameters: Name Description db_path Path to a .db file data_dicts all data to be stored in SQLite. Can contain Pandas dataframes meta_table_name optional name of the main SQLite table. Default is META_TABLE_NAME use_raw_sql if True, will use the raw SQL connection rather than DataSet. This is faster for meta_tables that have more than 1000 rows, but less safe View Source def store_reference_tables ( db_path , data_dicts , meta_table_name = META_TABLE_NAME , use_raw_sql = True ): # noqa: CCR001 \"\"\"Store multi-dimensionsal data in a SQLite database. WARN: This will append to the META_TABLE_NAME without checking for duplicates. Handling de-duping separately Args: db_path: Path to a `.db` file data_dicts: all data to be stored in SQLite. Can contain Pandas dataframes meta_table_name: optional name of the main SQLite table. Default is `META_TABLE_NAME` use_raw_sql: if True, will use the raw SQL connection rather than DataSet. This is faster for meta_tables that have more than 1000 rows, but less safe \"\"\" with SQLConnection ( db_path ) as conn : meta_table = [] unique = uniq_table_id () for dict_idx , data_dict in enumerate ( data_dicts ): lookup = {} for key_idx , ( key , value ) in enumerate ( data_dict . items ()): if isinstance ( value , pd . DataFrame ): value . columns = [ * map ( safe_col_name , enumerate ( value . columns . to_list ()))] table_name = f ' { unique } Dict { dict_idx } Key { key_idx } ' value . to_sql ( table_name , con = conn ) lookup [ key ] = table_name else : lookup [ key ] = value meta_table . append ( lookup ) if use_raw_sql : add_meta_table_records_sql ( db_path , meta_table , meta_table_name ) else : with DBConnection ( db_path ) as data_db : table_main = data_db . db . create_table ( meta_table_name ) table_main . insert_many ( meta_table )","title":"store_reference_tables"},{"location":"modules/dash_charts/utils_dataset/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/utils_dataset/#dbconnect","text":"class DBConnect ( db_path ) View Source class DBConnect : # noqa: H601 \"\"\"Manage database connection since closing connection isn't possible.\"\"\" db_path = None \"\"\"Path to the local storage SQLite database file. Initialize in `__init__()`.\"\"\" _db = None @property def db ( self ): \"\"\"Return connection to database. Will create new connection if one does not exist already. Returns: dict: `dataset` database instance \"\"\" if self . _db is None : self . _db = dataset . connect ( f 'sqlite:/// { self . db_path } ' ) return self . _db def __init__ ( self , db_path ): \"\"\"Store the database path and ensure the parent directory exists. Args: db_path: Path to the SQLite file \"\"\" self . db_path = db_path . resolve () self . db_path . parent . mkdir ( exist_ok = True ) self . db # Check initial connection def new_table ( self , table_name ): \"\"\"Create a table. Drop a table if one existed before. Args: table_name: string table name to create Returns: table: a dataset Table instance \"\"\" if table_name in self . db . tables : self . db [ table_name ] . drop () return self . db . create_table ( table_name ) def close ( self ): \"\"\"Safely disconnect and release the SQLite file.\"\"\" self . db . executable . close () self . _db = None","title":"DBConnect"},{"location":"modules/dash_charts/utils_dataset/#class-variables","text":"db_path Path to the local storage SQLite database file. Initialize in __init__() .","title":"Class variables"},{"location":"modules/dash_charts/utils_dataset/#instance-variables","text":"db Return connection to database. Will create new connection if one does not exist already.","title":"Instance variables"},{"location":"modules/dash_charts/utils_dataset/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_dataset/#close","text":"def close ( self ) Safely disconnect and release the SQLite file. View Source def close ( self ): \"\"\"Safely disconnect and release the SQLite file.\"\"\" self . db . executable . close () self . _db = None","title":"close"},{"location":"modules/dash_charts/utils_dataset/#new_table","text":"def new_table ( self , table_name ) Create a table. Drop a table if one existed before. Parameters: Name Description table_name string table name to create Returns: Type Description table a dataset Table instance View Source def new_table ( self , table_name ): \"\"\"Create a table. Drop a table if one existed before. Args: table_name: string table name to create Returns: table: a dataset Table instance \"\"\" if table_name in self . db . tables : self . db [ table_name ] . drop () return self . db . create_table ( table_name )","title":"new_table"},{"location":"modules/dash_charts/utils_dataset/#dbconnection","text":"class DBConnection ( db_path ) View Source class DBConnection ( ContextDecorator ): \"\"\"Ensure the DBConnect connection is properly opened and closed.\"\"\" def __init__ ( self , db_path ): \"\"\"Initialize context wrapper. Args: db_path: Path to the SQLite file \"\"\" self . conn = None self . db_path = db_path def __enter__ ( self ): \"\"\"Connect to the database and return connection reference. Returns: dict: connection to sqlite database \"\"\" self . conn = DBConnect ( self . db_path ) return self . conn def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\"Close connection.\"\"\" # noqa: DAR101 self . conn . close ()","title":"DBConnection"},{"location":"modules/dash_charts/utils_dataset/#ancestors-in-mro","text":"contextlib.ContextDecorator","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_fig/","text":"dash_charts.utils_fig \u2693\ufe0e Utilities for custom Dash figures. View Source \"\"\"Utilities for custom Dash figures.\"\"\" import plotly.graph_objects as go from dash import dcc from plotly.subplots import make_subplots from .utils_data import validate FIGURE_PLACEHOLDER = { 'data' : [], 'layout' : {}, 'frames' : []} \"\"\"Figure placeholder.\"\"\" def min_graph ( config = None , figure = FIGURE_PLACEHOLDER , ** kwargs ): \"\"\"Return dcc.Graph element with Plotly overlay removed. See: https://community.plot.ly/t/is-it-possible-to-hide-the-floating-toolbar/4911/7 Args: config: dictionary passed to `dcc.Graph`. Default is to disable the `displayModeBar` figure: figure argument. Default is an empty placeholder (`FIGURE_PLACEHOLDER`) kwargs: any kwargs to pass to the dash initializer other than `assets_folder` Returns: dict: Dash `dcc.Graph` object \"\"\" if config is None : config = { 'displayModeBar' : False } return dcc . Graph ( config = config , figure = figure , ** kwargs ) def check_raw_data ( df_raw , min_keys ): \"\"\"Verify that dataframe contains the minimum columns. Args: df_raw: data to pass to formatter method min_keys: list of string column names expected in dataframe Raises: RuntimeError: if any columns are missing from dataframe \"\"\" all_keys = df_raw . keys () if len ([ _k for _k in min_keys if _k in all_keys ]) != len ( min_keys ): raise RuntimeError ( f '`df_raw` must have keys { min_keys } . Found: { all_keys } ' ) def make_dict_an ( coord , text , label = None , color = None , y_offset = 10 ): \"\"\"Create stylized chart annotation. Args: coord: tuple of x and y coordinate text: string text for annotation label: string label shown on hover color: string color. If None (default), will revert to black y_offset: offset in yaxis for annotation Returns: dict: keyword arguments for `go.layout.Annotation` \"\"\" return { 'arrowcolor' : color or 'black' , 'arrowhead' : 7 , 'arrowsize' : 0.3 , 'arrowwidth' : 1.5 , 'ax' : coord [ 0 ], 'axref' : 'x' , 'ay' : coord [ 1 ] + y_offset , 'ayref' : 'y' , 'bgcolor' : color or 'black' , 'bordercolor' : color or 'black' , 'borderpad' : 2 , 'borderwidth' : 1 , 'font' : { 'color' : '#ffffff' }, 'hovertext' : label , 'opacity' : 0.8 , 'showarrow' : True , 'text' : text , 'x' : coord [ 0 ], 'xref' : 'x' , 'y' : coord [ 1 ], 'yref' : 'y' , } class CustomChart : # noqa: H601 \"\"\"Base Class for Custom Charts.\"\"\" annotations = [] \"\"\"Store annotations. Default is an empty list. See documentation: https://plot.ly/python/reference/#layout-annotations \"\"\" _axis_range = {} _axis_range_schema = { 'x' : { 'items' : [{ 'type' : [ 'integer' , 'float' , 'string' ]}, { 'type' : [ 'integer' , 'float' , 'string' ]}], 'required' : False , 'type' : 'list' , }, 'y' : { 'items' : [{ 'type' : [ 'integer' , 'float' ]}, { 'type' : [ 'integer' , 'float' ]}], 'required' : False , 'type' : 'list' , }, } @property def axis_range ( self ): \"\"\"Specify x/y axis range or leave as empty dictionary for autorange. Returns: dict: dictionary potentially with keys `(x, y)` \"\"\" return self . _axis_range @axis_range . setter def axis_range ( self , axis_range ): errors = validate ( axis_range , self . _axis_range_schema ) if errors : raise RuntimeError ( f 'Validation of self.axis_range failed: { errors } ' ) # Assign new axis_range self . _axis_range = axis_range def __init__ ( self , * , title , xlabel , ylabel , layout_overrides = ()): \"\"\"Initialize Custom Dash Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) xlabel: XAxis string label (can be an empty string for blank) ylabel: YAxis string label (can be an empty string for blank) layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" self . title = title self . labels = { 'x' : xlabel , 'y' : ylabel } self . layout_overrides = layout_overrides self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout class MarginalChart ( CustomChart ): # noqa: H601 \"\"\"Base Class for Custom Charts with Marginal X and Marginal Y Plots.\"\"\" def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: Dash figure object \"\"\" # Initialize figure with subplots fig = make_subplots ( rows = 2 , cols = 2 , shared_xaxes = True , shared_yaxes = True , vertical_spacing = 0.02 , horizontal_spacing = 0.02 , row_width = [ 0.8 , 0.2 ], column_width = [ 0.8 , 0.2 ], ) # Populate the traces of each subplot traces = [ ( self . create_traces , 2 , 1 ), ( self . create_marg_top , 1 , 1 ), ( self . create_marg_right , 2 , 2 ), ] for trace_func , row , col in traces : for trace in trace_func ( df_raw , ** kwargs_data ): fig . add_trace ( trace , row , col ) # Apply axis labels fig . update_xaxes ( title_text = self . labels [ 'x' ], row = 2 , col = 1 ) fig . update_yaxes ( title_text = self . labels [ 'y' ], row = 2 , col = 1 ) # Replace the default blue/white grid introduced in Plotly v4 fig . update_xaxes ( showgrid = True , gridcolor = 'white' ) fig . update_yaxes ( showgrid = True , gridcolor = 'white' ) fig [ 'layout' ] . update ( self . apply_custom_layout ( self . create_layout ())) return fig def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_marg_top ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_top must be implemented by child class' ) # pragma: no cover def create_marg_right ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_right must be implemented by child class' ) # pragma: no cover def create_layout ( self , * , bg_color = '#F0F0F0' ): \"\"\"Remove axis lables from base layout as they would be applied to (row=1,col=1). Args: bg_color: Background color for the chart. Default is white for light themes Returns: dict: updated layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'xaxis' ][ 'title' ] = '' layout [ 'yaxis' ][ 'title' ] = '' layout [ 'plot_bgcolor' ] = bg_color return layout Variables \u2693\ufe0e FIGURE_PLACEHOLDER Figure placeholder. Functions \u2693\ufe0e check_raw_data \u2693\ufe0e def check_raw_data ( df_raw , min_keys ) Verify that dataframe contains the minimum columns. Parameters: Name Description df_raw data to pass to formatter method min_keys list of string column names expected in dataframe Raises: Type Description RuntimeError if any columns are missing from dataframe View Source def check_raw_data ( df_raw , min_keys ): \"\"\"Verify that dataframe contains the minimum columns. Args: df_raw: data to pass to formatter method min_keys: list of string column names expected in dataframe Raises: RuntimeError: if any columns are missing from dataframe \"\"\" all_keys = df_raw . keys () if len ([ _k for _k in min_keys if _k in all_keys ]) != len ( min_keys ): raise RuntimeError ( f '`df_raw` must have keys { min_keys } . Found: { all_keys } ' ) make_dict_an \u2693\ufe0e def make_dict_an ( coord , text , label = None , color = None , y_offset = 10 ) Create stylized chart annotation. Parameters: Name Description coord tuple of x and y coordinate text string text for annotation label string label shown on hover color string color. If None (default), will revert to black y_offset offset in yaxis for annotation Returns: Type Description dict keyword arguments for go.layout.Annotation View Source def make_dict_an ( coord , text , label = None , color = None , y_offset = 10 ): \"\"\"Create stylized chart annotation. Args: coord: tuple of x and y coordinate text: string text for annotation label: string label shown on hover color: string color. If None (default), will revert to black y_offset: offset in yaxis for annotation Returns: dict: keyword arguments for `go.layout.Annotation` \"\"\" return { 'arrowcolor' : color or 'black' , 'arrowhead' : 7 , 'arrowsize' : 0.3 , 'arrowwidth' : 1.5 , 'ax' : coord [ 0 ], 'axref' : 'x' , 'ay' : coord [ 1 ] + y_offset , 'ayref' : 'y' , 'bgcolor' : color or 'black' , 'bordercolor' : color or 'black' , 'borderpad' : 2 , 'borderwidth' : 1 , 'font' : { 'color' : '#ffffff' }, 'hovertext' : label , 'opacity' : 0.8 , 'showarrow' : True , 'text' : text , 'x' : coord [ 0 ], 'xref' : 'x' , 'y' : coord [ 1 ], 'yref' : 'y' , } min_graph \u2693\ufe0e def min_graph ( config = None , figure = { 'data' : [], 'layout' : {}, 'frames' : []}, ** kwargs ) Return dcc.Graph element with Plotly overlay removed. See: https://community.plot.ly/t/is-it-possible-to-hide-the-floating-toolbar/4911/7 Parameters: Name Description config dictionary passed to dcc.Graph . Default is to disable the displayModeBar figure figure argument. Default is an empty placeholder ( FIGURE_PLACEHOLDER ) kwargs any kwargs to pass to the dash initializer other than assets_folder Returns: Type Description dict Dash dcc.Graph object View Source def min_graph ( config = None , figure = FIGURE_PLACEHOLDER , ** kwargs ): \"\"\"Return dcc.Graph element with Plotly overlay removed. See: https://community.plot.ly/t/is-it-possible-to-hide-the-floating-toolbar/4911/7 Args: config: dictionary passed to `dcc.Graph`. Default is to disable the `displayModeBar` figure: figure argument. Default is an empty placeholder (`FIGURE_PLACEHOLDER`) kwargs: any kwargs to pass to the dash initializer other than `assets_folder` Returns: dict: Dash `dcc.Graph` object \"\"\" if config is None : config = { 'displayModeBar' : False } return dcc . Graph ( config = config , figure = figure , ** kwargs ) Classes \u2693\ufe0e CustomChart \u2693\ufe0e class CustomChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class CustomChart : # noqa: H601 \"\"\"Base Class for Custom Charts.\"\"\" annotations = [] \"\"\"Store annotations. Default is an empty list. See documentation: https://plot.ly/python/reference/#layout-annotations \"\"\" _axis_range = {} _axis_range_schema = { 'x' : { 'items' : [{ 'type' : [ 'integer' , 'float' , 'string' ]}, { 'type' : [ 'integer' , 'float' , 'string' ]}], 'required' : False , 'type' : 'list' , }, 'y' : { 'items' : [{ 'type' : [ 'integer' , 'float' ]}, { 'type' : [ 'integer' , 'float' ]}], 'required' : False , 'type' : 'list' , }, } @property def axis_range ( self ): \"\"\"Specify x/y axis range or leave as empty dictionary for autorange. Returns: dict: dictionary potentially with keys `(x, y)` \"\"\" return self . _axis_range @axis_range . setter def axis_range ( self , axis_range ): errors = validate ( axis_range , self . _axis_range_schema ) if errors : raise RuntimeError ( f 'Validation of self.axis_range failed: { errors } ' ) # Assign new axis_range self . _axis_range = axis_range def __init__ ( self , * , title , xlabel , ylabel , layout_overrides = ()): \"\"\"Initialize Custom Dash Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) xlabel: XAxis string label (can be an empty string for blank) ylabel: YAxis string label (can be an empty string for blank) layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" self . title = title self . labels = { 'x' : xlabel , 'y' : ylabel } self . layout_overrides = layout_overrides self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout Descendants \u2693\ufe0e dash_charts.utils_fig.MarginalChart dash_charts.coordinate_chart.CoordinateChart dash_charts.gantt_chart.GanttChart dash_charts.pareto_chart.ParetoChart dash_charts.scatter_line_charts.RollingChart dash_charts.scatter_line_charts.FittedChart dash_charts.time_vis_chart.TimeVisChart Class variables \u2693\ufe0e annotations Store annotations. Default is an empty list. See documentation: https://plot.ly/python/reference/#layout-annotations Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } create_layout \u2693\ufe0e def create_layout ( self ) Return the standard layout. Can be overridden and modified when inherited. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout create_traces \u2693\ufe0e def create_traces ( self , df_raw , ** kwargs_data ) Return traces for plotly chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... MarginalChart \u2693\ufe0e class MarginalChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class MarginalChart ( CustomChart ): # noqa: H601 \"\"\"Base Class for Custom Charts with Marginal X and Marginal Y Plots.\"\"\" def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: Dash figure object \"\"\" # Initialize figure with subplots fig = make_subplots ( rows = 2 , cols = 2 , shared_xaxes = True , shared_yaxes = True , vertical_spacing = 0.02 , horizontal_spacing = 0.02 , row_width = [ 0.8 , 0.2 ], column_width = [ 0.8 , 0.2 ], ) # Populate the traces of each subplot traces = [ ( self . create_traces , 2 , 1 ), ( self . create_marg_top , 1 , 1 ), ( self . create_marg_right , 2 , 2 ), ] for trace_func , row , col in traces : for trace in trace_func ( df_raw , ** kwargs_data ): fig . add_trace ( trace , row , col ) # Apply axis labels fig . update_xaxes ( title_text = self . labels [ 'x' ], row = 2 , col = 1 ) fig . update_yaxes ( title_text = self . labels [ 'y' ], row = 2 , col = 1 ) # Replace the default blue/white grid introduced in Plotly v4 fig . update_xaxes ( showgrid = True , gridcolor = 'white' ) fig . update_yaxes ( showgrid = True , gridcolor = 'white' ) fig [ 'layout' ] . update ( self . apply_custom_layout ( self . create_layout ())) return fig def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_marg_top ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_top must be implemented by child class' ) # pragma: no cover def create_marg_right ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_right must be implemented by child class' ) # pragma: no cover def create_layout ( self , * , bg_color = '#F0F0F0' ): \"\"\"Remove axis lables from base layout as they would be applied to (row=1,col=1). Args: bg_color: Background color for the chart. Default is white for light themes Returns: dict: updated layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'xaxis' ][ 'title' ] = '' layout [ 'yaxis' ][ 'title' ] = '' layout [ 'plot_bgcolor' ] = bg_color return layout Ancestors (in MRO) \u2693\ufe0e dash_charts.utils_fig.CustomChart Class variables \u2693\ufe0e annotations Instance variables \u2693\ufe0e axis_range Specify x/y axis range or leave as empty dictionary for autorange. Methods \u2693\ufe0e apply_custom_layout \u2693\ufe0e def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout create_figure \u2693\ufe0e def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict Dash figure object View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: Dash figure object \"\"\" # Initialize figure with subplots fig = make_subplots ( rows = 2 , cols = 2 , shared_xaxes = True , shared_yaxes = True , vertical_spacing = 0.02 , horizontal_spacing = 0.02 , row_width = [ 0.8 , 0.2 ], column_width = [ 0.8 , 0.2 ], ) # Populate the traces of each subplot traces = [ ( self . create_traces , 2 , 1 ), ( self . create_marg_top , 1 , 1 ), ( self . create_marg_right , 2 , 2 ), ] for trace_func , row , col in traces : for trace in trace_func ( df_raw , ** kwargs_data ): fig . add_trace ( trace , row , col ) # Apply axis labels fig . update_xaxes ( title_text = self . labels [ 'x' ], row = 2 , col = 1 ) fig . update_yaxes ( title_text = self . labels [ 'y' ], row = 2 , col = 1 ) # Replace the default blue/white grid introduced in Plotly v4 fig . update_xaxes ( showgrid = True , gridcolor = 'white' ) fig . update_yaxes ( showgrid = True , gridcolor = 'white' ) fig [ 'layout' ] . update ( self . apply_custom_layout ( self . create_layout ())) return fig create_layout \u2693\ufe0e def create_layout ( self , * , bg_color = '#F0F0F0' ) Remove axis lables from base layout as they would be applied to (row=1,col=1). Parameters: Name Description bg_color Background color for the chart. Default is white for light themes Returns: Type Description dict updated layout for Dash figure View Source def create_layout ( self , * , bg_color = '#F0F0F0' ): \"\"\"Remove axis lables from base layout as they would be applied to (row=1,col=1). Args: bg_color: Background color for the chart. Default is white for light themes Returns: dict: updated layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'xaxis' ][ 'title' ] = '' layout [ 'yaxis' ][ 'title' ] = '' layout [ 'plot_bgcolor' ] = bg_color return layout create_marg_right \u2693\ufe0e def create_marg_right ( self , df_raw , ** kwargs_data ) Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_marg_right ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_right must be implemented by child class' ) # pragma: no cover create_marg_top \u2693\ufe0e def create_marg_top ( self , df_raw , ** kwargs_data ) Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_marg_top ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_top must be implemented by child class' ) # pragma: no cover create_traces \u2693\ufe0e def create_traces ( self , df_raw , ** kwargs_data ) Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover initialize_mutables \u2693\ufe0e def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"dash_charts.utils_fig"},{"location":"modules/dash_charts/utils_fig/#dash_chartsutils_fig","text":"Utilities for custom Dash figures. View Source \"\"\"Utilities for custom Dash figures.\"\"\" import plotly.graph_objects as go from dash import dcc from plotly.subplots import make_subplots from .utils_data import validate FIGURE_PLACEHOLDER = { 'data' : [], 'layout' : {}, 'frames' : []} \"\"\"Figure placeholder.\"\"\" def min_graph ( config = None , figure = FIGURE_PLACEHOLDER , ** kwargs ): \"\"\"Return dcc.Graph element with Plotly overlay removed. See: https://community.plot.ly/t/is-it-possible-to-hide-the-floating-toolbar/4911/7 Args: config: dictionary passed to `dcc.Graph`. Default is to disable the `displayModeBar` figure: figure argument. Default is an empty placeholder (`FIGURE_PLACEHOLDER`) kwargs: any kwargs to pass to the dash initializer other than `assets_folder` Returns: dict: Dash `dcc.Graph` object \"\"\" if config is None : config = { 'displayModeBar' : False } return dcc . Graph ( config = config , figure = figure , ** kwargs ) def check_raw_data ( df_raw , min_keys ): \"\"\"Verify that dataframe contains the minimum columns. Args: df_raw: data to pass to formatter method min_keys: list of string column names expected in dataframe Raises: RuntimeError: if any columns are missing from dataframe \"\"\" all_keys = df_raw . keys () if len ([ _k for _k in min_keys if _k in all_keys ]) != len ( min_keys ): raise RuntimeError ( f '`df_raw` must have keys { min_keys } . Found: { all_keys } ' ) def make_dict_an ( coord , text , label = None , color = None , y_offset = 10 ): \"\"\"Create stylized chart annotation. Args: coord: tuple of x and y coordinate text: string text for annotation label: string label shown on hover color: string color. If None (default), will revert to black y_offset: offset in yaxis for annotation Returns: dict: keyword arguments for `go.layout.Annotation` \"\"\" return { 'arrowcolor' : color or 'black' , 'arrowhead' : 7 , 'arrowsize' : 0.3 , 'arrowwidth' : 1.5 , 'ax' : coord [ 0 ], 'axref' : 'x' , 'ay' : coord [ 1 ] + y_offset , 'ayref' : 'y' , 'bgcolor' : color or 'black' , 'bordercolor' : color or 'black' , 'borderpad' : 2 , 'borderwidth' : 1 , 'font' : { 'color' : '#ffffff' }, 'hovertext' : label , 'opacity' : 0.8 , 'showarrow' : True , 'text' : text , 'x' : coord [ 0 ], 'xref' : 'x' , 'y' : coord [ 1 ], 'yref' : 'y' , } class CustomChart : # noqa: H601 \"\"\"Base Class for Custom Charts.\"\"\" annotations = [] \"\"\"Store annotations. Default is an empty list. See documentation: https://plot.ly/python/reference/#layout-annotations \"\"\" _axis_range = {} _axis_range_schema = { 'x' : { 'items' : [{ 'type' : [ 'integer' , 'float' , 'string' ]}, { 'type' : [ 'integer' , 'float' , 'string' ]}], 'required' : False , 'type' : 'list' , }, 'y' : { 'items' : [{ 'type' : [ 'integer' , 'float' ]}, { 'type' : [ 'integer' , 'float' ]}], 'required' : False , 'type' : 'list' , }, } @property def axis_range ( self ): \"\"\"Specify x/y axis range or leave as empty dictionary for autorange. Returns: dict: dictionary potentially with keys `(x, y)` \"\"\" return self . _axis_range @axis_range . setter def axis_range ( self , axis_range ): errors = validate ( axis_range , self . _axis_range_schema ) if errors : raise RuntimeError ( f 'Validation of self.axis_range failed: { errors } ' ) # Assign new axis_range self . _axis_range = axis_range def __init__ ( self , * , title , xlabel , ylabel , layout_overrides = ()): \"\"\"Initialize Custom Dash Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) xlabel: XAxis string label (can be an empty string for blank) ylabel: YAxis string label (can be an empty string for blank) layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" self . title = title self . labels = { 'x' : xlabel , 'y' : ylabel } self . layout_overrides = layout_overrides self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout class MarginalChart ( CustomChart ): # noqa: H601 \"\"\"Base Class for Custom Charts with Marginal X and Marginal Y Plots.\"\"\" def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: Dash figure object \"\"\" # Initialize figure with subplots fig = make_subplots ( rows = 2 , cols = 2 , shared_xaxes = True , shared_yaxes = True , vertical_spacing = 0.02 , horizontal_spacing = 0.02 , row_width = [ 0.8 , 0.2 ], column_width = [ 0.8 , 0.2 ], ) # Populate the traces of each subplot traces = [ ( self . create_traces , 2 , 1 ), ( self . create_marg_top , 1 , 1 ), ( self . create_marg_right , 2 , 2 ), ] for trace_func , row , col in traces : for trace in trace_func ( df_raw , ** kwargs_data ): fig . add_trace ( trace , row , col ) # Apply axis labels fig . update_xaxes ( title_text = self . labels [ 'x' ], row = 2 , col = 1 ) fig . update_yaxes ( title_text = self . labels [ 'y' ], row = 2 , col = 1 ) # Replace the default blue/white grid introduced in Plotly v4 fig . update_xaxes ( showgrid = True , gridcolor = 'white' ) fig . update_yaxes ( showgrid = True , gridcolor = 'white' ) fig [ 'layout' ] . update ( self . apply_custom_layout ( self . create_layout ())) return fig def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_marg_top ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_top must be implemented by child class' ) # pragma: no cover def create_marg_right ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_right must be implemented by child class' ) # pragma: no cover def create_layout ( self , * , bg_color = '#F0F0F0' ): \"\"\"Remove axis lables from base layout as they would be applied to (row=1,col=1). Args: bg_color: Background color for the chart. Default is white for light themes Returns: dict: updated layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'xaxis' ][ 'title' ] = '' layout [ 'yaxis' ][ 'title' ] = '' layout [ 'plot_bgcolor' ] = bg_color return layout","title":"dash_charts.utils_fig"},{"location":"modules/dash_charts/utils_fig/#variables","text":"FIGURE_PLACEHOLDER Figure placeholder.","title":"Variables"},{"location":"modules/dash_charts/utils_fig/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_fig/#check_raw_data","text":"def check_raw_data ( df_raw , min_keys ) Verify that dataframe contains the minimum columns. Parameters: Name Description df_raw data to pass to formatter method min_keys list of string column names expected in dataframe Raises: Type Description RuntimeError if any columns are missing from dataframe View Source def check_raw_data ( df_raw , min_keys ): \"\"\"Verify that dataframe contains the minimum columns. Args: df_raw: data to pass to formatter method min_keys: list of string column names expected in dataframe Raises: RuntimeError: if any columns are missing from dataframe \"\"\" all_keys = df_raw . keys () if len ([ _k for _k in min_keys if _k in all_keys ]) != len ( min_keys ): raise RuntimeError ( f '`df_raw` must have keys { min_keys } . Found: { all_keys } ' )","title":"check_raw_data"},{"location":"modules/dash_charts/utils_fig/#make_dict_an","text":"def make_dict_an ( coord , text , label = None , color = None , y_offset = 10 ) Create stylized chart annotation. Parameters: Name Description coord tuple of x and y coordinate text string text for annotation label string label shown on hover color string color. If None (default), will revert to black y_offset offset in yaxis for annotation Returns: Type Description dict keyword arguments for go.layout.Annotation View Source def make_dict_an ( coord , text , label = None , color = None , y_offset = 10 ): \"\"\"Create stylized chart annotation. Args: coord: tuple of x and y coordinate text: string text for annotation label: string label shown on hover color: string color. If None (default), will revert to black y_offset: offset in yaxis for annotation Returns: dict: keyword arguments for `go.layout.Annotation` \"\"\" return { 'arrowcolor' : color or 'black' , 'arrowhead' : 7 , 'arrowsize' : 0.3 , 'arrowwidth' : 1.5 , 'ax' : coord [ 0 ], 'axref' : 'x' , 'ay' : coord [ 1 ] + y_offset , 'ayref' : 'y' , 'bgcolor' : color or 'black' , 'bordercolor' : color or 'black' , 'borderpad' : 2 , 'borderwidth' : 1 , 'font' : { 'color' : '#ffffff' }, 'hovertext' : label , 'opacity' : 0.8 , 'showarrow' : True , 'text' : text , 'x' : coord [ 0 ], 'xref' : 'x' , 'y' : coord [ 1 ], 'yref' : 'y' , }","title":"make_dict_an"},{"location":"modules/dash_charts/utils_fig/#min_graph","text":"def min_graph ( config = None , figure = { 'data' : [], 'layout' : {}, 'frames' : []}, ** kwargs ) Return dcc.Graph element with Plotly overlay removed. See: https://community.plot.ly/t/is-it-possible-to-hide-the-floating-toolbar/4911/7 Parameters: Name Description config dictionary passed to dcc.Graph . Default is to disable the displayModeBar figure figure argument. Default is an empty placeholder ( FIGURE_PLACEHOLDER ) kwargs any kwargs to pass to the dash initializer other than assets_folder Returns: Type Description dict Dash dcc.Graph object View Source def min_graph ( config = None , figure = FIGURE_PLACEHOLDER , ** kwargs ): \"\"\"Return dcc.Graph element with Plotly overlay removed. See: https://community.plot.ly/t/is-it-possible-to-hide-the-floating-toolbar/4911/7 Args: config: dictionary passed to `dcc.Graph`. Default is to disable the `displayModeBar` figure: figure argument. Default is an empty placeholder (`FIGURE_PLACEHOLDER`) kwargs: any kwargs to pass to the dash initializer other than `assets_folder` Returns: dict: Dash `dcc.Graph` object \"\"\" if config is None : config = { 'displayModeBar' : False } return dcc . Graph ( config = config , figure = figure , ** kwargs )","title":"min_graph"},{"location":"modules/dash_charts/utils_fig/#classes","text":"","title":"Classes"},{"location":"modules/dash_charts/utils_fig/#customchart","text":"class CustomChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class CustomChart : # noqa: H601 \"\"\"Base Class for Custom Charts.\"\"\" annotations = [] \"\"\"Store annotations. Default is an empty list. See documentation: https://plot.ly/python/reference/#layout-annotations \"\"\" _axis_range = {} _axis_range_schema = { 'x' : { 'items' : [{ 'type' : [ 'integer' , 'float' , 'string' ]}, { 'type' : [ 'integer' , 'float' , 'string' ]}], 'required' : False , 'type' : 'list' , }, 'y' : { 'items' : [{ 'type' : [ 'integer' , 'float' ]}, { 'type' : [ 'integer' , 'float' ]}], 'required' : False , 'type' : 'list' , }, } @property def axis_range ( self ): \"\"\"Specify x/y axis range or leave as empty dictionary for autorange. Returns: dict: dictionary potentially with keys `(x, y)` \"\"\" return self . _axis_range @axis_range . setter def axis_range ( self , axis_range ): errors = validate ( axis_range , self . _axis_range_schema ) if errors : raise RuntimeError ( f 'Validation of self.axis_range failed: { errors } ' ) # Assign new axis_range self . _axis_range = axis_range def __init__ ( self , * , title , xlabel , ylabel , layout_overrides = ()): \"\"\"Initialize Custom Dash Chart and store parameters as data members. Args: title: String title for chart (can be an empty string for blank) xlabel: XAxis string label (can be an empty string for blank) ylabel: YAxis string label (can be an empty string for blank) layout_overrides: Custom parameters in format [ParentKey, SubKey, Value] to customize 'go.layout' \"\"\" self . title = title self . labels = { 'x' : xlabel , 'y' : ylabel } self . layout_overrides = layout_overrides self . initialize_mutables () def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ... def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), } def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"CustomChart"},{"location":"modules/dash_charts/utils_fig/#descendants","text":"dash_charts.utils_fig.MarginalChart dash_charts.coordinate_chart.CoordinateChart dash_charts.gantt_chart.GanttChart dash_charts.pareto_chart.ParetoChart dash_charts.scatter_line_charts.RollingChart dash_charts.scatter_line_charts.FittedChart dash_charts.time_vis_chart.TimeVisChart","title":"Descendants"},{"location":"modules/dash_charts/utils_fig/#class-variables","text":"annotations Store annotations. Default is an empty list. See documentation: https://plot.ly/python/reference/#layout-annotations","title":"Class variables"},{"location":"modules/dash_charts/utils_fig/#instance-variables","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/utils_fig/#methods","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_fig/#apply_custom_layout","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/utils_fig/#create_figure","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict keys data and layout for Dash View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: keys `data` and `layout` for Dash \"\"\" return { 'data' : self . create_traces ( df_raw , ** kwargs_data ), 'layout' : go . Layout ( self . apply_custom_layout ( self . create_layout ())), }","title":"create_figure"},{"location":"modules/dash_charts/utils_fig/#create_layout","text":"def create_layout ( self ) Return the standard layout. Can be overridden and modified when inherited. Returns: Type Description dict layout for Dash figure View Source def create_layout ( self ): \"\"\"Return the standard layout. Can be overridden and modified when inherited. Returns: dict: layout for Dash figure \"\"\" layout = { 'annotations' : self . annotations , 'title' : go . layout . Title ( text = self . title ), 'xaxis' : { 'automargin' : True , 'title' : self . labels [ 'x' ], }, 'yaxis' : { 'automargin' : True , 'title' : self . labels [ 'y' ], 'zeroline' : True , }, 'legend' : { 'orientation' : 'h' , 'y' : - 0.25 }, # below XAxis label 'hovermode' : 'closest' , } # Optionally apply the specified range for axis in [ 'x' , 'y' ]: axis_name = f ' { axis } axis' if axis in self . axis_range : layout [ axis_name ][ 'range' ] = self . axis_range [ axis ] else : layout [ axis_name ][ 'autorange' ] = True return layout","title":"create_layout"},{"location":"modules/dash_charts/utils_fig/#create_traces","text":"def create_traces ( self , df_raw , ** kwargs_data ) Return traces for plotly chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover","title":"create_traces"},{"location":"modules/dash_charts/utils_fig/#initialize_mutables","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/utils_fig/#marginalchart","text":"class MarginalChart ( * , title , xlabel , ylabel , layout_overrides = () ) View Source class MarginalChart ( CustomChart ): # noqa: H601 \"\"\"Base Class for Custom Charts with Marginal X and Marginal Y Plots.\"\"\" def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: Dash figure object \"\"\" # Initialize figure with subplots fig = make_subplots ( rows = 2 , cols = 2 , shared_xaxes = True , shared_yaxes = True , vertical_spacing = 0.02 , horizontal_spacing = 0.02 , row_width = [ 0.8 , 0.2 ], column_width = [ 0.8 , 0.2 ], ) # Populate the traces of each subplot traces = [ ( self . create_traces , 2 , 1 ), ( self . create_marg_top , 1 , 1 ), ( self . create_marg_right , 2 , 2 ), ] for trace_func , row , col in traces : for trace in trace_func ( df_raw , ** kwargs_data ): fig . add_trace ( trace , row , col ) # Apply axis labels fig . update_xaxes ( title_text = self . labels [ 'x' ], row = 2 , col = 1 ) fig . update_yaxes ( title_text = self . labels [ 'y' ], row = 2 , col = 1 ) # Replace the default blue/white grid introduced in Plotly v4 fig . update_xaxes ( showgrid = True , gridcolor = 'white' ) fig . update_yaxes ( showgrid = True , gridcolor = 'white' ) fig [ 'layout' ] . update ( self . apply_custom_layout ( self . create_layout ())) return fig def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover def create_marg_top ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_top must be implemented by child class' ) # pragma: no cover def create_marg_right ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_right must be implemented by child class' ) # pragma: no cover def create_layout ( self , * , bg_color = '#F0F0F0' ): \"\"\"Remove axis lables from base layout as they would be applied to (row=1,col=1). Args: bg_color: Background color for the chart. Default is white for light themes Returns: dict: updated layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'xaxis' ][ 'title' ] = '' layout [ 'yaxis' ][ 'title' ] = '' layout [ 'plot_bgcolor' ] = bg_color return layout","title":"MarginalChart"},{"location":"modules/dash_charts/utils_fig/#ancestors-in-mro","text":"dash_charts.utils_fig.CustomChart","title":"Ancestors (in MRO)"},{"location":"modules/dash_charts/utils_fig/#class-variables_1","text":"annotations","title":"Class variables"},{"location":"modules/dash_charts/utils_fig/#instance-variables_1","text":"axis_range Specify x/y axis range or leave as empty dictionary for autorange.","title":"Instance variables"},{"location":"modules/dash_charts/utils_fig/#methods_1","text":"","title":"Methods"},{"location":"modules/dash_charts/utils_fig/#apply_custom_layout_1","text":"def apply_custom_layout ( self , layout ) Extend and/or override layout with custom settings. Parameters: Name Description layout base layout dictionary. Typically from self.create_layout() Returns: Type Description dict layout for Dash figure View Source def apply_custom_layout ( self , layout ): \"\"\"Extend and/or override layout with custom settings. Args: layout: base layout dictionary. Typically from self.create_layout() Returns: dict: layout for Dash figure \"\"\" for parent_key , sub_key , value in self . layout_overrides : if sub_key is not None : layout [ parent_key ][ sub_key ] = value else : layout [ parent_key ] = value return layout","title":"apply_custom_layout"},{"location":"modules/dash_charts/utils_fig/#create_figure_1","text":"def create_figure ( self , df_raw , ** kwargs_data ) Create the figure dictionary. Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Returns: Type Description dict Dash figure object View Source def create_figure ( self , df_raw , ** kwargs_data ): \"\"\"Create the figure dictionary. Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Returns: dict: Dash figure object \"\"\" # Initialize figure with subplots fig = make_subplots ( rows = 2 , cols = 2 , shared_xaxes = True , shared_yaxes = True , vertical_spacing = 0.02 , horizontal_spacing = 0.02 , row_width = [ 0.8 , 0.2 ], column_width = [ 0.8 , 0.2 ], ) # Populate the traces of each subplot traces = [ ( self . create_traces , 2 , 1 ), ( self . create_marg_top , 1 , 1 ), ( self . create_marg_right , 2 , 2 ), ] for trace_func , row , col in traces : for trace in trace_func ( df_raw , ** kwargs_data ): fig . add_trace ( trace , row , col ) # Apply axis labels fig . update_xaxes ( title_text = self . labels [ 'x' ], row = 2 , col = 1 ) fig . update_yaxes ( title_text = self . labels [ 'y' ], row = 2 , col = 1 ) # Replace the default blue/white grid introduced in Plotly v4 fig . update_xaxes ( showgrid = True , gridcolor = 'white' ) fig . update_yaxes ( showgrid = True , gridcolor = 'white' ) fig [ 'layout' ] . update ( self . apply_custom_layout ( self . create_layout ())) return fig","title":"create_figure"},{"location":"modules/dash_charts/utils_fig/#create_layout_1","text":"def create_layout ( self , * , bg_color = '#F0F0F0' ) Remove axis lables from base layout as they would be applied to (row=1,col=1). Parameters: Name Description bg_color Background color for the chart. Default is white for light themes Returns: Type Description dict updated layout for Dash figure View Source def create_layout ( self , * , bg_color = '#F0F0F0' ): \"\"\"Remove axis lables from base layout as they would be applied to (row=1,col=1). Args: bg_color: Background color for the chart. Default is white for light themes Returns: dict: updated layout for Dash figure \"\"\" layout = super () . create_layout () layout [ 'xaxis' ][ 'title' ] = '' layout [ 'yaxis' ][ 'title' ] = '' layout [ 'plot_bgcolor' ] = bg_color return layout","title":"create_layout"},{"location":"modules/dash_charts/utils_fig/#create_marg_right","text":"def create_marg_right ( self , df_raw , ** kwargs_data ) Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_marg_right ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the right marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_right must be implemented by child class' ) # pragma: no cover","title":"create_marg_right"},{"location":"modules/dash_charts/utils_fig/#create_marg_top","text":"def create_marg_top ( self , df_raw , ** kwargs_data ) Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_marg_top ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the top marginal chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_marg_top must be implemented by child class' ) # pragma: no cover","title":"create_marg_top"},{"location":"modules/dash_charts/utils_fig/#create_traces_1","text":"def create_traces ( self , df_raw , ** kwargs_data ) Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Parameters: Name Description df_raw data to pass to formatter method kwargs_data keyword arguments to pass to the data formatter method Raises: Type Description NotImplementedError Must be overridden by child class View Source def create_traces ( self , df_raw , ** kwargs_data ): \"\"\"Return traces for the main plotly chart. Should return, list: trace data points. List may be empty Args: df_raw: data to pass to formatter method kwargs_data: keyword arguments to pass to the data formatter method Raises: NotImplementedError: Must be overridden by child class \"\"\" raise NotImplementedError ( 'create_traces must be implemented by child class' ) # pragma: no cover","title":"create_traces"},{"location":"modules/dash_charts/utils_fig/#initialize_mutables_1","text":"def initialize_mutables ( self ) Initialize the mutable data members to prevent modifying one attribute and impacting all instances. View Source def initialize_mutables ( self ): \"\"\"Initialize the mutable data members to prevent modifying one attribute and impacting all instances.\"\"\" ...","title":"initialize_mutables"},{"location":"modules/dash_charts/utils_helpers/","text":"dash_charts.utils_helpers \u2693\ufe0e Helpers for building Dash applications. View Source \"\"\"Helpers for building Dash applications.\"\"\" import argparse import time from datetime import datetime from typing import Optional from beartype import beartype # ---------------------------------------------------------------------------------------------------------------------- # General Debug @beartype def debug_time ( message : str , last : Optional [ datetime ] = None ) -> datetime : \"\"\"Debug timing issues. Args: message: string message to print last: last timestamp Returns: timestamp: the current timestamp to calculate the next delta \"\"\" if last is None : last = time . time () now = time . time () delta = now - last if delta > 0.5 : print ( message , delta ) # noqa: T001 return now # ---------------------------------------------------------------------------------------------------------------------- # Dash Helpers def parse_dash_cli_args (): # pragma: no cover \"\"\"Configure the CLI options for Dash applications. Returns: dict: keyword arguments for Dash \"\"\" parser = argparse . ArgumentParser ( description = 'Process Dash Parameters.' ) parser . add_argument ( '--port' , type = int , default = 8050 , help = 'Pass port number to Dash server. Default is 8050' , ) parser . add_argument ( '--nodebug' , action = 'store_true' , default = False , help = 'If set, will disable debug mode. Default is to set `debug=True`' , ) args = parser . parse_args () return { 'port' : args . port , 'debug' : not args . nodebug } # ---------------------------------------------------------------------------------------------------------------------- # Functional Programming def graph_return ( resp , keys ): \"\"\"Based on concepts of GraphQL, return specified subset of response. Args: resp: dictionary with values from function keys: list of keynames from the resp dictionary Returns: the `resp` dictionary with only the keys specified in the `keys` list Raises: RuntimeError: if `keys` is not a list or tuple \"\"\" if not ( len ( keys ) and isinstance ( keys , ( list , tuple ))): raise RuntimeError ( f 'Expected list of keys for: ` { resp . items () } `, but received ` { keys } `' ) ordered_responses = [ resp . get ( key , None ) for key in keys ] return ordered_responses if len ( ordered_responses ) > 1 else ordered_responses [ 0 ] Functions \u2693\ufe0e debug_time \u2693\ufe0e def debug_time ( message : str , last : Union [ datetime . datetime , NoneType ] = None ) -> datetime . datetime Debug timing issues. Parameters: Name Description message string message to print last last timestamp Returns: Type Description timestamp the current timestamp to calculate the next delta View Source @beartype def debug_time ( message : str , last : Optional [ datetime ] = None ) -> datetime : \"\"\"Debug timing issues. Args: message: string message to print last: last timestamp Returns: timestamp: the current timestamp to calculate the next delta \"\"\" if last is None : last = time . time () now = time . time () delta = now - last if delta > 0.5 : print ( message , delta ) # noqa: T001 return now graph_return \u2693\ufe0e def graph_return ( resp , keys ) Based on concepts of GraphQL, return specified subset of response. Parameters: Name Description resp dictionary with values from function keys list of keynames from the resp dictionary Returns: Type Description None the resp dictionary with only the keys specified in the keys list Raises: Type Description RuntimeError if keys is not a list or tuple View Source def graph_return ( resp , keys ): \"\"\"Based on concepts of GraphQL, return specified subset of response. Args: resp: dictionary with values from function keys: list of keynames from the resp dictionary Returns: the `resp` dictionary with only the keys specified in the `keys` list Raises: RuntimeError: if `keys` is not a list or tuple \"\"\" if not ( len ( keys ) and isinstance ( keys , ( list , tuple ))): raise RuntimeError ( f 'Expected list of keys for: ` { resp . items () } `, but received ` { keys } `' ) ordered_responses = [ resp . get ( key , None ) for key in keys ] return ordered_responses if len ( ordered_responses ) > 1 else ordered_responses [ 0 ] parse_dash_cli_args \u2693\ufe0e def parse_dash_cli_args () Configure the CLI options for Dash applications. Returns: Type Description dict keyword arguments for Dash View Source def parse_dash_cli_args (): # pragma: no cover \"\"\"Configure the CLI options for Dash applications. Returns: dict: keyword arguments for Dash \"\"\" parser = argparse . ArgumentParser ( description = 'Process Dash Parameters.' ) parser . add_argument ( '--port' , type = int , default = 8050 , help = 'Pass port number to Dash server. Default is 8050' , ) parser . add_argument ( '--nodebug' , action = 'store_true' , default = False , help = 'If set, will disable debug mode. Default is to set `debug=True`' , ) args = parser . parse_args () return { 'port' : args . port , 'debug' : not args . nodebug }","title":"dash_charts.utils_helpers"},{"location":"modules/dash_charts/utils_helpers/#dash_chartsutils_helpers","text":"Helpers for building Dash applications. View Source \"\"\"Helpers for building Dash applications.\"\"\" import argparse import time from datetime import datetime from typing import Optional from beartype import beartype # ---------------------------------------------------------------------------------------------------------------------- # General Debug @beartype def debug_time ( message : str , last : Optional [ datetime ] = None ) -> datetime : \"\"\"Debug timing issues. Args: message: string message to print last: last timestamp Returns: timestamp: the current timestamp to calculate the next delta \"\"\" if last is None : last = time . time () now = time . time () delta = now - last if delta > 0.5 : print ( message , delta ) # noqa: T001 return now # ---------------------------------------------------------------------------------------------------------------------- # Dash Helpers def parse_dash_cli_args (): # pragma: no cover \"\"\"Configure the CLI options for Dash applications. Returns: dict: keyword arguments for Dash \"\"\" parser = argparse . ArgumentParser ( description = 'Process Dash Parameters.' ) parser . add_argument ( '--port' , type = int , default = 8050 , help = 'Pass port number to Dash server. Default is 8050' , ) parser . add_argument ( '--nodebug' , action = 'store_true' , default = False , help = 'If set, will disable debug mode. Default is to set `debug=True`' , ) args = parser . parse_args () return { 'port' : args . port , 'debug' : not args . nodebug } # ---------------------------------------------------------------------------------------------------------------------- # Functional Programming def graph_return ( resp , keys ): \"\"\"Based on concepts of GraphQL, return specified subset of response. Args: resp: dictionary with values from function keys: list of keynames from the resp dictionary Returns: the `resp` dictionary with only the keys specified in the `keys` list Raises: RuntimeError: if `keys` is not a list or tuple \"\"\" if not ( len ( keys ) and isinstance ( keys , ( list , tuple ))): raise RuntimeError ( f 'Expected list of keys for: ` { resp . items () } `, but received ` { keys } `' ) ordered_responses = [ resp . get ( key , None ) for key in keys ] return ordered_responses if len ( ordered_responses ) > 1 else ordered_responses [ 0 ]","title":"dash_charts.utils_helpers"},{"location":"modules/dash_charts/utils_helpers/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_helpers/#debug_time","text":"def debug_time ( message : str , last : Union [ datetime . datetime , NoneType ] = None ) -> datetime . datetime Debug timing issues. Parameters: Name Description message string message to print last last timestamp Returns: Type Description timestamp the current timestamp to calculate the next delta View Source @beartype def debug_time ( message : str , last : Optional [ datetime ] = None ) -> datetime : \"\"\"Debug timing issues. Args: message: string message to print last: last timestamp Returns: timestamp: the current timestamp to calculate the next delta \"\"\" if last is None : last = time . time () now = time . time () delta = now - last if delta > 0.5 : print ( message , delta ) # noqa: T001 return now","title":"debug_time"},{"location":"modules/dash_charts/utils_helpers/#graph_return","text":"def graph_return ( resp , keys ) Based on concepts of GraphQL, return specified subset of response. Parameters: Name Description resp dictionary with values from function keys list of keynames from the resp dictionary Returns: Type Description None the resp dictionary with only the keys specified in the keys list Raises: Type Description RuntimeError if keys is not a list or tuple View Source def graph_return ( resp , keys ): \"\"\"Based on concepts of GraphQL, return specified subset of response. Args: resp: dictionary with values from function keys: list of keynames from the resp dictionary Returns: the `resp` dictionary with only the keys specified in the `keys` list Raises: RuntimeError: if `keys` is not a list or tuple \"\"\" if not ( len ( keys ) and isinstance ( keys , ( list , tuple ))): raise RuntimeError ( f 'Expected list of keys for: ` { resp . items () } `, but received ` { keys } `' ) ordered_responses = [ resp . get ( key , None ) for key in keys ] return ordered_responses if len ( ordered_responses ) > 1 else ordered_responses [ 0 ]","title":"graph_return"},{"location":"modules/dash_charts/utils_helpers/#parse_dash_cli_args","text":"def parse_dash_cli_args () Configure the CLI options for Dash applications. Returns: Type Description dict keyword arguments for Dash View Source def parse_dash_cli_args (): # pragma: no cover \"\"\"Configure the CLI options for Dash applications. Returns: dict: keyword arguments for Dash \"\"\" parser = argparse . ArgumentParser ( description = 'Process Dash Parameters.' ) parser . add_argument ( '--port' , type = int , default = 8050 , help = 'Pass port number to Dash server. Default is 8050' , ) parser . add_argument ( '--nodebug' , action = 'store_true' , default = False , help = 'If set, will disable debug mode. Default is to set `debug=True`' , ) args = parser . parse_args () return { 'port' : args . port , 'debug' : not args . nodebug }","title":"parse_dash_cli_args"},{"location":"modules/dash_charts/utils_json_cache/","text":"dash_charts.utils_json_cache \u2693\ufe0e Helpers for managing a generic JSON data file cache. Can be used to reduce API calls, etc. Full dataset documentation: https://dataset.readthedocs.io/en/latest/api.html View Source \"\"\"Helpers for managing a generic JSON data file cache. Can be used to reduce API calls, etc. Full dataset documentation: https://dataset.readthedocs.io/en/latest/api.html \"\"\" import json import time from pathlib import Path from .utils_data import uniq_table_id , write_pretty_json from .utils_dataset import DBConnect # FIXME: Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ CACHE_DIR = Path ( __file__ ) . parent / 'local_cache' \"\"\"Path to folder with all downloaded responses from Kitsu API.\"\"\" FILE_DATA = DBConnect ( CACHE_DIR / '_file_lookup_database.db' ) \"\"\"Global instance of the DBConnect() for the file lookup database.\"\"\" CACHE_TABLE_NAME = 'files' \"\"\"Table name containing the cache file information.\"\"\" ID_KEY = 'identifier' \"\"\"Name of the SQLite column containing the unique identifier.\"\"\" TS_KEY = 'timestamp' \"\"\"Name of the SQLite column containing the timestamp.\"\"\" FILENAME_KEY = 'filename' \"\"\"Name of the SQLite column containing the string filename.\"\"\" # TODO: Enable versioning of data and automatic deletion when the version changes DATA_VERSION_KEY = 'data_version' \"\"\"Key to indicate the data version.\"\"\" def get_files_table ( db_instance ): \"\"\"Retrieve stored object from cache database. Args: db_instance: Connected Database file with `DBConnect()`. Returns: table: Dataset table for the files lookup \"\"\" return db_instance . db . load_table ( CACHE_TABLE_NAME ) def initialize_cache ( db_instance ): \"\"\"Ensure that the directory and database exist. Remove files from database if manually removed. Args: db_instance: Connected Database file with `DBConnect()`. \"\"\" table = db_instance . db . create_table ( CACHE_TABLE_NAME ) removed_files = [] for row in table : if not Path ( row [ FILENAME_KEY ]) . is_file (): removed_files . append ( row [ FILENAME_KEY ]) for filename in removed_files : table . delete ( filename = filename ) def get_cache_dict ( db_instance ): \"\"\"Return a dictionary `{identifier: path}` keys and values. Args: db_instance: Connected Database file with `DBConnect()`. Returns: dict: dictionary `{identifier: path}` keys and values \"\"\" table = get_files_table ( db_instance ) return { row [ ID_KEY ]: Path ( row [ FILENAME_KEY ]) for row in table } def match_identifier_in_cache ( identifier , db_instance ): \"\"\"Return list of matches for the given identifier in the file database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: list: list of match object with keys of the SQL table \"\"\" kwargs = { ID_KEY : identifier } return [ * get_files_table ( db_instance ) . find ( ** kwargs )] def store_cache_as_file ( prefix , identifier , db_instance , cache_dir = CACHE_DIR , suffix = '.json' ): \"\"\"Store the reference in the cache database and return the file so the user can handle saving the file. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR suffix: string filename suffix. The default is `.json` Returns: Path: to the cached file. Caller needs to write to the file Raises: RuntimeError: if duplicate match found when storing \"\"\" # Check that the identifier isn't already in the database matches = match_identifier_in_cache ( identifier , db_instance ) if matches : raise RuntimeError ( f 'Already have an entry for this identifier (` { identifier } `): { matches } ' ) # Update the database and store the file filename = cache_dir / f ' { prefix } _ { uniq_table_id () }{ suffix } ' new_row = { FILENAME_KEY : str ( filename ), ID_KEY : identifier , TS_KEY : time . time ()} get_files_table ( db_instance ) . insert ( new_row ) return filename def store_cache_object ( prefix , identifier , obj , db_instance , cache_dir = CACHE_DIR ): \"\"\"Store the object as a JSON file and track in a SQLite database to prevent duplicates. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached obj: JSON object to write db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR Raises: Exception: if duplicate match found when storing \"\"\" filename = store_cache_as_file ( prefix , identifier , db_instance , cache_dir ) try : write_pretty_json ( filename , obj ) except Exception : # If writing the file fails, ensure that the record is removed from the database get_files_table ( db_instance ) . delete ( filename = filename ) raise def retrieve_cache_fn ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: Path: to the cached file. Caller needs to read the file Raises: RuntimeError: if not exactly one match found \"\"\" matches = match_identifier_in_cache ( identifier , db_instance ) if len ( matches ) != 1 : raise RuntimeError ( f 'Did not find exactly one entry for this identifier (` { identifier } `): { matches } ' ) return Path ( matches [ 0 ][ FILENAME_KEY ]) def retrieve_cache_object ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: dict: object stored in the cache \"\"\" filename = retrieve_cache_fn ( identifier , db_instance ) return json . loads ( filename . read_text ()) Variables \u2693\ufe0e CACHE_DIR Path to folder with all downloaded responses from Kitsu API. CACHE_TABLE_NAME Table name containing the cache file information. DATA_VERSION_KEY Key to indicate the data version. FILENAME_KEY Name of the SQLite column containing the string filename. FILE_DATA Global instance of the DBConnect() for the file lookup database. ID_KEY Name of the SQLite column containing the unique identifier. TS_KEY Name of the SQLite column containing the timestamp. Functions \u2693\ufe0e get_cache_dict \u2693\ufe0e def get_cache_dict ( db_instance ) Return a dictionary {identifier: path} keys and values. Parameters: Name Description db_instance Connected Database file with DBConnect() . Returns: Type Description dict dictionary {identifier: path} keys and values View Source def get_cache_dict ( db_instance ): \"\"\"Return a dictionary `{identifier: path}` keys and values. Args: db_instance: Connected Database file with `DBConnect()`. Returns: dict: dictionary `{identifier: path}` keys and values \"\"\" table = get_files_table ( db_instance ) return { row [ ID_KEY ]: Path ( row [ FILENAME_KEY ]) for row in table } get_files_table \u2693\ufe0e def get_files_table ( db_instance ) Retrieve stored object from cache database. Parameters: Name Description db_instance Connected Database file with DBConnect() . Returns: Type Description table Dataset table for the files lookup View Source def get_files_table ( db_instance ): \"\"\"Retrieve stored object from cache database. Args: db_instance: Connected Database file with `DBConnect()`. Returns: table: Dataset table for the files lookup \"\"\" return db_instance . db . load_table ( CACHE_TABLE_NAME ) initialize_cache \u2693\ufe0e def initialize_cache ( db_instance ) Ensure that the directory and database exist. Remove files from database if manually removed. Parameters: Name Description db_instance Connected Database file with DBConnect() . View Source def initialize_cache ( db_instance ): \"\"\"Ensure that the directory and database exist. Remove files from database if manually removed. Args: db_instance: Connected Database file with `DBConnect()`. \"\"\" table = db_instance . db . create_table ( CACHE_TABLE_NAME ) removed_files = [] for row in table : if not Path ( row [ FILENAME_KEY ]) . is_file (): removed_files . append ( row [ FILENAME_KEY ]) for filename in removed_files : table . delete ( filename = filename ) match_identifier_in_cache \u2693\ufe0e def match_identifier_in_cache ( identifier , db_instance ) Return list of matches for the given identifier in the file database. Parameters: Name Description identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . Returns: Type Description list list of match object with keys of the SQL table View Source def match_identifier_in_cache ( identifier , db_instance ): \"\"\"Return list of matches for the given identifier in the file database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: list: list of match object with keys of the SQL table \"\"\" kwargs = { ID_KEY : identifier } return [ * get_files_table ( db_instance ) . find ( ** kwargs )] retrieve_cache_fn \u2693\ufe0e def retrieve_cache_fn ( identifier , db_instance ) Retrieve stored object from cache database. Parameters: Name Description identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . Returns: Type Description Path to the cached file. Caller needs to read the file Raises: Type Description RuntimeError if not exactly one match found View Source def retrieve_cache_fn ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: Path: to the cached file. Caller needs to read the file Raises: RuntimeError: if not exactly one match found \"\"\" matches = match_identifier_in_cache ( identifier , db_instance ) if len ( matches ) != 1 : raise RuntimeError ( f 'Did not find exactly one entry for this identifier (` { identifier } `): { matches } ' ) return Path ( matches [ 0 ][ FILENAME_KEY ]) retrieve_cache_object \u2693\ufe0e def retrieve_cache_object ( identifier , db_instance ) Retrieve stored object from cache database. Parameters: Name Description identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . Returns: Type Description dict object stored in the cache View Source def retrieve_cache_object ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: dict: object stored in the cache \"\"\" filename = retrieve_cache_fn ( identifier , db_instance ) return json . loads ( filename . read_text ()) store_cache_as_file \u2693\ufe0e def store_cache_as_file ( prefix , identifier , db_instance , cache_dir = PosixPath ( '/Users/kyleking/Developer/packages/dash_charts/dash_charts/local_cache' ), suffix = '.json' ) Store the reference in the cache database and return the file so the user can handle saving the file. Parameters: Name Description prefix string used to create more recognizable filenames identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . cache_dir path to the directory to store the file. Default is `CACHE_DIR suffix string filename suffix. The default is .json Returns: Type Description Path to the cached file. Caller needs to write to the file Raises: Type Description RuntimeError if duplicate match found when storing View Source def store_cache_as_file ( prefix , identifier , db_instance , cache_dir = CACHE_DIR , suffix = '.json' ): \"\"\"Store the reference in the cache database and return the file so the user can handle saving the file. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR suffix: string filename suffix. The default is `.json` Returns: Path: to the cached file. Caller needs to write to the file Raises: RuntimeError: if duplicate match found when storing \"\"\" # Check that the identifier isn't already in the database matches = match_identifier_in_cache ( identifier , db_instance ) if matches : raise RuntimeError ( f 'Already have an entry for this identifier (` { identifier } `): { matches } ' ) # Update the database and store the file filename = cache_dir / f ' { prefix } _ { uniq_table_id () }{ suffix } ' new_row = { FILENAME_KEY : str ( filename ), ID_KEY : identifier , TS_KEY : time . time ()} get_files_table ( db_instance ) . insert ( new_row ) return filename store_cache_object \u2693\ufe0e def store_cache_object ( prefix , identifier , obj , db_instance , cache_dir = PosixPath ( '/Users/kyleking/Developer/packages/dash_charts/dash_charts/local_cache' ) ) Store the object as a JSON file and track in a SQLite database to prevent duplicates. Parameters: Name Description prefix string used to create more recognizable filenames identifier identifier to use as a reference if the corresponding data is already cached obj JSON object to write db_instance Connected Database file with DBConnect() . cache_dir path to the directory to store the file. Default is `CACHE_DIR Raises: Type Description Exception if duplicate match found when storing View Source def store_cache_object ( prefix , identifier , obj , db_instance , cache_dir = CACHE_DIR ): \"\"\"Store the object as a JSON file and track in a SQLite database to prevent duplicates. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached obj: JSON object to write db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR Raises: Exception: if duplicate match found when storing \"\"\" filename = store_cache_as_file ( prefix , identifier , db_instance , cache_dir ) try : write_pretty_json ( filename , obj ) except Exception : # If writing the file fails, ensure that the record is removed from the database get_files_table ( db_instance ) . delete ( filename = filename ) raise","title":"dash_charts.utils_json_cache"},{"location":"modules/dash_charts/utils_json_cache/#dash_chartsutils_json_cache","text":"Helpers for managing a generic JSON data file cache. Can be used to reduce API calls, etc. Full dataset documentation: https://dataset.readthedocs.io/en/latest/api.html View Source \"\"\"Helpers for managing a generic JSON data file cache. Can be used to reduce API calls, etc. Full dataset documentation: https://dataset.readthedocs.io/en/latest/api.html \"\"\" import json import time from pathlib import Path from .utils_data import uniq_table_id , write_pretty_json from .utils_dataset import DBConnect # FIXME: Add versioning to the cache directory with semver logic: https://pypi.org/project/semantic-version/ CACHE_DIR = Path ( __file__ ) . parent / 'local_cache' \"\"\"Path to folder with all downloaded responses from Kitsu API.\"\"\" FILE_DATA = DBConnect ( CACHE_DIR / '_file_lookup_database.db' ) \"\"\"Global instance of the DBConnect() for the file lookup database.\"\"\" CACHE_TABLE_NAME = 'files' \"\"\"Table name containing the cache file information.\"\"\" ID_KEY = 'identifier' \"\"\"Name of the SQLite column containing the unique identifier.\"\"\" TS_KEY = 'timestamp' \"\"\"Name of the SQLite column containing the timestamp.\"\"\" FILENAME_KEY = 'filename' \"\"\"Name of the SQLite column containing the string filename.\"\"\" # TODO: Enable versioning of data and automatic deletion when the version changes DATA_VERSION_KEY = 'data_version' \"\"\"Key to indicate the data version.\"\"\" def get_files_table ( db_instance ): \"\"\"Retrieve stored object from cache database. Args: db_instance: Connected Database file with `DBConnect()`. Returns: table: Dataset table for the files lookup \"\"\" return db_instance . db . load_table ( CACHE_TABLE_NAME ) def initialize_cache ( db_instance ): \"\"\"Ensure that the directory and database exist. Remove files from database if manually removed. Args: db_instance: Connected Database file with `DBConnect()`. \"\"\" table = db_instance . db . create_table ( CACHE_TABLE_NAME ) removed_files = [] for row in table : if not Path ( row [ FILENAME_KEY ]) . is_file (): removed_files . append ( row [ FILENAME_KEY ]) for filename in removed_files : table . delete ( filename = filename ) def get_cache_dict ( db_instance ): \"\"\"Return a dictionary `{identifier: path}` keys and values. Args: db_instance: Connected Database file with `DBConnect()`. Returns: dict: dictionary `{identifier: path}` keys and values \"\"\" table = get_files_table ( db_instance ) return { row [ ID_KEY ]: Path ( row [ FILENAME_KEY ]) for row in table } def match_identifier_in_cache ( identifier , db_instance ): \"\"\"Return list of matches for the given identifier in the file database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: list: list of match object with keys of the SQL table \"\"\" kwargs = { ID_KEY : identifier } return [ * get_files_table ( db_instance ) . find ( ** kwargs )] def store_cache_as_file ( prefix , identifier , db_instance , cache_dir = CACHE_DIR , suffix = '.json' ): \"\"\"Store the reference in the cache database and return the file so the user can handle saving the file. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR suffix: string filename suffix. The default is `.json` Returns: Path: to the cached file. Caller needs to write to the file Raises: RuntimeError: if duplicate match found when storing \"\"\" # Check that the identifier isn't already in the database matches = match_identifier_in_cache ( identifier , db_instance ) if matches : raise RuntimeError ( f 'Already have an entry for this identifier (` { identifier } `): { matches } ' ) # Update the database and store the file filename = cache_dir / f ' { prefix } _ { uniq_table_id () }{ suffix } ' new_row = { FILENAME_KEY : str ( filename ), ID_KEY : identifier , TS_KEY : time . time ()} get_files_table ( db_instance ) . insert ( new_row ) return filename def store_cache_object ( prefix , identifier , obj , db_instance , cache_dir = CACHE_DIR ): \"\"\"Store the object as a JSON file and track in a SQLite database to prevent duplicates. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached obj: JSON object to write db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR Raises: Exception: if duplicate match found when storing \"\"\" filename = store_cache_as_file ( prefix , identifier , db_instance , cache_dir ) try : write_pretty_json ( filename , obj ) except Exception : # If writing the file fails, ensure that the record is removed from the database get_files_table ( db_instance ) . delete ( filename = filename ) raise def retrieve_cache_fn ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: Path: to the cached file. Caller needs to read the file Raises: RuntimeError: if not exactly one match found \"\"\" matches = match_identifier_in_cache ( identifier , db_instance ) if len ( matches ) != 1 : raise RuntimeError ( f 'Did not find exactly one entry for this identifier (` { identifier } `): { matches } ' ) return Path ( matches [ 0 ][ FILENAME_KEY ]) def retrieve_cache_object ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: dict: object stored in the cache \"\"\" filename = retrieve_cache_fn ( identifier , db_instance ) return json . loads ( filename . read_text ())","title":"dash_charts.utils_json_cache"},{"location":"modules/dash_charts/utils_json_cache/#variables","text":"CACHE_DIR Path to folder with all downloaded responses from Kitsu API. CACHE_TABLE_NAME Table name containing the cache file information. DATA_VERSION_KEY Key to indicate the data version. FILENAME_KEY Name of the SQLite column containing the string filename. FILE_DATA Global instance of the DBConnect() for the file lookup database. ID_KEY Name of the SQLite column containing the unique identifier. TS_KEY Name of the SQLite column containing the timestamp.","title":"Variables"},{"location":"modules/dash_charts/utils_json_cache/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_json_cache/#get_cache_dict","text":"def get_cache_dict ( db_instance ) Return a dictionary {identifier: path} keys and values. Parameters: Name Description db_instance Connected Database file with DBConnect() . Returns: Type Description dict dictionary {identifier: path} keys and values View Source def get_cache_dict ( db_instance ): \"\"\"Return a dictionary `{identifier: path}` keys and values. Args: db_instance: Connected Database file with `DBConnect()`. Returns: dict: dictionary `{identifier: path}` keys and values \"\"\" table = get_files_table ( db_instance ) return { row [ ID_KEY ]: Path ( row [ FILENAME_KEY ]) for row in table }","title":"get_cache_dict"},{"location":"modules/dash_charts/utils_json_cache/#get_files_table","text":"def get_files_table ( db_instance ) Retrieve stored object from cache database. Parameters: Name Description db_instance Connected Database file with DBConnect() . Returns: Type Description table Dataset table for the files lookup View Source def get_files_table ( db_instance ): \"\"\"Retrieve stored object from cache database. Args: db_instance: Connected Database file with `DBConnect()`. Returns: table: Dataset table for the files lookup \"\"\" return db_instance . db . load_table ( CACHE_TABLE_NAME )","title":"get_files_table"},{"location":"modules/dash_charts/utils_json_cache/#initialize_cache","text":"def initialize_cache ( db_instance ) Ensure that the directory and database exist. Remove files from database if manually removed. Parameters: Name Description db_instance Connected Database file with DBConnect() . View Source def initialize_cache ( db_instance ): \"\"\"Ensure that the directory and database exist. Remove files from database if manually removed. Args: db_instance: Connected Database file with `DBConnect()`. \"\"\" table = db_instance . db . create_table ( CACHE_TABLE_NAME ) removed_files = [] for row in table : if not Path ( row [ FILENAME_KEY ]) . is_file (): removed_files . append ( row [ FILENAME_KEY ]) for filename in removed_files : table . delete ( filename = filename )","title":"initialize_cache"},{"location":"modules/dash_charts/utils_json_cache/#match_identifier_in_cache","text":"def match_identifier_in_cache ( identifier , db_instance ) Return list of matches for the given identifier in the file database. Parameters: Name Description identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . Returns: Type Description list list of match object with keys of the SQL table View Source def match_identifier_in_cache ( identifier , db_instance ): \"\"\"Return list of matches for the given identifier in the file database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: list: list of match object with keys of the SQL table \"\"\" kwargs = { ID_KEY : identifier } return [ * get_files_table ( db_instance ) . find ( ** kwargs )]","title":"match_identifier_in_cache"},{"location":"modules/dash_charts/utils_json_cache/#retrieve_cache_fn","text":"def retrieve_cache_fn ( identifier , db_instance ) Retrieve stored object from cache database. Parameters: Name Description identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . Returns: Type Description Path to the cached file. Caller needs to read the file Raises: Type Description RuntimeError if not exactly one match found View Source def retrieve_cache_fn ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: Path: to the cached file. Caller needs to read the file Raises: RuntimeError: if not exactly one match found \"\"\" matches = match_identifier_in_cache ( identifier , db_instance ) if len ( matches ) != 1 : raise RuntimeError ( f 'Did not find exactly one entry for this identifier (` { identifier } `): { matches } ' ) return Path ( matches [ 0 ][ FILENAME_KEY ])","title":"retrieve_cache_fn"},{"location":"modules/dash_charts/utils_json_cache/#retrieve_cache_object","text":"def retrieve_cache_object ( identifier , db_instance ) Retrieve stored object from cache database. Parameters: Name Description identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . Returns: Type Description dict object stored in the cache View Source def retrieve_cache_object ( identifier , db_instance ): \"\"\"Retrieve stored object from cache database. Args: identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. Returns: dict: object stored in the cache \"\"\" filename = retrieve_cache_fn ( identifier , db_instance ) return json . loads ( filename . read_text ())","title":"retrieve_cache_object"},{"location":"modules/dash_charts/utils_json_cache/#store_cache_as_file","text":"def store_cache_as_file ( prefix , identifier , db_instance , cache_dir = PosixPath ( '/Users/kyleking/Developer/packages/dash_charts/dash_charts/local_cache' ), suffix = '.json' ) Store the reference in the cache database and return the file so the user can handle saving the file. Parameters: Name Description prefix string used to create more recognizable filenames identifier identifier to use as a reference if the corresponding data is already cached db_instance Connected Database file with DBConnect() . cache_dir path to the directory to store the file. Default is `CACHE_DIR suffix string filename suffix. The default is .json Returns: Type Description Path to the cached file. Caller needs to write to the file Raises: Type Description RuntimeError if duplicate match found when storing View Source def store_cache_as_file ( prefix , identifier , db_instance , cache_dir = CACHE_DIR , suffix = '.json' ): \"\"\"Store the reference in the cache database and return the file so the user can handle saving the file. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR suffix: string filename suffix. The default is `.json` Returns: Path: to the cached file. Caller needs to write to the file Raises: RuntimeError: if duplicate match found when storing \"\"\" # Check that the identifier isn't already in the database matches = match_identifier_in_cache ( identifier , db_instance ) if matches : raise RuntimeError ( f 'Already have an entry for this identifier (` { identifier } `): { matches } ' ) # Update the database and store the file filename = cache_dir / f ' { prefix } _ { uniq_table_id () }{ suffix } ' new_row = { FILENAME_KEY : str ( filename ), ID_KEY : identifier , TS_KEY : time . time ()} get_files_table ( db_instance ) . insert ( new_row ) return filename","title":"store_cache_as_file"},{"location":"modules/dash_charts/utils_json_cache/#store_cache_object","text":"def store_cache_object ( prefix , identifier , obj , db_instance , cache_dir = PosixPath ( '/Users/kyleking/Developer/packages/dash_charts/dash_charts/local_cache' ) ) Store the object as a JSON file and track in a SQLite database to prevent duplicates. Parameters: Name Description prefix string used to create more recognizable filenames identifier identifier to use as a reference if the corresponding data is already cached obj JSON object to write db_instance Connected Database file with DBConnect() . cache_dir path to the directory to store the file. Default is `CACHE_DIR Raises: Type Description Exception if duplicate match found when storing View Source def store_cache_object ( prefix , identifier , obj , db_instance , cache_dir = CACHE_DIR ): \"\"\"Store the object as a JSON file and track in a SQLite database to prevent duplicates. Args: prefix: string used to create more recognizable filenames identifier: identifier to use as a reference if the corresponding data is already cached obj: JSON object to write db_instance: Connected Database file with `DBConnect()`. cache_dir: path to the directory to store the file. Default is `CACHE_DIR Raises: Exception: if duplicate match found when storing \"\"\" filename = store_cache_as_file ( prefix , identifier , db_instance , cache_dir ) try : write_pretty_json ( filename , obj ) except Exception : # If writing the file fails, ensure that the record is removed from the database get_files_table ( db_instance ) . delete ( filename = filename ) raise","title":"store_cache_object"},{"location":"modules/dash_charts/utils_static/","text":"dash_charts.utils_static \u2693\ufe0e Utilities for generating static HTML reports. View Source \"\"\"Utilities for generating static HTML reports.\"\"\" import io from base64 import b64encode import dash_bootstrap_components as dbc import dominate import markdown import pandas as pd import plotly.io from bs4 import BeautifulSoup from dominate import tags , util def write_div ( figure , path_or_file_object , is_div = True , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object is_div: if True (default) will override html_kwargs to only write the minimum HTML needed html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` \"\"\" for key in [ 'include_plotlyjs' , 'full_html' ]: if key not in html_kwargs and is_div : html_kwargs [ key ] = False plotly . io . write_html ( fig = figure , file = path_or_file_object , ** html_kwargs ) def make_div ( figure , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` Returns: str: HTML div \"\"\" with io . StringIO () as output : write_div ( figure , output , is_div = True , ** html_kwargs ) return output . getvalue () def add_image ( image_path , alt_text = None ): \"\"\"Write base64 image to HTML. Args: image_path: Path to image file and format will be read from file suffix. alt_text: alternate text. If None, will show the image filename Returns: str: HTML \"\"\" with open ( image_path , 'rb' ) as image_file : encoded_image = b64encode ( image_file . read ()) . decode () image_uri = f 'data:image/ { image_path . suffix [ 1 :] } ;base64, { encoded_image } ' return f '<img src=\" { image_uri } \" alt=\" { alt_text or image_path . name } \"/>' def add_video ( video_path , alt_text = None ): \"\"\"Write base64 video to HTML. Video formats can easily be converted with ffmpeg: `ffmpeg -i video_filename.mov video_filename.webm` Args: video_path: Path to video file and format will be read from file suffix. Video should be in webm format alt_text: alternate text. If None, will show the video filename Returns: str: HTML video tag \"\"\" with open ( video_path , 'rb' ) as video_file : encoded_video = b64encode ( video_file . read ()) . decode () video_uri = f 'data:video/ { video_path . suffix [ 1 :] } ;base64, { encoded_video } ' return f '<video src=\" { video_uri } \" controls> { alt_text or video_path . name } </video>' def write_image_file ( figure , path_or_file_object , image_format , ** img_kwargs ): \"\"\"Write Plotly figure as an image to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object image_format: one of `(png, jpg, jpeg, webp, svg, pdf)` img_kwargs: additional keyword arguments passed to `plotly.io.write_image()` \"\"\" plotly . io . write_image ( fig = figure , file = str ( path_or_file_object ), format = image_format , ** img_kwargs ) def capture_plotly_body (): \"\"\"Return HTML body that includes necessary scripts for Plotly and MathJax. Returns: tuple: of the top and the bottom HTML content \"\"\" # Capture necessary Plotly boilerplate HTML with io . StringIO () as output : write_div ({}, output , is_div = False , include_mathjax = '.js' , validate = False ) blank_plotly = BeautifulSoup ( output . getvalue (), features = 'lxml' ) # Remove the empty figure div and corresponding script plot_div = blank_plotly . find ( 'div' , attrs = { 'class' : 'plotly-graph-div' }) for script in blank_plotly . find_all ( 'script' )[:: - 1 ]: # Use the ID from the plot to identify which script needs to be removed if plot_div . attrs [ 'id' ] in script . prettify (): script . decompose () break plot_div . decompose () return blank_plotly . body . prettify () def format_plotly_boilerplate ( ** doc_kwargs ): \"\"\"Initialize a boilerplate dominate document for creating static Plotly HTML files. See dominate documentation: https://pypi.org/project/dominate/ Args: doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" doc = dominate . document ( ** doc_kwargs ) with doc : util . raw ( capture_plotly_body ()) return doc def create_dbc_doc ( theme = dbc . themes . BOOTSTRAP , custom_styles = '' , ** doc_kwargs ): \"\"\"Create boilerplate dominate document with Bootstrap and Plotly for static HTML. Based on: https://github.com/facultyai/dash-bootstrap-components/tree/master/docs/templates/partials See dominate documentation: https://pypi.org/project/dominate/ Args: theme: string URL to CSS for theming Bootstrap. Default is `dbc.themes.BOOTSTRAP` custom_styles: optional custom CSS to add to file. Default is blank (`''`) doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" stylesheets = [ { 'href' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/styles/a11y-light.min.css' }, { 'href' : theme }, ] scripts = [ { 'src' : 'https://code.jquery.com/jquery-3.4.1.slim.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js' }, { 'src' : 'https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/highlight.min.js' }, ] doc = format_plotly_boilerplate ( ** doc_kwargs ) with doc . head : tags . meta ( charset = 'utf-8' ) tags . meta ( name = 'viewport' , content = 'width=device-width, initial-scale=1' ) for sheet_kwargs in stylesheets : tags . link ( rel = 'stylesheet' , ** sheet_kwargs ) util . raw ( f '<style> { custom_styles } </style>' ) for script_kwargs in scripts : tags . script ( ** script_kwargs ) util . raw ( '<script>hljs.initHighlightingOnLoad();</script>' ) return doc def tag_code ( text , language = '' ): \"\"\"Format HTML for a `pre.code` block with specified `hljs` language. Args: text: string to show in code block language: `hljs` language (ex: `'language-json'`). Default is `''`. \"\"\" tags . pre () . add ( tags . code ( text , _class = f ' { language } hljs' )) def tag_markdown ( text , ** markdown_kwargs ): \"\"\"Format markdown text as HTML. Args: text: markdown string markdown_kwargs: additional keyword arguments for `markdown.markdown`, such as `extensions` \"\"\" util . raw ( markdown . markdown ( text , ** markdown_kwargs )) def tag_table ( df_table , table_class = None ): \"\"\"Format HTML for a responsive Bootstrap table. See Bootstrap documentation at: https://getbootstrap.com/docs/4.4/content/tables/#tables Args: df_table: pandas dataframe to show in table table_class: string classes to add to table. If None, will use default string Raises: RuntimeError: if `df_table` is not a DataFrame object \"\"\" if table_class is None : table_class = 'table table-bordered table-striped table-hover' if not isinstance ( df_table , pd . core . frame . DataFrame ): raise RuntimeError ( f 'df_table is not a DataFrame ( { type ( df_table ) } ): \\n { df_table } ' ) df_table = df_table . reset_index () with tags . div ( _class = 'table-responsive' ) . add ( tags . table ( _class = table_class )): # Create header row with tags . thead () . add ( tags . tr ()): for col in df_table . columns : tags . th ( col ) # Create body rows with tags . tbody (): for row in df_table . itertuples ( index = False ): with tags . tr (): for value in row : tags . td ( str ( value )) def write_lookup ( key , function_lookup ): \"\"\"Determine the lookup result and add to the file. Args: key: string key for function lookup function_lookup: dictionary with either the string result or equation and arguments Raises: RuntimeError: if error in lookup dictionary \"\"\" try : match = function_lookup [ key ] except KeyError : raise RuntimeError ( f 'Could not find \" { key } \" in { function_lookup } ' ) if isinstance ( match , str ): util . raw ( match ) elif len ( match ) == 2 : fun , args = match result = fun ( * args ) if isinstance ( result , str ): util . raw ( result ) else : raise RuntimeError ( f 'Match failed for \" { key } \". Returned: { match } from { function_lookup } ' ) def markdown_machine ( lines , function_lookup ): # noqa: CCR001 \"\"\"Convert markdown text file into Plotly-HTML and write to doc context. Note: you will need a document with necessary boilerplate and call this within a `with doc:` dominate context Multiple Markdown files can then be put into a single HTML output file by calling this function with new lines and function lookup arguments Args: lines: list of text file lines function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` \"\"\" markdown_lines = [] for line in lines : if line . startswith ( '>>lookup:' ): # Write stored markdown and clear list. Then write the matched lookup tag_markdown ( ' \\n ' . join ( markdown_lines )) markdown_lines = [] write_lookup ( line . split ( '>>lookup:' )[ 1 ], function_lookup ) else : markdown_lines . append ( line ) if markdown_lines : tag_markdown ( ' \\n ' . join ( markdown_lines )) def write_from_markdown ( filename , function_lookup , ** dbc_kwargs ): \"\"\"Wrap markdown_machine to convert markdown to Bootstrap HTML. Args: filename: path to markdown file function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` dbc_kwargs: keyword arguments to pass to `create_dbc_doc` Returns: Path: created HTML filename \"\"\" lines = filename . read_text () . split ( ' \\n ' ) html_filename = filename . parent / f ' { filename . stem } .html' doc = create_dbc_doc ( ** dbc_kwargs ) with doc : with tags . div ( _class = 'container' ) . add ( tags . div ( _class = 'col' )): markdown_machine ( lines , function_lookup ) html_filename . write_text ( str ( doc )) return html_filename Functions \u2693\ufe0e add_image \u2693\ufe0e def add_image ( image_path , alt_text = None ) Write base64 image to HTML. Parameters: Name Description image_path Path to image file and format will be read from file suffix. alt_text alternate text. If None, will show the image filename Returns: Type Description str HTML View Source def add_image ( image_path , alt_text = None ): \"\"\"Write base64 image to HTML. Args: image_path: Path to image file and format will be read from file suffix. alt_text: alternate text. If None, will show the image filename Returns: str: HTML \"\"\" with open ( image_path , 'rb' ) as image_file : encoded_image = b64encode ( image_file . read ()) . decode () image_uri = f 'data:image/ { image_path . suffix [ 1 :] } ;base64, { encoded_image } ' return f '<img src=\" { image_uri } \" alt=\" { alt_text or image_path . name } \"/>' add_video \u2693\ufe0e def add_video ( video_path , alt_text = None ) Write base64 video to HTML. Video formats can easily be converted with ffmpeg: ffmpeg -i video_filename.mov video_filename.webm Parameters: Name Description video_path Path to video file and format will be read from file suffix. Video should be in webm format alt_text alternate text. If None, will show the video filename Returns: Type Description str HTML video tag View Source def add_video ( video_path , alt_text = None ): \"\"\"Write base64 video to HTML. Video formats can easily be converted with ffmpeg: `ffmpeg -i video_filename.mov video_filename.webm` Args: video_path: Path to video file and format will be read from file suffix. Video should be in webm format alt_text: alternate text. If None, will show the video filename Returns: str: HTML video tag \"\"\" with open ( video_path , 'rb' ) as video_file : encoded_video = b64encode ( video_file . read ()) . decode () video_uri = f 'data:video/ { video_path . suffix [ 1 :] } ;base64, { encoded_video } ' return f '<video src=\" { video_uri } \" controls> { alt_text or video_path . name } </video>' capture_plotly_body \u2693\ufe0e def capture_plotly_body () Return HTML body that includes necessary scripts for Plotly and MathJax. Returns: Type Description tuple of the top and the bottom HTML content View Source def capture_plotly_body (): \"\"\"Return HTML body that includes necessary scripts for Plotly and MathJax. Returns: tuple: of the top and the bottom HTML content \"\"\" # Capture necessary Plotly boilerplate HTML with io . StringIO () as output : write_div ({}, output , is_div = False , include_mathjax = '.js' , validate = False ) blank_plotly = BeautifulSoup ( output . getvalue (), features = 'lxml' ) # Remove the empty figure div and corresponding script plot_div = blank_plotly . find ( 'div' , attrs = { 'class' : 'plotly-graph-div' }) for script in blank_plotly . find_all ( 'script' )[:: - 1 ]: # Use the ID from the plot to identify which script needs to be removed if plot_div . attrs [ 'id' ] in script . prettify (): script . decompose () break plot_div . decompose () return blank_plotly . body . prettify () create_dbc_doc \u2693\ufe0e def create_dbc_doc ( theme = 'https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css' , custom_styles = '' , ** doc_kwargs ) Create boilerplate dominate document with Bootstrap and Plotly for static HTML. Based on: https://github.com/facultyai/dash-bootstrap-components/tree/master/docs/templates/partials See dominate documentation: https://pypi.org/project/dominate/ Parameters: Name Description theme string URL to CSS for theming Bootstrap. Default is dbc.themes.BOOTSTRAP custom_styles optional custom CSS to add to file. Default is blank ( '' ) doc_kwargs keyword arguments for dominate.document() Returns: Type Description dict dominate document instance View Source def create_dbc_doc ( theme = dbc . themes . BOOTSTRAP , custom_styles = '' , ** doc_kwargs ): \"\"\"Create boilerplate dominate document with Bootstrap and Plotly for static HTML. Based on: https://github.com/facultyai/dash-bootstrap-components/tree/master/docs/templates/partials See dominate documentation: https://pypi.org/project/dominate/ Args: theme: string URL to CSS for theming Bootstrap. Default is `dbc.themes.BOOTSTRAP` custom_styles: optional custom CSS to add to file. Default is blank (`''`) doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" stylesheets = [ { 'href' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/styles/a11y-light.min.css' }, { 'href' : theme }, ] scripts = [ { 'src' : 'https://code.jquery.com/jquery-3.4.1.slim.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js' }, { 'src' : 'https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/highlight.min.js' }, ] doc = format_plotly_boilerplate ( ** doc_kwargs ) with doc . head : tags . meta ( charset = 'utf-8' ) tags . meta ( name = 'viewport' , content = 'width=device-width, initial-scale=1' ) for sheet_kwargs in stylesheets : tags . link ( rel = 'stylesheet' , ** sheet_kwargs ) util . raw ( f '<style> { custom_styles } </style>' ) for script_kwargs in scripts : tags . script ( ** script_kwargs ) util . raw ( '<script>hljs.initHighlightingOnLoad();</script>' ) return doc format_plotly_boilerplate \u2693\ufe0e def format_plotly_boilerplate ( ** doc_kwargs ) Initialize a boilerplate dominate document for creating static Plotly HTML files. See dominate documentation: https://pypi.org/project/dominate/ Parameters: Name Description doc_kwargs keyword arguments for dominate.document() Returns: Type Description dict dominate document instance View Source def format_plotly_boilerplate ( ** doc_kwargs ): \"\"\"Initialize a boilerplate dominate document for creating static Plotly HTML files. See dominate documentation: https://pypi.org/project/dominate/ Args: doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" doc = dominate . document ( ** doc_kwargs ) with doc : util . raw ( capture_plotly_body ()) return doc make_div \u2693\ufe0e def make_div ( figure , ** html_kwargs ) Write Plotly figure as HTML to specified file. Parameters: Name Description figure Plotly figure (can be from create_figure for custom charts) html_kwargs additional keyword arguments passed to plotly.io.write_html() Returns: Type Description str HTML div View Source def make_div ( figure , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` Returns: str: HTML div \"\"\" with io . StringIO () as output : write_div ( figure , output , is_div = True , ** html_kwargs ) return output . getvalue () markdown_machine \u2693\ufe0e def markdown_machine ( lines , function_lookup ) Convert markdown text file into Plotly-HTML and write to doc context. Note: you will need a document with necessary boilerplate and call this within a with doc: dominate context Multiple Markdown files can then be put into a single HTML output file by calling this function with new lines and function lookup arguments Parameters: Name Description lines list of text file lines function_lookup dictionary with either the string result or equation and arguments Will be inserted into file where >>lookup:function_name assuming key of function_name View Source def markdown_machine ( lines , function_lookup ): # noqa: CCR001 \"\"\"Convert markdown text file into Plotly-HTML and write to doc context. Note: you will need a document with necessary boilerplate and call this within a `with doc:` dominate context Multiple Markdown files can then be put into a single HTML output file by calling this function with new lines and function lookup arguments Args: lines: list of text file lines function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` \"\"\" markdown_lines = [] for line in lines : if line . startswith ( '>>lookup:' ): # Write stored markdown and clear list. Then write the matched lookup tag_markdown ( ' \\n ' . join ( markdown_lines )) markdown_lines = [] write_lookup ( line . split ( '>>lookup:' )[ 1 ], function_lookup ) else : markdown_lines . append ( line ) if markdown_lines : tag_markdown ( ' \\n ' . join ( markdown_lines )) tag_code \u2693\ufe0e def tag_code ( text , language = '' ) Format HTML for a pre.code block with specified hljs language. Parameters: Name Description text string to show in code block language hljs language (ex: 'language-json' ). Default is '' . View Source def tag_code ( text , language = '' ): \"\"\"Format HTML for a `pre.code` block with specified `hljs` language. Args: text: string to show in code block language: `hljs` language (ex: `'language-json'`). Default is `''`. \"\"\" tags . pre () . add ( tags . code ( text , _class = f ' { language } hljs' )) tag_markdown \u2693\ufe0e def tag_markdown ( text , ** markdown_kwargs ) Format markdown text as HTML. Parameters: Name Description text markdown string markdown_kwargs additional keyword arguments for markdown.markdown , such as extensions View Source def tag_markdown ( text , ** markdown_kwargs ): \"\"\"Format markdown text as HTML. Args: text: markdown string markdown_kwargs: additional keyword arguments for `markdown.markdown`, such as `extensions` \"\"\" util . raw ( markdown . markdown ( text , ** markdown_kwargs )) tag_table \u2693\ufe0e def tag_table ( df_table , table_class = None ) Format HTML for a responsive Bootstrap table. See Bootstrap documentation at: https://getbootstrap.com/docs/4.4/content/tables/#tables Parameters: Name Description df_table pandas dataframe to show in table table_class string classes to add to table. If None, will use default string Raises: Type Description RuntimeError if df_table is not a DataFrame object View Source def tag_table ( df_table , table_class = None ): \"\"\"Format HTML for a responsive Bootstrap table. See Bootstrap documentation at: https://getbootstrap.com/docs/4.4/content/tables/#tables Args: df_table: pandas dataframe to show in table table_class: string classes to add to table. If None, will use default string Raises: RuntimeError: if `df_table` is not a DataFrame object \"\"\" if table_class is None : table_class = 'table table-bordered table-striped table-hover' if not isinstance ( df_table , pd . core . frame . DataFrame ): raise RuntimeError ( f 'df_table is not a DataFrame ( { type ( df_table ) } ): \\n { df_table } ' ) df_table = df_table . reset_index () with tags . div ( _class = 'table-responsive' ) . add ( tags . table ( _class = table_class )): # Create header row with tags . thead () . add ( tags . tr ()): for col in df_table . columns : tags . th ( col ) # Create body rows with tags . tbody (): for row in df_table . itertuples ( index = False ): with tags . tr (): for value in row : tags . td ( str ( value )) write_div \u2693\ufe0e def write_div ( figure , path_or_file_object , is_div = True , ** html_kwargs ) Write Plotly figure as HTML to specified file. Parameters: Name Description figure Plotly figure (can be from create_figure for custom charts) path_or_file_object string path or file object is_div if True (default) will override html_kwargs to only write the minimum HTML needed html_kwargs additional keyword arguments passed to plotly.io.write_html() View Source def write_div ( figure , path_or_file_object , is_div = True , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object is_div: if True (default) will override html_kwargs to only write the minimum HTML needed html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` \"\"\" for key in [ 'include_plotlyjs' , 'full_html' ]: if key not in html_kwargs and is_div : html_kwargs [ key ] = False plotly . io . write_html ( fig = figure , file = path_or_file_object , ** html_kwargs ) write_from_markdown \u2693\ufe0e def write_from_markdown ( filename , function_lookup , ** dbc_kwargs ) Wrap markdown_machine to convert markdown to Bootstrap HTML. Parameters: Name Description filename path to markdown file function_lookup dictionary with either the string result or equation and arguments Will be inserted into file where >>lookup:function_name assuming key of function_name dbc_kwargs keyword arguments to pass to create_dbc_doc Returns: Type Description Path created HTML filename View Source def write_from_markdown ( filename , function_lookup , ** dbc_kwargs ): \"\"\"Wrap markdown_machine to convert markdown to Bootstrap HTML. Args: filename: path to markdown file function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` dbc_kwargs: keyword arguments to pass to `create_dbc_doc` Returns: Path: created HTML filename \"\"\" lines = filename . read_text () . split ( ' \\n ' ) html_filename = filename . parent / f ' { filename . stem } .html' doc = create_dbc_doc ( ** dbc_kwargs ) with doc : with tags . div ( _class = 'container' ) . add ( tags . div ( _class = 'col' )): markdown_machine ( lines , function_lookup ) html_filename . write_text ( str ( doc )) return html_filename write_image_file \u2693\ufe0e def write_image_file ( figure , path_or_file_object , image_format , ** img_kwargs ) Write Plotly figure as an image to specified file. Parameters: Name Description figure Plotly figure (can be from create_figure for custom charts) path_or_file_object string path or file object image_format one of (png, jpg, jpeg, webp, svg, pdf) img_kwargs additional keyword arguments passed to plotly.io.write_image() View Source def write_image_file ( figure , path_or_file_object , image_format , ** img_kwargs ): \"\"\"Write Plotly figure as an image to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object image_format: one of `(png, jpg, jpeg, webp, svg, pdf)` img_kwargs: additional keyword arguments passed to `plotly.io.write_image()` \"\"\" plotly . io . write_image ( fig = figure , file = str ( path_or_file_object ), format = image_format , ** img_kwargs ) write_lookup \u2693\ufe0e def write_lookup ( key , function_lookup ) Determine the lookup result and add to the file. Parameters: Name Description key string key for function lookup function_lookup dictionary with either the string result or equation and arguments Raises: Type Description RuntimeError if error in lookup dictionary View Source def write_lookup ( key , function_lookup ): \"\"\"Determine the lookup result and add to the file. Args: key: string key for function lookup function_lookup: dictionary with either the string result or equation and arguments Raises: RuntimeError: if error in lookup dictionary \"\"\" try : match = function_lookup [ key ] except KeyError : raise RuntimeError ( f 'Could not find \" { key } \" in { function_lookup } ' ) if isinstance ( match , str ): util . raw ( match ) elif len ( match ) == 2 : fun , args = match result = fun ( * args ) if isinstance ( result , str ): util . raw ( result ) else : raise RuntimeError ( f 'Match failed for \" { key } \". Returned: { match } from { function_lookup } ' )","title":"dash_charts.utils_static"},{"location":"modules/dash_charts/utils_static/#dash_chartsutils_static","text":"Utilities for generating static HTML reports. View Source \"\"\"Utilities for generating static HTML reports.\"\"\" import io from base64 import b64encode import dash_bootstrap_components as dbc import dominate import markdown import pandas as pd import plotly.io from bs4 import BeautifulSoup from dominate import tags , util def write_div ( figure , path_or_file_object , is_div = True , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object is_div: if True (default) will override html_kwargs to only write the minimum HTML needed html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` \"\"\" for key in [ 'include_plotlyjs' , 'full_html' ]: if key not in html_kwargs and is_div : html_kwargs [ key ] = False plotly . io . write_html ( fig = figure , file = path_or_file_object , ** html_kwargs ) def make_div ( figure , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` Returns: str: HTML div \"\"\" with io . StringIO () as output : write_div ( figure , output , is_div = True , ** html_kwargs ) return output . getvalue () def add_image ( image_path , alt_text = None ): \"\"\"Write base64 image to HTML. Args: image_path: Path to image file and format will be read from file suffix. alt_text: alternate text. If None, will show the image filename Returns: str: HTML \"\"\" with open ( image_path , 'rb' ) as image_file : encoded_image = b64encode ( image_file . read ()) . decode () image_uri = f 'data:image/ { image_path . suffix [ 1 :] } ;base64, { encoded_image } ' return f '<img src=\" { image_uri } \" alt=\" { alt_text or image_path . name } \"/>' def add_video ( video_path , alt_text = None ): \"\"\"Write base64 video to HTML. Video formats can easily be converted with ffmpeg: `ffmpeg -i video_filename.mov video_filename.webm` Args: video_path: Path to video file and format will be read from file suffix. Video should be in webm format alt_text: alternate text. If None, will show the video filename Returns: str: HTML video tag \"\"\" with open ( video_path , 'rb' ) as video_file : encoded_video = b64encode ( video_file . read ()) . decode () video_uri = f 'data:video/ { video_path . suffix [ 1 :] } ;base64, { encoded_video } ' return f '<video src=\" { video_uri } \" controls> { alt_text or video_path . name } </video>' def write_image_file ( figure , path_or_file_object , image_format , ** img_kwargs ): \"\"\"Write Plotly figure as an image to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object image_format: one of `(png, jpg, jpeg, webp, svg, pdf)` img_kwargs: additional keyword arguments passed to `plotly.io.write_image()` \"\"\" plotly . io . write_image ( fig = figure , file = str ( path_or_file_object ), format = image_format , ** img_kwargs ) def capture_plotly_body (): \"\"\"Return HTML body that includes necessary scripts for Plotly and MathJax. Returns: tuple: of the top and the bottom HTML content \"\"\" # Capture necessary Plotly boilerplate HTML with io . StringIO () as output : write_div ({}, output , is_div = False , include_mathjax = '.js' , validate = False ) blank_plotly = BeautifulSoup ( output . getvalue (), features = 'lxml' ) # Remove the empty figure div and corresponding script plot_div = blank_plotly . find ( 'div' , attrs = { 'class' : 'plotly-graph-div' }) for script in blank_plotly . find_all ( 'script' )[:: - 1 ]: # Use the ID from the plot to identify which script needs to be removed if plot_div . attrs [ 'id' ] in script . prettify (): script . decompose () break plot_div . decompose () return blank_plotly . body . prettify () def format_plotly_boilerplate ( ** doc_kwargs ): \"\"\"Initialize a boilerplate dominate document for creating static Plotly HTML files. See dominate documentation: https://pypi.org/project/dominate/ Args: doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" doc = dominate . document ( ** doc_kwargs ) with doc : util . raw ( capture_plotly_body ()) return doc def create_dbc_doc ( theme = dbc . themes . BOOTSTRAP , custom_styles = '' , ** doc_kwargs ): \"\"\"Create boilerplate dominate document with Bootstrap and Plotly for static HTML. Based on: https://github.com/facultyai/dash-bootstrap-components/tree/master/docs/templates/partials See dominate documentation: https://pypi.org/project/dominate/ Args: theme: string URL to CSS for theming Bootstrap. Default is `dbc.themes.BOOTSTRAP` custom_styles: optional custom CSS to add to file. Default is blank (`''`) doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" stylesheets = [ { 'href' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/styles/a11y-light.min.css' }, { 'href' : theme }, ] scripts = [ { 'src' : 'https://code.jquery.com/jquery-3.4.1.slim.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js' }, { 'src' : 'https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/highlight.min.js' }, ] doc = format_plotly_boilerplate ( ** doc_kwargs ) with doc . head : tags . meta ( charset = 'utf-8' ) tags . meta ( name = 'viewport' , content = 'width=device-width, initial-scale=1' ) for sheet_kwargs in stylesheets : tags . link ( rel = 'stylesheet' , ** sheet_kwargs ) util . raw ( f '<style> { custom_styles } </style>' ) for script_kwargs in scripts : tags . script ( ** script_kwargs ) util . raw ( '<script>hljs.initHighlightingOnLoad();</script>' ) return doc def tag_code ( text , language = '' ): \"\"\"Format HTML for a `pre.code` block with specified `hljs` language. Args: text: string to show in code block language: `hljs` language (ex: `'language-json'`). Default is `''`. \"\"\" tags . pre () . add ( tags . code ( text , _class = f ' { language } hljs' )) def tag_markdown ( text , ** markdown_kwargs ): \"\"\"Format markdown text as HTML. Args: text: markdown string markdown_kwargs: additional keyword arguments for `markdown.markdown`, such as `extensions` \"\"\" util . raw ( markdown . markdown ( text , ** markdown_kwargs )) def tag_table ( df_table , table_class = None ): \"\"\"Format HTML for a responsive Bootstrap table. See Bootstrap documentation at: https://getbootstrap.com/docs/4.4/content/tables/#tables Args: df_table: pandas dataframe to show in table table_class: string classes to add to table. If None, will use default string Raises: RuntimeError: if `df_table` is not a DataFrame object \"\"\" if table_class is None : table_class = 'table table-bordered table-striped table-hover' if not isinstance ( df_table , pd . core . frame . DataFrame ): raise RuntimeError ( f 'df_table is not a DataFrame ( { type ( df_table ) } ): \\n { df_table } ' ) df_table = df_table . reset_index () with tags . div ( _class = 'table-responsive' ) . add ( tags . table ( _class = table_class )): # Create header row with tags . thead () . add ( tags . tr ()): for col in df_table . columns : tags . th ( col ) # Create body rows with tags . tbody (): for row in df_table . itertuples ( index = False ): with tags . tr (): for value in row : tags . td ( str ( value )) def write_lookup ( key , function_lookup ): \"\"\"Determine the lookup result and add to the file. Args: key: string key for function lookup function_lookup: dictionary with either the string result or equation and arguments Raises: RuntimeError: if error in lookup dictionary \"\"\" try : match = function_lookup [ key ] except KeyError : raise RuntimeError ( f 'Could not find \" { key } \" in { function_lookup } ' ) if isinstance ( match , str ): util . raw ( match ) elif len ( match ) == 2 : fun , args = match result = fun ( * args ) if isinstance ( result , str ): util . raw ( result ) else : raise RuntimeError ( f 'Match failed for \" { key } \". Returned: { match } from { function_lookup } ' ) def markdown_machine ( lines , function_lookup ): # noqa: CCR001 \"\"\"Convert markdown text file into Plotly-HTML and write to doc context. Note: you will need a document with necessary boilerplate and call this within a `with doc:` dominate context Multiple Markdown files can then be put into a single HTML output file by calling this function with new lines and function lookup arguments Args: lines: list of text file lines function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` \"\"\" markdown_lines = [] for line in lines : if line . startswith ( '>>lookup:' ): # Write stored markdown and clear list. Then write the matched lookup tag_markdown ( ' \\n ' . join ( markdown_lines )) markdown_lines = [] write_lookup ( line . split ( '>>lookup:' )[ 1 ], function_lookup ) else : markdown_lines . append ( line ) if markdown_lines : tag_markdown ( ' \\n ' . join ( markdown_lines )) def write_from_markdown ( filename , function_lookup , ** dbc_kwargs ): \"\"\"Wrap markdown_machine to convert markdown to Bootstrap HTML. Args: filename: path to markdown file function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` dbc_kwargs: keyword arguments to pass to `create_dbc_doc` Returns: Path: created HTML filename \"\"\" lines = filename . read_text () . split ( ' \\n ' ) html_filename = filename . parent / f ' { filename . stem } .html' doc = create_dbc_doc ( ** dbc_kwargs ) with doc : with tags . div ( _class = 'container' ) . add ( tags . div ( _class = 'col' )): markdown_machine ( lines , function_lookup ) html_filename . write_text ( str ( doc )) return html_filename","title":"dash_charts.utils_static"},{"location":"modules/dash_charts/utils_static/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_static/#add_image","text":"def add_image ( image_path , alt_text = None ) Write base64 image to HTML. Parameters: Name Description image_path Path to image file and format will be read from file suffix. alt_text alternate text. If None, will show the image filename Returns: Type Description str HTML View Source def add_image ( image_path , alt_text = None ): \"\"\"Write base64 image to HTML. Args: image_path: Path to image file and format will be read from file suffix. alt_text: alternate text. If None, will show the image filename Returns: str: HTML \"\"\" with open ( image_path , 'rb' ) as image_file : encoded_image = b64encode ( image_file . read ()) . decode () image_uri = f 'data:image/ { image_path . suffix [ 1 :] } ;base64, { encoded_image } ' return f '<img src=\" { image_uri } \" alt=\" { alt_text or image_path . name } \"/>'","title":"add_image"},{"location":"modules/dash_charts/utils_static/#add_video","text":"def add_video ( video_path , alt_text = None ) Write base64 video to HTML. Video formats can easily be converted with ffmpeg: ffmpeg -i video_filename.mov video_filename.webm Parameters: Name Description video_path Path to video file and format will be read from file suffix. Video should be in webm format alt_text alternate text. If None, will show the video filename Returns: Type Description str HTML video tag View Source def add_video ( video_path , alt_text = None ): \"\"\"Write base64 video to HTML. Video formats can easily be converted with ffmpeg: `ffmpeg -i video_filename.mov video_filename.webm` Args: video_path: Path to video file and format will be read from file suffix. Video should be in webm format alt_text: alternate text. If None, will show the video filename Returns: str: HTML video tag \"\"\" with open ( video_path , 'rb' ) as video_file : encoded_video = b64encode ( video_file . read ()) . decode () video_uri = f 'data:video/ { video_path . suffix [ 1 :] } ;base64, { encoded_video } ' return f '<video src=\" { video_uri } \" controls> { alt_text or video_path . name } </video>'","title":"add_video"},{"location":"modules/dash_charts/utils_static/#capture_plotly_body","text":"def capture_plotly_body () Return HTML body that includes necessary scripts for Plotly and MathJax. Returns: Type Description tuple of the top and the bottom HTML content View Source def capture_plotly_body (): \"\"\"Return HTML body that includes necessary scripts for Plotly and MathJax. Returns: tuple: of the top and the bottom HTML content \"\"\" # Capture necessary Plotly boilerplate HTML with io . StringIO () as output : write_div ({}, output , is_div = False , include_mathjax = '.js' , validate = False ) blank_plotly = BeautifulSoup ( output . getvalue (), features = 'lxml' ) # Remove the empty figure div and corresponding script plot_div = blank_plotly . find ( 'div' , attrs = { 'class' : 'plotly-graph-div' }) for script in blank_plotly . find_all ( 'script' )[:: - 1 ]: # Use the ID from the plot to identify which script needs to be removed if plot_div . attrs [ 'id' ] in script . prettify (): script . decompose () break plot_div . decompose () return blank_plotly . body . prettify ()","title":"capture_plotly_body"},{"location":"modules/dash_charts/utils_static/#create_dbc_doc","text":"def create_dbc_doc ( theme = 'https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css' , custom_styles = '' , ** doc_kwargs ) Create boilerplate dominate document with Bootstrap and Plotly for static HTML. Based on: https://github.com/facultyai/dash-bootstrap-components/tree/master/docs/templates/partials See dominate documentation: https://pypi.org/project/dominate/ Parameters: Name Description theme string URL to CSS for theming Bootstrap. Default is dbc.themes.BOOTSTRAP custom_styles optional custom CSS to add to file. Default is blank ( '' ) doc_kwargs keyword arguments for dominate.document() Returns: Type Description dict dominate document instance View Source def create_dbc_doc ( theme = dbc . themes . BOOTSTRAP , custom_styles = '' , ** doc_kwargs ): \"\"\"Create boilerplate dominate document with Bootstrap and Plotly for static HTML. Based on: https://github.com/facultyai/dash-bootstrap-components/tree/master/docs/templates/partials See dominate documentation: https://pypi.org/project/dominate/ Args: theme: string URL to CSS for theming Bootstrap. Default is `dbc.themes.BOOTSTRAP` custom_styles: optional custom CSS to add to file. Default is blank (`''`) doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" stylesheets = [ { 'href' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/styles/a11y-light.min.css' }, { 'href' : theme }, ] scripts = [ { 'src' : 'https://code.jquery.com/jquery-3.4.1.slim.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js' }, { 'src' : 'https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js' }, { 'src' : 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/highlight.min.js' }, ] doc = format_plotly_boilerplate ( ** doc_kwargs ) with doc . head : tags . meta ( charset = 'utf-8' ) tags . meta ( name = 'viewport' , content = 'width=device-width, initial-scale=1' ) for sheet_kwargs in stylesheets : tags . link ( rel = 'stylesheet' , ** sheet_kwargs ) util . raw ( f '<style> { custom_styles } </style>' ) for script_kwargs in scripts : tags . script ( ** script_kwargs ) util . raw ( '<script>hljs.initHighlightingOnLoad();</script>' ) return doc","title":"create_dbc_doc"},{"location":"modules/dash_charts/utils_static/#format_plotly_boilerplate","text":"def format_plotly_boilerplate ( ** doc_kwargs ) Initialize a boilerplate dominate document for creating static Plotly HTML files. See dominate documentation: https://pypi.org/project/dominate/ Parameters: Name Description doc_kwargs keyword arguments for dominate.document() Returns: Type Description dict dominate document instance View Source def format_plotly_boilerplate ( ** doc_kwargs ): \"\"\"Initialize a boilerplate dominate document for creating static Plotly HTML files. See dominate documentation: https://pypi.org/project/dominate/ Args: doc_kwargs: keyword arguments for `dominate.document()` Returns: dict: dominate document instance \"\"\" doc = dominate . document ( ** doc_kwargs ) with doc : util . raw ( capture_plotly_body ()) return doc","title":"format_plotly_boilerplate"},{"location":"modules/dash_charts/utils_static/#make_div","text":"def make_div ( figure , ** html_kwargs ) Write Plotly figure as HTML to specified file. Parameters: Name Description figure Plotly figure (can be from create_figure for custom charts) html_kwargs additional keyword arguments passed to plotly.io.write_html() Returns: Type Description str HTML div View Source def make_div ( figure , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` Returns: str: HTML div \"\"\" with io . StringIO () as output : write_div ( figure , output , is_div = True , ** html_kwargs ) return output . getvalue ()","title":"make_div"},{"location":"modules/dash_charts/utils_static/#markdown_machine","text":"def markdown_machine ( lines , function_lookup ) Convert markdown text file into Plotly-HTML and write to doc context. Note: you will need a document with necessary boilerplate and call this within a with doc: dominate context Multiple Markdown files can then be put into a single HTML output file by calling this function with new lines and function lookup arguments Parameters: Name Description lines list of text file lines function_lookup dictionary with either the string result or equation and arguments Will be inserted into file where >>lookup:function_name assuming key of function_name View Source def markdown_machine ( lines , function_lookup ): # noqa: CCR001 \"\"\"Convert markdown text file into Plotly-HTML and write to doc context. Note: you will need a document with necessary boilerplate and call this within a `with doc:` dominate context Multiple Markdown files can then be put into a single HTML output file by calling this function with new lines and function lookup arguments Args: lines: list of text file lines function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` \"\"\" markdown_lines = [] for line in lines : if line . startswith ( '>>lookup:' ): # Write stored markdown and clear list. Then write the matched lookup tag_markdown ( ' \\n ' . join ( markdown_lines )) markdown_lines = [] write_lookup ( line . split ( '>>lookup:' )[ 1 ], function_lookup ) else : markdown_lines . append ( line ) if markdown_lines : tag_markdown ( ' \\n ' . join ( markdown_lines ))","title":"markdown_machine"},{"location":"modules/dash_charts/utils_static/#tag_code","text":"def tag_code ( text , language = '' ) Format HTML for a pre.code block with specified hljs language. Parameters: Name Description text string to show in code block language hljs language (ex: 'language-json' ). Default is '' . View Source def tag_code ( text , language = '' ): \"\"\"Format HTML for a `pre.code` block with specified `hljs` language. Args: text: string to show in code block language: `hljs` language (ex: `'language-json'`). Default is `''`. \"\"\" tags . pre () . add ( tags . code ( text , _class = f ' { language } hljs' ))","title":"tag_code"},{"location":"modules/dash_charts/utils_static/#tag_markdown","text":"def tag_markdown ( text , ** markdown_kwargs ) Format markdown text as HTML. Parameters: Name Description text markdown string markdown_kwargs additional keyword arguments for markdown.markdown , such as extensions View Source def tag_markdown ( text , ** markdown_kwargs ): \"\"\"Format markdown text as HTML. Args: text: markdown string markdown_kwargs: additional keyword arguments for `markdown.markdown`, such as `extensions` \"\"\" util . raw ( markdown . markdown ( text , ** markdown_kwargs ))","title":"tag_markdown"},{"location":"modules/dash_charts/utils_static/#tag_table","text":"def tag_table ( df_table , table_class = None ) Format HTML for a responsive Bootstrap table. See Bootstrap documentation at: https://getbootstrap.com/docs/4.4/content/tables/#tables Parameters: Name Description df_table pandas dataframe to show in table table_class string classes to add to table. If None, will use default string Raises: Type Description RuntimeError if df_table is not a DataFrame object View Source def tag_table ( df_table , table_class = None ): \"\"\"Format HTML for a responsive Bootstrap table. See Bootstrap documentation at: https://getbootstrap.com/docs/4.4/content/tables/#tables Args: df_table: pandas dataframe to show in table table_class: string classes to add to table. If None, will use default string Raises: RuntimeError: if `df_table` is not a DataFrame object \"\"\" if table_class is None : table_class = 'table table-bordered table-striped table-hover' if not isinstance ( df_table , pd . core . frame . DataFrame ): raise RuntimeError ( f 'df_table is not a DataFrame ( { type ( df_table ) } ): \\n { df_table } ' ) df_table = df_table . reset_index () with tags . div ( _class = 'table-responsive' ) . add ( tags . table ( _class = table_class )): # Create header row with tags . thead () . add ( tags . tr ()): for col in df_table . columns : tags . th ( col ) # Create body rows with tags . tbody (): for row in df_table . itertuples ( index = False ): with tags . tr (): for value in row : tags . td ( str ( value ))","title":"tag_table"},{"location":"modules/dash_charts/utils_static/#write_div","text":"def write_div ( figure , path_or_file_object , is_div = True , ** html_kwargs ) Write Plotly figure as HTML to specified file. Parameters: Name Description figure Plotly figure (can be from create_figure for custom charts) path_or_file_object string path or file object is_div if True (default) will override html_kwargs to only write the minimum HTML needed html_kwargs additional keyword arguments passed to plotly.io.write_html() View Source def write_div ( figure , path_or_file_object , is_div = True , ** html_kwargs ): \"\"\"Write Plotly figure as HTML to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object is_div: if True (default) will override html_kwargs to only write the minimum HTML needed html_kwargs: additional keyword arguments passed to `plotly.io.write_html()` \"\"\" for key in [ 'include_plotlyjs' , 'full_html' ]: if key not in html_kwargs and is_div : html_kwargs [ key ] = False plotly . io . write_html ( fig = figure , file = path_or_file_object , ** html_kwargs )","title":"write_div"},{"location":"modules/dash_charts/utils_static/#write_from_markdown","text":"def write_from_markdown ( filename , function_lookup , ** dbc_kwargs ) Wrap markdown_machine to convert markdown to Bootstrap HTML. Parameters: Name Description filename path to markdown file function_lookup dictionary with either the string result or equation and arguments Will be inserted into file where >>lookup:function_name assuming key of function_name dbc_kwargs keyword arguments to pass to create_dbc_doc Returns: Type Description Path created HTML filename View Source def write_from_markdown ( filename , function_lookup , ** dbc_kwargs ): \"\"\"Wrap markdown_machine to convert markdown to Bootstrap HTML. Args: filename: path to markdown file function_lookup: dictionary with either the string result or equation and arguments Will be inserted into file where `>>lookup:function_name` assuming key of `function_name` dbc_kwargs: keyword arguments to pass to `create_dbc_doc` Returns: Path: created HTML filename \"\"\" lines = filename . read_text () . split ( ' \\n ' ) html_filename = filename . parent / f ' { filename . stem } .html' doc = create_dbc_doc ( ** dbc_kwargs ) with doc : with tags . div ( _class = 'container' ) . add ( tags . div ( _class = 'col' )): markdown_machine ( lines , function_lookup ) html_filename . write_text ( str ( doc )) return html_filename","title":"write_from_markdown"},{"location":"modules/dash_charts/utils_static/#write_image_file","text":"def write_image_file ( figure , path_or_file_object , image_format , ** img_kwargs ) Write Plotly figure as an image to specified file. Parameters: Name Description figure Plotly figure (can be from create_figure for custom charts) path_or_file_object string path or file object image_format one of (png, jpg, jpeg, webp, svg, pdf) img_kwargs additional keyword arguments passed to plotly.io.write_image() View Source def write_image_file ( figure , path_or_file_object , image_format , ** img_kwargs ): \"\"\"Write Plotly figure as an image to specified file. Args: figure: Plotly figure (can be from `create_figure` for custom charts) path_or_file_object: *string* path or file object image_format: one of `(png, jpg, jpeg, webp, svg, pdf)` img_kwargs: additional keyword arguments passed to `plotly.io.write_image()` \"\"\" plotly . io . write_image ( fig = figure , file = str ( path_or_file_object ), format = image_format , ** img_kwargs )","title":"write_image_file"},{"location":"modules/dash_charts/utils_static/#write_lookup","text":"def write_lookup ( key , function_lookup ) Determine the lookup result and add to the file. Parameters: Name Description key string key for function lookup function_lookup dictionary with either the string result or equation and arguments Raises: Type Description RuntimeError if error in lookup dictionary View Source def write_lookup ( key , function_lookup ): \"\"\"Determine the lookup result and add to the file. Args: key: string key for function lookup function_lookup: dictionary with either the string result or equation and arguments Raises: RuntimeError: if error in lookup dictionary \"\"\" try : match = function_lookup [ key ] except KeyError : raise RuntimeError ( f 'Could not find \" { key } \" in { function_lookup } ' ) if isinstance ( match , str ): util . raw ( match ) elif len ( match ) == 2 : fun , args = match result = fun ( * args ) if isinstance ( result , str ): util . raw ( result ) else : raise RuntimeError ( f 'Match failed for \" { key } \". Returned: { match } from { function_lookup } ' )","title":"write_lookup"},{"location":"modules/dash_charts/utils_static_toc/","text":"dash_charts.utils_static_toc \u2693\ufe0e Add a nested Table of Contents to any HTML file with BeautifulSoup and dominate. View Source \"\"\"Add a nested Table of Contents to any HTML file with BeautifulSoup and dominate.\"\"\" from bs4 import BeautifulSoup from dominate import tags TOC_KEYWORD = '{{toc}}' \"\"\"Default string to replace in the specified file with the nested table of contents. Default is `{{toc}}`.\"\"\" def add_nested_list_item ( l_index , l_string , level = 1 ): \"\"\"Add nested list items recursively. Args: l_index: numeric index of the list depth (note: 1-indexed) l_string: string to show in the list element level: current list depth. Optional and default is 1 \"\"\" with tags . ul (): if l_index != level : add_nested_list_item ( l_index , l_string , level + 1 ) else : tags . li ( f 'H { l_index } : { l_string } ' ) def create_toc ( html_text , header_depth = 3 ): \"\"\"Return the HTML for a nested table of contents based on the HTML file path. Args: html_text: HTML text header_depth: depth of headers to show. Default is 3 (H1-H3) Returns: string: table of contents \"\"\" soup = BeautifulSoup ( html_text , features = 'lxml' ) h_lookup = { f 'h { idx } ' : idx for idx in range ( 1 , header_depth + 1 )} toc = tags . div () for header in soup . findAll ([ * h_lookup . keys ()]): with toc : add_nested_list_item ( h_lookup [ header . name ], header . string ) # FIXME: Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) # > `tags.a(header.string, f'#{header.string}')`? return str ( toc ) def write_toc ( html_path , header_depth = 3 , toc_key = TOC_KEYWORD ): \"\"\"Write the nested table of contents to the specified file. Args: html_path: path to the HTML file header_depth: depth of headers to show. Default is 3 (H1-H3) toc_key: string to replace with the nested table of contents. Default is `TOC_KEYWORD` Raises: RuntimeError: if the key was not found in the file \"\"\" text = html_path . read_text () if toc_key not in text : raise RuntimeError ( f 'HTML file does not have the table of contents key ( { toc_key } ): { html_path } ' ) toc = create_toc ( text , header_depth = header_depth ) html_path . write_text ( text . replace ( '{{toc}}' , toc )) Variables \u2693\ufe0e TOC_KEYWORD Default string to replace in the specified file with the nested table of contents. Default is {{toc}} . Functions \u2693\ufe0e add_nested_list_item \u2693\ufe0e def add_nested_list_item ( l_index , l_string , level = 1 ) Add nested list items recursively. Parameters: Name Description l_index numeric index of the list depth (note: 1-indexed) l_string string to show in the list element level current list depth. Optional and default is 1 View Source def add_nested_list_item ( l_index , l_string , level = 1 ): \"\"\"Add nested list items recursively. Args: l_index: numeric index of the list depth (note: 1-indexed) l_string: string to show in the list element level: current list depth. Optional and default is 1 \"\"\" with tags . ul (): if l_index != level : add_nested_list_item ( l_index , l_string , level + 1 ) else : tags . li ( f 'H { l_index } : { l_string } ' ) create_toc \u2693\ufe0e def create_toc ( html_text , header_depth = 3 ) Return the HTML for a nested table of contents based on the HTML file path. Parameters: Name Description html_text HTML text header_depth depth of headers to show. Default is 3 (H1-H3) Returns: Type Description string table of contents View Source def create_toc ( html_text , header_depth = 3 ): \"\"\"Return the HTML for a nested table of contents based on the HTML file path. Args: html_text: HTML text header_depth: depth of headers to show. Default is 3 (H1-H3) Returns: string: table of contents \"\"\" soup = BeautifulSoup ( html_text , features = 'lxml' ) h_lookup = { f 'h { idx } ' : idx for idx in range ( 1 , header_depth + 1 )} toc = tags . div () for header in soup . findAll ([ * h_lookup . keys ()]): with toc : add_nested_list_item ( h_lookup [ header . name ], header . string ) # FIXME: Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) # > `tags.a(header.string, f'#{header.string}')`? return str ( toc ) write_toc \u2693\ufe0e def write_toc ( html_path , header_depth = 3 , toc_key = '{{toc}}' ) Write the nested table of contents to the specified file. Parameters: Name Description html_path path to the HTML file header_depth depth of headers to show. Default is 3 (H1-H3) toc_key string to replace with the nested table of contents. Default is TOC_KEYWORD Raises: Type Description RuntimeError if the key was not found in the file View Source def write_toc ( html_path , header_depth = 3 , toc_key = TOC_KEYWORD ): \"\"\"Write the nested table of contents to the specified file. Args: html_path: path to the HTML file header_depth: depth of headers to show. Default is 3 (H1-H3) toc_key: string to replace with the nested table of contents. Default is `TOC_KEYWORD` Raises: RuntimeError: if the key was not found in the file \"\"\" text = html_path . read_text () if toc_key not in text : raise RuntimeError ( f 'HTML file does not have the table of contents key ( { toc_key } ): { html_path } ' ) toc = create_toc ( text , header_depth = header_depth ) html_path . write_text ( text . replace ( '{{toc}}' , toc ))","title":"dash_charts.utils_static_toc"},{"location":"modules/dash_charts/utils_static_toc/#dash_chartsutils_static_toc","text":"Add a nested Table of Contents to any HTML file with BeautifulSoup and dominate. View Source \"\"\"Add a nested Table of Contents to any HTML file with BeautifulSoup and dominate.\"\"\" from bs4 import BeautifulSoup from dominate import tags TOC_KEYWORD = '{{toc}}' \"\"\"Default string to replace in the specified file with the nested table of contents. Default is `{{toc}}`.\"\"\" def add_nested_list_item ( l_index , l_string , level = 1 ): \"\"\"Add nested list items recursively. Args: l_index: numeric index of the list depth (note: 1-indexed) l_string: string to show in the list element level: current list depth. Optional and default is 1 \"\"\" with tags . ul (): if l_index != level : add_nested_list_item ( l_index , l_string , level + 1 ) else : tags . li ( f 'H { l_index } : { l_string } ' ) def create_toc ( html_text , header_depth = 3 ): \"\"\"Return the HTML for a nested table of contents based on the HTML file path. Args: html_text: HTML text header_depth: depth of headers to show. Default is 3 (H1-H3) Returns: string: table of contents \"\"\" soup = BeautifulSoup ( html_text , features = 'lxml' ) h_lookup = { f 'h { idx } ' : idx for idx in range ( 1 , header_depth + 1 )} toc = tags . div () for header in soup . findAll ([ * h_lookup . keys ()]): with toc : add_nested_list_item ( h_lookup [ header . name ], header . string ) # FIXME: Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) # > `tags.a(header.string, f'#{header.string}')`? return str ( toc ) def write_toc ( html_path , header_depth = 3 , toc_key = TOC_KEYWORD ): \"\"\"Write the nested table of contents to the specified file. Args: html_path: path to the HTML file header_depth: depth of headers to show. Default is 3 (H1-H3) toc_key: string to replace with the nested table of contents. Default is `TOC_KEYWORD` Raises: RuntimeError: if the key was not found in the file \"\"\" text = html_path . read_text () if toc_key not in text : raise RuntimeError ( f 'HTML file does not have the table of contents key ( { toc_key } ): { html_path } ' ) toc = create_toc ( text , header_depth = header_depth ) html_path . write_text ( text . replace ( '{{toc}}' , toc ))","title":"dash_charts.utils_static_toc"},{"location":"modules/dash_charts/utils_static_toc/#variables","text":"TOC_KEYWORD Default string to replace in the specified file with the nested table of contents. Default is {{toc}} .","title":"Variables"},{"location":"modules/dash_charts/utils_static_toc/#functions","text":"","title":"Functions"},{"location":"modules/dash_charts/utils_static_toc/#add_nested_list_item","text":"def add_nested_list_item ( l_index , l_string , level = 1 ) Add nested list items recursively. Parameters: Name Description l_index numeric index of the list depth (note: 1-indexed) l_string string to show in the list element level current list depth. Optional and default is 1 View Source def add_nested_list_item ( l_index , l_string , level = 1 ): \"\"\"Add nested list items recursively. Args: l_index: numeric index of the list depth (note: 1-indexed) l_string: string to show in the list element level: current list depth. Optional and default is 1 \"\"\" with tags . ul (): if l_index != level : add_nested_list_item ( l_index , l_string , level + 1 ) else : tags . li ( f 'H { l_index } : { l_string } ' )","title":"add_nested_list_item"},{"location":"modules/dash_charts/utils_static_toc/#create_toc","text":"def create_toc ( html_text , header_depth = 3 ) Return the HTML for a nested table of contents based on the HTML file path. Parameters: Name Description html_text HTML text header_depth depth of headers to show. Default is 3 (H1-H3) Returns: Type Description string table of contents View Source def create_toc ( html_text , header_depth = 3 ): \"\"\"Return the HTML for a nested table of contents based on the HTML file path. Args: html_text: HTML text header_depth: depth of headers to show. Default is 3 (H1-H3) Returns: string: table of contents \"\"\" soup = BeautifulSoup ( html_text , features = 'lxml' ) h_lookup = { f 'h { idx } ' : idx for idx in range ( 1 , header_depth + 1 )} toc = tags . div () for header in soup . findAll ([ * h_lookup . keys ()]): with toc : add_nested_list_item ( h_lookup [ header . name ], header . string ) # FIXME: Figure out how to make the header links work (i.e. when clicked in TOC go to the respective header) # > `tags.a(header.string, f'#{header.string}')`? return str ( toc )","title":"create_toc"},{"location":"modules/dash_charts/utils_static_toc/#write_toc","text":"def write_toc ( html_path , header_depth = 3 , toc_key = '{{toc}}' ) Write the nested table of contents to the specified file. Parameters: Name Description html_path path to the HTML file header_depth depth of headers to show. Default is 3 (H1-H3) toc_key string to replace with the nested table of contents. Default is TOC_KEYWORD Raises: Type Description RuntimeError if the key was not found in the file View Source def write_toc ( html_path , header_depth = 3 , toc_key = TOC_KEYWORD ): \"\"\"Write the nested table of contents to the specified file. Args: html_path: path to the HTML file header_depth: depth of headers to show. Default is 3 (H1-H3) toc_key: string to replace with the nested table of contents. Default is `TOC_KEYWORD` Raises: RuntimeError: if the key was not found in the file \"\"\" text = html_path . read_text () if toc_key not in text : raise RuntimeError ( f 'HTML file does not have the table of contents key ( { toc_key } ): { html_path } ' ) toc = create_toc ( text , header_depth = header_depth ) html_path . write_text ( text . replace ( '{{toc}}' , toc ))","title":"write_toc"}]}